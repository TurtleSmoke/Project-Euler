<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Project Euler</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Solution of Project Euler problems">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="problems/project_euler.html"><strong aria-hidden="true">2.</strong> Project Euler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0001/problem.html"><strong aria-hidden="true">2.1.</strong> Problem 1: Multiples of 3 or 5</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0001/solution1.html"><strong aria-hidden="true">2.1.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0001/solution2.html"><strong aria-hidden="true">2.1.2.</strong> Three by three</a></li><li class="chapter-item "><a href="problems/problem_0001/solution3.html"><strong aria-hidden="true">2.1.3.</strong> Summing everything</a></li><li class="chapter-item "><a href="problems/problem_0001/solution.html"><strong aria-hidden="true">2.1.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0002/problem.html"><strong aria-hidden="true">2.2.</strong> Problem 2: even Fibonacci numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0002/solution1.html"><strong aria-hidden="true">2.2.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0002/solution2.html"><strong aria-hidden="true">2.2.2.</strong> Fibonacci recurrence</a></li><li class="chapter-item "><a href="problems/problem_0002/solution3.html"><strong aria-hidden="true">2.2.3.</strong> Fibonacci and the golden ratio</a></li><li class="chapter-item "><a href="problems/problem_0002/solution.html"><strong aria-hidden="true">2.2.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0003/problem.html"><strong aria-hidden="true">2.3.</strong> Problem 3: Largest prime factor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0003/solution1.html"><strong aria-hidden="true">2.3.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0003/solution2.html"><strong aria-hidden="true">2.3.2.</strong> Two by two</a></li><li class="chapter-item "><a href="problems/problem_0003/solution.html"><strong aria-hidden="true">2.3.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0004/problem.html"><strong aria-hidden="true">2.4.</strong> Problem 4: Largest palindrome product</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0004/solution1.html"><strong aria-hidden="true">2.4.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0004/solution2.html"><strong aria-hidden="true">2.4.2.</strong> Factorisation is the key</a></li><li class="chapter-item "><a href="problems/problem_0004/solution3.html"><strong aria-hidden="true">2.4.3.</strong> With pen and paper</a></li><li class="chapter-item "><a href="problems/problem_0004/solution.html"><strong aria-hidden="true">2.4.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0005/problem.html"><strong aria-hidden="true">2.5.</strong> Problem 5: Smallest multiple</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0005/solution1.html"><strong aria-hidden="true">2.5.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0005/solution2.html"><strong aria-hidden="true">2.5.2.</strong> Prime factorization</a></li><li class="chapter-item "><a href="problems/problem_0005/solution3.html"><strong aria-hidden="true">2.5.3.</strong> Least common multiple</a></li><li class="chapter-item "><a href="problems/problem_0005/solution.html"><strong aria-hidden="true">2.5.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0006/problem.html"><strong aria-hidden="true">2.6.</strong> Problem 6: Sum square difference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0006/solution1.html"><strong aria-hidden="true">2.6.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0006/solution2.html"><strong aria-hidden="true">2.6.2.</strong> Summation formula</a></li><li class="chapter-item "><a href="problems/problem_0006/solution.html"><strong aria-hidden="true">2.6.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0007/problem.html"><strong aria-hidden="true">2.7.</strong> Problem 7: 10001st prime</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0007/solution1.html"><strong aria-hidden="true">2.7.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0007/solution2.html"><strong aria-hidden="true">2.7.2.</strong> Almost six by six</a></li><li class="chapter-item "><a href="problems/problem_0007/solution3.html"><strong aria-hidden="true">2.7.3.</strong> Prime number theorem</a></li><li class="chapter-item "><a href="problems/problem_0007/solution.html"><strong aria-hidden="true">2.7.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0008/problem.html"><strong aria-hidden="true">2.8.</strong> Problem 8: Largest product in a series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0008/solution1.html"><strong aria-hidden="true">2.8.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0008/solution2.html"><strong aria-hidden="true">2.8.2.</strong> 0 are useless</a></li><li class="chapter-item "><a href="problems/problem_0008/solution.html"><strong aria-hidden="true">2.8.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0009/problem.html"><strong aria-hidden="true">2.9.</strong> Problem 9: Special Pythagorean triplet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0009/solution1.html"><strong aria-hidden="true">2.9.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0009/solution2.html"><strong aria-hidden="true">2.9.2.</strong> With a little thought</a></li><li class="chapter-item "><a href="problems/problem_0009/solution3.html"><strong aria-hidden="true">2.9.3.</strong> Prime Pythagorean triples</a></li><li class="chapter-item "><a href="problems/problem_0009/solution.html"><strong aria-hidden="true">2.9.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0010/problem.html"><strong aria-hidden="true">2.10.</strong> Problem 10: Summation of primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0010/solution1.html"><strong aria-hidden="true">2.10.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0010/solution2.html"><strong aria-hidden="true">2.10.2.</strong> Summation minus summation</a></li><li class="chapter-item "><a href="problems/problem_0010/solution3.html"><strong aria-hidden="true">2.10.3.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0010/solution.html"><strong aria-hidden="true">2.10.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0011/problem.html"><strong aria-hidden="true">2.11.</strong> Problem 11: Largest product in a grid</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0011/solution1.html"><strong aria-hidden="true">2.11.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0011/solution.html"><strong aria-hidden="true">2.11.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0012/problem.html"><strong aria-hidden="true">2.12.</strong> Problem 12: Highly divisible triangular number</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0012/solution1.html"><strong aria-hidden="true">2.12.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0012/solution2.html"><strong aria-hidden="true">2.12.2.</strong> Common factor</a></li><li class="chapter-item "><a href="problems/problem_0012/solution.html"><strong aria-hidden="true">2.12.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0013/problem.html"><strong aria-hidden="true">2.13.</strong> Problem 13: Large sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0013/solution1.html"><strong aria-hidden="true">2.13.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0013/solution.html"><strong aria-hidden="true">2.13.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0014/problem.html"><strong aria-hidden="true">2.14.</strong> Problem 14: Longest Collatz sequence</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0014/solution1.html"><strong aria-hidden="true">2.14.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0014/solution2.html"><strong aria-hidden="true">2.14.2.</strong> Caching</a></li><li class="chapter-item "><a href="problems/problem_0014/solution.html"><strong aria-hidden="true">2.14.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0015/problem.html"><strong aria-hidden="true">2.15.</strong> Problem 15: Lattice paths</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0015/solution1.html"><strong aria-hidden="true">2.15.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0015/solution2.html"><strong aria-hidden="true">2.15.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0015/solution3.html"><strong aria-hidden="true">2.15.3.</strong> Combination</a></li><li class="chapter-item "><a href="problems/problem_0015/solution.html"><strong aria-hidden="true">2.15.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0016/problem.html"><strong aria-hidden="true">2.16.</strong> Problem 16: Power digit sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0016/solution1.html"><strong aria-hidden="true">2.16.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0016/solution.html"><strong aria-hidden="true">2.16.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0017/problem.html"><strong aria-hidden="true">2.17.</strong> Problem 17: Number letter counts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0017/solution1.html"><strong aria-hidden="true">2.17.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0017/solution.html"><strong aria-hidden="true">2.17.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0018/problem.html"><strong aria-hidden="true">2.18.</strong> Problem 18: Maximum path sum I</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0018/solution1.html"><strong aria-hidden="true">2.18.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0018/solution2.html"><strong aria-hidden="true">2.18.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0018/solution.html"><strong aria-hidden="true">2.18.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0019/problem.html"><strong aria-hidden="true">2.19.</strong> Problem 19: Counting Sundays</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0019/solution1.html"><strong aria-hidden="true">2.19.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0019/solution.html"><strong aria-hidden="true">2.19.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0020/problem.html"><strong aria-hidden="true">2.20.</strong> Problem 20: Factorial digit sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0020/solution1.html"><strong aria-hidden="true">2.20.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0020/solution.html"><strong aria-hidden="true">2.20.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0021/problem.html"><strong aria-hidden="true">2.21.</strong> Problem 21: Amicable numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0021/solution1.html"><strong aria-hidden="true">2.21.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0021/solution.html"><strong aria-hidden="true">2.21.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0022/problem.html"><strong aria-hidden="true">2.22.</strong> Problem 22: Names scores</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0022/solution1.html"><strong aria-hidden="true">2.22.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0022/solution.html"><strong aria-hidden="true">2.22.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0023/problem.html"><strong aria-hidden="true">2.23.</strong> Problem 23: Non-abundant sums</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0023/solution1.html"><strong aria-hidden="true">2.23.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0023/solution2.html"><strong aria-hidden="true">2.23.2.</strong> Set</a></li><li class="chapter-item "><a href="problems/problem_0023/solution.html"><strong aria-hidden="true">2.23.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0024/problem.html"><strong aria-hidden="true">2.24.</strong> Problem 24: Lexicographic permutations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0024/solution1.html"><strong aria-hidden="true">2.24.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0024/solution2.html"><strong aria-hidden="true">2.24.2.</strong> Maths permutations</a></li><li class="chapter-item "><a href="problems/problem_0024/solution.html"><strong aria-hidden="true">2.24.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0025/problem.html"><strong aria-hidden="true">2.25.</strong> Problem 25: 1000-digit Fibonacci number</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0025/solution1.html"><strong aria-hidden="true">2.25.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0025/solution2.html"><strong aria-hidden="true">2.25.2.</strong> Fibonacci convergence</a></li><li class="chapter-item "><a href="problems/problem_0025/solution.html"><strong aria-hidden="true">2.25.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0026/problem.html"><strong aria-hidden="true">2.26.</strong> Problem 26: Reciprocal cycles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0026/solution1.html"><strong aria-hidden="true">2.26.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0026/solution2.html"><strong aria-hidden="true">2.26.2.</strong> Carmichael function</a></li><li class="chapter-item "><a href="problems/problem_0026/solution.html"><strong aria-hidden="true">2.26.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0027/problem.html"><strong aria-hidden="true">2.27.</strong> Problem 27: Quadratic primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0027/solution1.html"><strong aria-hidden="true">2.27.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0027/solution2.html"><strong aria-hidden="true">2.27.2.</strong> Shorten the intervals</a></li><li class="chapter-item "><a href="problems/problem_0027/solution3.html"><strong aria-hidden="true">2.27.3.</strong> Lucky numbers of Euler</a></li><li class="chapter-item "><a href="problems/problem_0027/solution.html"><strong aria-hidden="true">2.27.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0028/problem.html"><strong aria-hidden="true">2.28.</strong> Problem 28: Number spiral diagonals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0028/solution1.html"><strong aria-hidden="true">2.28.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0028/solution2.html"><strong aria-hidden="true">2.28.2.</strong> Summation</a></li><li class="chapter-item "><a href="problems/problem_0028/solution.html"><strong aria-hidden="true">2.28.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0029/problem.html"><strong aria-hidden="true">2.29.</strong> Problem 29: Distinct powers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0029/solution1.html"><strong aria-hidden="true">2.29.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0029/solution2.html"><strong aria-hidden="true">2.29.2.</strong> Discarding duplicate</a></li><li class="chapter-item "><a href="problems/problem_0029/solution.html"><strong aria-hidden="true">2.29.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0030/problem.html"><strong aria-hidden="true">2.30.</strong> Problem 30: Digit fifth powers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0030/solution1.html"><strong aria-hidden="true">2.30.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0030/solution2.html"><strong aria-hidden="true">2.30.2.</strong> Search unique combination</a></li><li class="chapter-item "><a href="problems/problem_0030/solution.html"><strong aria-hidden="true">2.30.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0031/problem.html"><strong aria-hidden="true">2.31.</strong> Problem 31: Coin sums</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0031/solution1.html"><strong aria-hidden="true">2.31.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0031/solution2.html"><strong aria-hidden="true">2.31.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0031/solution3.html"><strong aria-hidden="true">2.31.3.</strong> Better dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0031/solution.html"><strong aria-hidden="true">2.31.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0032/problem.html"><strong aria-hidden="true">2.32.</strong> Problem 32: Pandigital products</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0032/solution1.html"><strong aria-hidden="true">2.32.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0032/solution.html"><strong aria-hidden="true">2.32.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0033/problem.html"><strong aria-hidden="true">2.33.</strong> Problem 33: Digit cancelling fractions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0033/solution1.html"><strong aria-hidden="true">2.33.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0033/solution.html"><strong aria-hidden="true">2.33.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0034/problem.html"><strong aria-hidden="true">2.34.</strong> Problem 34: Digit factorials</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0034/solution1.html"><strong aria-hidden="true">2.34.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0034/solution.html"><strong aria-hidden="true">2.34.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0035/problem.html"><strong aria-hidden="true">2.35.</strong> Problem 35: Circular primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0035/solution1.html"><strong aria-hidden="true">2.35.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0035/solution2.html"><strong aria-hidden="true">2.35.2.</strong> 1, 3, 7, 9</a></li><li class="chapter-item "><a href="problems/problem_0035/solution.html"><strong aria-hidden="true">2.35.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0036/problem.html"><strong aria-hidden="true">2.36.</strong> Problem 36: Double-base palindromes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0036/solution1.html"><strong aria-hidden="true">2.36.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0036/solution2.html"><strong aria-hidden="true">2.36.2.</strong> Generating palindromes</a></li><li class="chapter-item "><a href="problems/problem_0036/solution.html"><strong aria-hidden="true">2.36.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0037/problem.html"><strong aria-hidden="true">2.37.</strong> Problem 37: Truncatable primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0037/solution1.html"><strong aria-hidden="true">2.37.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0037/solution2.html"><strong aria-hidden="true">2.37.2.</strong> Construct them all</a></li><li class="chapter-item "><a href="problems/problem_0037/solution.html"><strong aria-hidden="true">2.37.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0038/problem.html"><strong aria-hidden="true">2.38.</strong> Problem 38: Pandigital multiples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0038/solution1.html"><strong aria-hidden="true">2.38.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0038/solution2.html"><strong aria-hidden="true">2.38.2.</strong> Good old pen and paper</a></li><li class="chapter-item "><a href="problems/problem_0038/solution.html"><strong aria-hidden="true">2.38.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0039/problem.html"><strong aria-hidden="true">2.39.</strong> Problem 39: Integer right triangles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0039/solution1.html"><strong aria-hidden="true">2.39.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0039/solution2.html"><strong aria-hidden="true">2.39.2.</strong> Fewer loops is better</a></li><li class="chapter-item "><a href="problems/problem_0039/solution3.html"><strong aria-hidden="true">2.39.3.</strong> Even fewer loops</a></li><li class="chapter-item "><a href="problems/problem_0039/solution4.html"><strong aria-hidden="true">2.39.4.</strong> Tree of primitive Pythagorean triples</a></li><li class="chapter-item "><a href="problems/problem_0039/solution.html"><strong aria-hidden="true">2.39.5.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0040/problem.html"><strong aria-hidden="true">2.40.</strong> Problem 40: Champernowne's constant</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0040/solution1.html"><strong aria-hidden="true">2.40.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0040/solution2.html"><strong aria-hidden="true">2.40.2.</strong> Foreshadowing</a></li><li class="chapter-item "><a href="problems/problem_0040/solution.html"><strong aria-hidden="true">2.40.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0041/problem.html"><strong aria-hidden="true">2.41.</strong> Problem 41: Pandigital prime</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0041/solution1.html"><strong aria-hidden="true">2.41.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0041/solution.html"><strong aria-hidden="true">2.41.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0042/problem.html"><strong aria-hidden="true">2.42.</strong> Problem 42: Coded triangle numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0042/solution1.html"><strong aria-hidden="true">2.42.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0042/solution.html"><strong aria-hidden="true">2.42.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0043/problem.html"><strong aria-hidden="true">2.43.</strong> Problem 43: Sub-string divisibility</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0043/solution1.html"><strong aria-hidden="true">2.43.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0043/solution2.html"><strong aria-hidden="true">2.43.2.</strong> Generation over iteration</a></li><li class="chapter-item "><a href="problems/problem_0043/solution3.html"><strong aria-hidden="true">2.43.3.</strong> With pen and paper</a></li><li class="chapter-item "><a href="problems/problem_0043/solution.html"><strong aria-hidden="true">2.43.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0044/problem.html"><strong aria-hidden="true">2.44.</strong> Problem 44: Pentagon numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0044/solution1.html"><strong aria-hidden="true">2.44.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0044/solution2.html"><strong aria-hidden="true">2.44.2.</strong> Optimal iteration</a></li><li class="chapter-item "><a href="problems/problem_0044/solution3.html"><strong aria-hidden="true">2.44.3.</strong> Even better iteration</a></li><li class="chapter-item "><a href="problems/problem_0044/solution.html"><strong aria-hidden="true">2.44.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0045/problem.html"><strong aria-hidden="true">2.45.</strong> Problem 45: Triangular, pentagonal, and hexagonal</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0045/solution1.html"><strong aria-hidden="true">2.45.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0045/solution2.html"><strong aria-hidden="true">2.45.2.</strong> Triangular numbers are useless</a></li><li class="chapter-item "><a href="problems/problem_0045/solution3.html"><strong aria-hidden="true">2.45.3.</strong> Diophantine equations</a></li><li class="chapter-item "><a href="problems/problem_0045/solution.html"><strong aria-hidden="true">2.45.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0046/problem.html"><strong aria-hidden="true">2.46.</strong> Problem 46: Goldbach's other conjecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0046/solution1.html"><strong aria-hidden="true">2.46.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0046/solution2.html"><strong aria-hidden="true">2.46.2.</strong> Better iteration and caching</a></li><li class="chapter-item "><a href="problems/problem_0046/solution.html"><strong aria-hidden="true">2.46.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0047/problem.html"><strong aria-hidden="true">2.47.</strong> Problem 47: Distinct primes factors</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0047/solution1.html"><strong aria-hidden="true">2.47.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0047/solution2.html"><strong aria-hidden="true">2.47.2.</strong> Cache is life</a></li><li class="chapter-item "><a href="problems/problem_0047/solution3.html"><strong aria-hidden="true">2.47.3.</strong> Good old Sieve</a></li><li class="chapter-item "><a href="problems/problem_0047/solution.html"><strong aria-hidden="true">2.47.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0048/problem.html"><strong aria-hidden="true">2.48.</strong> Problem 48: Self powers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0048/solution1.html"><strong aria-hidden="true">2.48.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0048/solution2.html"><strong aria-hidden="true">2.48.2.</strong> Modulos reduction</a></li><li class="chapter-item "><a href="problems/problem_0048/solution.html"><strong aria-hidden="true">2.48.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0049/problem.html"><strong aria-hidden="true">2.49.</strong> Problem 49: Prime permutations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0049/solution1.html"><strong aria-hidden="true">2.49.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0049/solution2.html"><strong aria-hidden="true">2.49.2.</strong> Primes permutations</a></li><li class="chapter-item "><a href="problems/problem_0049/solution.html"><strong aria-hidden="true">2.49.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0050/problem.html"><strong aria-hidden="true">2.50.</strong> Problem 50: Consecutive prime sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0050/solution1.html"><strong aria-hidden="true">2.50.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0050/solution2.html"><strong aria-hidden="true">2.50.2.</strong> Cumulative sum</a></li><li class="chapter-item "><a href="problems/problem_0050/solution.html"><strong aria-hidden="true">2.50.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0051/problem.html"><strong aria-hidden="true">2.51.</strong> Problem 51: Prime digit replacements</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0051/solution1.html"><strong aria-hidden="true">2.51.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0051/solution2.html"><strong aria-hidden="true">2.51.2.</strong> Simple observations</a></li><li class="chapter-item "><a href="problems/problem_0051/solution.html"><strong aria-hidden="true">2.51.3.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="usage/usage.html"><strong aria-hidden="true">3.</strong> Usage</a></li><li class="chapter-item expanded "><a href="contributing/contributing.html"><strong aria-hidden="true">4.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Project Euler</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/TurtleSmoke/Project-Euler" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This document gathers explanations on the solutions of the
<a href="https://projecteuler.net">Euler Project</a> exercises.
Each exercise has its own part, which can be discovered in the table of 
contents.
You can find the source code of every solution as well as the source code of my
<a href="https://rust-lang.github.io/mdBook/">mdBook</a> on my <a href="https://github.com/">Github</a>:
<a href="https://github.com/TurtleSmoke/Project-Euler">TurtleSmoke Project Euler</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-euler"><a class="header" href="#project-euler"><a href="https://projecteuler.net/">Project Euler</a></a></h1>
<h2 id="what-is-project-euler"><a class="header" href="#what-is-project-euler"><strong>What is Project Euler?</strong></a></h2>
<blockquote>
<p>Project Euler is a series of challenging mathematical/computer programming
problems that will require more than just mathematical insights to solve.
Although mathematics will help you arrive at elegant and efficient methods,
the use of a computer and programming skills will be required to solve
most problems.</p>
<p>The motivation for starting Project Euler, and its continuation, is to
provide a platform for the inquiring mind to delve into unfamiliar areas
and learn new concepts in a fun and recreational context.</p>
</blockquote>
<h2 id="who-are-the-problems-aimed-at"><a class="header" href="#who-are-the-problems-aimed-at"><strong>Who are the problems aimed at?</strong></a></h2>
<blockquote>
<p>The intended audience include students for whom the basic curriculum is not
feeding their hunger to learn, adults whose background was not primarily
mathematics but had an interest in things mathematical, and professionals
who want to keep their problem solving and mathematics on the cutting edge.</p>
<p>Currently we have 1036139 registered members who have solved at least one
problem, representing 220 locations throughout the world, and collectively
using 108 different programming langues to solve the problems.</p>
</blockquote>
<h2 id="can-anyone-solve-the-problems"><a class="header" href="#can-anyone-solve-the-problems"><strong>Can anyone solve the problems?</strong></a></h2>
<blockquote>
<p>The problems range in difficulty and for many the experience is inductive
chain learning. That is, by solving one problem it will expose you to a
new concept that allows you to undertake a previously inaccessible problem.
So the determined participant will slowly but surely work his/her way
through every problem.</p>
</blockquote>
<h2 id="what-next"><a class="header" href="#what-next"><strong>What next?</strong></a></h2>
<blockquote>
<p>In order to track your progress it is necessary to setup an account and
have Cookies enabled.</p>
<p>If you already have an account, then
<a href="https://projecteuler.net/sign_in">Sign In</a>. Otherwise, please
<a href="https://projecteuler.net/register">Register</a> – it's completely free!
However, as the problems are challenging, then you may wish to view the
<a href="https://projecteuler.net/archives">Problems</a> before registering.</p>
</blockquote>
<hr />
<p style="text-align: center; font-size: 125%; font-style: italic; color: #bbb">
Project Euler exists to encourage, challenge, and develop the skills 
and enjoyment of anyone with an interest in the fascinating world of mathematics.
</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiples-of-3-or-5"><a class="header" href="#multiples-of-3-or-5"><a href="https://projecteuler.net/problem=1">Multiples of 3 or 5</a></a></h1>
<blockquote>
<p>If we list all the natural numbers below \( 10 \) that are multiples of \( 3 \) or \( 5 \), we get \( 3 \), \( 5 \), \( 6 \) and \( 9 \). The sum of these multiples is \( 23 \).</p>
<p>Find the sum of all the multiples of \( 3 \) or \( 5 \) below \( 1000 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force"><a class="header" href="#brute-force">Brute force</a></h1>
<p>The first problem is actually quite easy, the naive solution is to iterate over
each number between 0 and 1000 and check those that are multiples of 3 or 5.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=1000):
    return sum(i for i in range(limit) if i % 3 == 0 or i % 5 == 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="three-by-three"><a class="header" href="#three-by-three">Three by three</a></h1>
<p>The <a href="problems/problem_0001/solution1.html">Brute force</a> is actually quite slow, at least it would be if
the limit was greater than 1000. Since only multiples of 3 and 5 are useful,
iterating 3 by 3 and then 5 by 5 will be faster. We have to be careful with the
multiples of 3 and 5 because they will be counted twice. So we have to subtract
them from the result.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=1000):
    sum_3 = sum(i for i in range(0, limit, 3) if i % 3 == 0)
    sum_5 = sum(i for i in range(0, limit, 5) if i % 5 == 0)
    sum_15 = sum(i for i in range(0, limit, 15) if i % 15 == 0)

    return sum_3 + sum_5 - sum_15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summing-everything"><a class="header" href="#summing-everything">Summing everything</a></h1>
<p>The <a href="problems/problem_0001/solution2.html">Three by three</a> solution is quite interesting because it
reduces the problem into smaller parts. For example, the sum of multiples of
three is the following:</p>
<p>\[ 3 + 6 + 9 + 12 + 15 + ... \]
\[ 3 * ( 1 + 2 + 3 + 4 + 5 ...) \]
\[ 3 * \sum_{i=0}^{\lfloor\frac{1000}{3}\rfloor} x_i \]</p>
<p>It is the sum of an arithmetic sequences, which is equal to:</p>
<p>\[ \frac{n*(n+1)}{2} \]</p>
<p>The <a href="problems/problem_0001/solution2.html">Three by three</a> solution can be reduced to:</p>
<p>\[ 3 * \frac{\lfloor\frac{999}{3}\rfloor * (\lfloor\frac{999}{3}\rfloor + 1)}{2} +5 * \frac{\lfloor\frac{999}{5}\rfloor * (\lfloor\frac{999}{5}\rfloor + 1)}{2} -15 * \frac{\lfloor\frac{999}{15}\rfloor * (\lfloor\frac{999}{15}\rfloor + 1)}{2} \]</p>
<p>Note that the limit is 999 because 1000 should not be included.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=999):
    limit_3 = limit // 3
    limit_5 = limit // 5
    limit_15 = limit // 15

    sum_3 = 3 * (limit_3 * (limit_3 + 1) // 2)
    sum_5 = 5 * (limit_5 * (limit_5 + 1) // 2)
    sum_15 = 15 * (limit_15 * (limit_15 + 1) // 2)

    return sum_3 + sum_5 - sum_15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution"><a class="header" href="#solution">Solution</a></h1>
<hr />
<blockquote>
<p>233168</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-fibonacci-numbers"><a class="header" href="#even-fibonacci-numbers"><a href="https://projecteuler.net/problem=2">Even Fibonacci numbers</a></a></h1>
<blockquote>
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with \( 1 \) and \( 2 \), the first \( 10 \) terms will be:</p>
<p>\[
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
\]</p>
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-1"><a class="header" href="#brute-force-1">Brute force</a></h1>
<blockquote>
<p>The <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a> form
a sequence, called the Fibonacci
<a href="https://en.wikipedia.org/wiki/Integer_sequence">sequence</a>, such that each
number is the sum of the two preceding ones, starting from 0 and 1.</p>
</blockquote>
<p>The sum of all even numbers in the Fibonacci sequence less than 4 million can be
calculated quite easily by iterating over the sequence until the threshold is
reached by adding each even number to the result.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    f0 = 1
    f1 = 2
    res = 0
    while f0 &lt; limit:
        if f0 % 2 == 0:
            res += f0
        f0, f1 = f1, f0 + f1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-recurrence"><a class="header" href="#fibonacci-recurrence">Fibonacci recurrence</a></h1>
<p>If we take a look at the Fibonacci series:</p>
<blockquote>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...</p>
</blockquote>
<p>Since our only concern is the parity of the numbers, with O being odd and E
even:</p>
<blockquote>
<p>E, O, O, E, O, O, E, O, O, E, O, O, E, O, O, E, ...</p>
</blockquote>
<h4 id="it-seems-that-every-third-number-of-the-series-is-even-lets-try-to-prove-it-properly"><a class="header" href="#it-seems-that-every-third-number-of-the-series-is-even-lets-try-to-prove-it-properly">It seems that every third number of the series is even, let's try to prove it properly.</a></h4>
<p>\[ \begin{gather} If\ n=0\ then\ F_{0}=0\ is\ even\\\\ Assuming\ that\ F_ {3n} \ is\ even.\\ \\ F_{3( n+1)} =F_{3n+2} +F_{3n+1} =( F_{3n+1} +F_{3n}) +F_{3n+1} =2F_{3n+1} +F_ {3n}\\ \\ Since\ F_{3n} \ is\ even\ and\ 2F_{3n+1} \ is\ also\ even,\ we\ have\ F_{3( n+1)} \ even\\ because\ it\ is\ the\ sum\ of\ two\ even\ numbers. \end{gather} \]</p>
<h4 id="this-mean-that-the-series-of-even-fibonacci-number-is"><a class="header" href="#this-mean-that-the-series-of-even-fibonacci-number-is">This mean that the series of even Fibonacci number is:</a></h4>
<p>\[ \begin {gather} E_{n} = F_{3n}\\ E_{n+2} = F_{3n+6} = F_{3n+5} + F_ {3n+4}\\ E_{n+2} = (F_{3n+4} + F_{3n+3}) + (F_{3n+3} + F_{3n+2})\\ E_{n+2} = (F_{3n+3} + F_{3n+2} + F_{3n+3}) + (F_{3n+3} + F_{3n+1} + F_{3n})\\ E_{n+2} = 3F_{3n+3} + (F_{3n+2} + F_{3n+1}) + F_{3n}\\ E_{n+2} = 4F_{3(n+1)} + F_{3n}\\ E_{n+2} = 4E_{n+1} + E_{n}\\ \end{gather} \]</p>
<h4 id="which-result-int-the-following-recurrence-relation"><a class="header" href="#which-result-int-the-following-recurrence-relation">Which result int the following recurrence relation:</a></h4>
<p>\[ E_{n} = 4E_ {n-1} + E_{n-2} \]</p>
<h4 id="we-are-searching-for"><a class="header" href="#we-are-searching-for">We are searching for:</a></h4>
<p>\[ \sum_{k=1}^ {n}E_k \]</p>
<h4 id="this-can-be-simplified-as-follows"><a class="header" href="#this-can-be-simplified-as-follows">This can be simplified as follows:</a></h4>
<p>\[ \begin{align} \sum_{k=1}^{n}E_ {k+1} &amp;= \sum_{k=1}^{n}4E_{k} + \sum_{k=1} ^{n}E_{k-1}\\ \sum_{k=1}^{n}E_{k}&amp;= \frac{1}{4}(\sum_{k=1}^{n}E_{k+1} - \sum_{k=1}^{n}E_{k-1})\\ &amp;= \frac{1}{4}(\sum_{k=2}^{n+1}E_{k} - \sum_{k=0}^{n-1}E_{k})\\ &amp;= \frac{1}{4}(E_{n+1} + E_{n} - E_1 - E_0)\\ &amp;= \frac{1}{4}(E_{n+1} + E_{n} - 2)\\ \end{align} \]</p>
<p>The result can be calculated by iterating until \( E_{n+1} \) is greater than
the limit, so that \( E_n \) is less than the limit, then apply the previous
function.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    e0 = 0
    e1 = 2
    while e1 &lt; limit:
        e0, e1 = e1, 4 * e1 + e0

    return (e1 + e0 - 2) // 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-and-the-golden-ratio"><a class="header" href="#fibonacci-and-the-golden-ratio">Fibonacci and the golden ratio</a></h1>
<p>Although the number of iterations of the second solution is lower than that of
the first solution, it is possible to do better:</p>
<p>\[ \begin{align} \frac{1}{4}(E_{n+1} + E_{n} - 2) &amp;= \frac{1}{4}(F_{3(n+1)} + F_{3n} - 2)\\ &amp;= \frac{1}{4}(F_{3n+2} + F_{3n+1} + F_{3n} - 2)\\ &amp;= \frac{1}{4}(2F_{3n+2} - 2)\\ &amp;= \frac{1}{2}(F_{3n+2} - 1)\\ \end{align} \]</p>
<p>This does not really change the problem, since we still need to iterate until
\( F_{3n} \) reach the limit and then compute \(\frac{1}{2}(F_
{3n+2} - 1)\).</p>
<p>Actually, the Fibonacci numbers can be approximated with the following
<a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression">equation</a>:</p>
<p>\[ F_{n} = \frac{\varphi^{n} - (-\varphi)^{-n}}{\sqrt{5}} \]</p>
<p>where \( \varphi = \frac{1+\sqrt{5}}{2} \) is the
<a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a>.</p>
<p>\( -(-\varphi)^{-n} \) can be ignored for large numbers which gives the
equation:</p>
<p>\[ F_{n} = \frac{\varphi^{n}}{\sqrt{5}} \]</p>
<p>The limit is the n-th Fibonacci number such that:</p>
<p>\[ \begin{align} F_{n} &amp;\leqslant M\\ \frac{\varphi ^{n}}{\sqrt{5}} &amp;\leqslant M\\ \varphi ^{n} &amp;\leqslant \sqrt{5} M\\ n\log( \varphi ) &amp;\leqslant \log\left(\sqrt{5} M\right)\\ n &amp;\leqslant \left\lfloor \frac{\log\left(\sqrt{5} M\right)}{\log( \varphi )} \right\rfloor \end{align} \]</p>
<p>The result can be computed with \(\frac{1}{2}(F_{n+2} - 1) \) where \( n =
\left\lfloor \frac{\log\left(\sqrt{5} M\right)}{\log( \varphi )} \right\rfloor
\):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    golden_ratio = (1 + sqrt(5)) / 2
    n = floor(log(sqrt(5) * limit) / log(golden_ratio))
    fn = round((golden_ratio ** (n + 2)) / sqrt(5))

    return (fn - 1) // 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-1"><a class="header" href="#solution-1">Solution</a></h1>
<hr />
<blockquote>
<p>4613732</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-prime-factor"><a class="header" href="#largest-prime-factor"><a href="https://projecteuler.net/problem=3">Largest prime factor</a></a></h1>
<blockquote>
<p>The prime factors of \( 13195 \) are \( 5 \), \( 7 \), \( 13 \) and \( 29 \).</p>
<p>What is the largest prime factor of the number \( 600851475143 \) ?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-2"><a class="header" href="#brute-force-2">Brute force</a></h1>
<p>\( i \) is a factor of \( n \) if \( n\ \equiv\ 0\ [i] \), in our case it
is enough to iterate over each number. When a factor is found, we simply divide
\( n \) by that factor and continue as long as \( n \) is greater than one.
When \( n \) is equal to one, we simply return the current factor which is
also the largest.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0003/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_prime_factor(n=600851475143):
    res = 2
    while n != 1:
        if n % res == 0:
            n //= res
        else:
            res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-by-two"><a class="header" href="#two-by-two">Two by Two</a></h1>
<p>Since all primes except 2 are odd and in our case 2 is not a factor of
600851475143, we can start with 3 and iterate two by two, which is not a great
improvement, but this problem has no interesting solution anyway.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0003/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_prime_factor(n=600851475143):
    res = 3
    while n != 1:
        if n % res == 0:
            n //= res
        else:
            res += 2

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-2"><a class="header" href="#solution-2">Solution</a></h1>
<hr />
<blockquote>
<p>6857</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-palindrome-product"><a class="header" href="#largest-palindrome-product"><a href="https://projecteuler.net/problem=4">Largest palindrome product</a></a></h1>
<blockquote>
<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two \( 2 \)-digit numbers is \( 9009=91×99 \).</p>
<p>Find the largest palindrome made from the product of two \( 3 \)-digit numbers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-3"><a class="header" href="#brute-force-3">Brute force</a></h1>
<p>We are searching the largest palindrome made from the product of two 3-digit
numbers. Firstly, it is necessary to know when a number is a palindrome. This
can be done easily using python iteration.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_palindrome(n):
    return str(n) == str(n)[::-1]
</code></pre>
<p>A better solution exists using modulus and division, but performance is not the
goal here.</p>
<p>The range of 3-digit numbers is \( [100; 999] \), the naive solution will
consist in simply iterate over each number and check which product is the
largest palindrome. A little trick: if \( 100 * 200 \) does not work, \(
200 * 100 \) won't work either, so the second loop starts from the current
number of the first one.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_palindrome_product():
    res = 0
    for x in range(100, 1000):
        for y in range(x, 1000):
            if x * y &gt; res and is_palindrome(x * y):
                res = x * y

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorisation-is-the-key"><a class="header" href="#factorisation-is-the-key">Factorisation is the key</a></h1>
<p>We know that the researched number is larger than \( 100*100 = 10000 \)
and smaller than \( 999*999 = 998001 \). So it must be of the form \(
abcba \) or \( abccba \). Let's assume it is of the form \( abccba \), if
it does not work, we'll try with \( abcba \).</p>
<p>\( abccba = 10001a + 10010b + 1100c = 11(9091a + 910b + 100c) \) which means
that the palindrome must be divisible by 11. Since 11 is prime, either \(
100001a \), \( 10010b \) or \( 1100c \) is a multiple of 11, which is why
the iteration can be done 11 by 11.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_palindrome_product():
    res = 0
    for x in range(110, 1000, 11):
        for y in range(x, 1000):
            if x * y &gt; res and is_palindrome(x * y):
                res = x * y

    return res
</code></pre>
<p>We went from 405450 iterations with the <a href="problems/problem_0004/solution1.html">Brute force</a> to 36450
iterations !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-pen-and-paper"><a class="header" href="#with-pen-and-paper">With pen and paper</a></h1>
<p>In <a href="problems/problem_0004/solution2.html">Factorisation is the key</a>, we assume that the number was of
the form \( abccba \). Since it is the factor of two 3-digit number, we have :</p>
<p>\[ \begin{align} abccba &amp;= (100a + 10b + c)(100d + 10e + f)\\ &amp;= 10000ad + 1000(bd + ae) + 100(cd + be + af) + 10(ce + bf) + cf \end{align} \]</p>
<p>Assuming the first digit is 9, then \( cf \) must be equal to 9 as well.</p>
<p>The only ways to make the last digit nine are:</p>
<p>\[ 1 * 9\\ 3 * 3\\ 7 * 7 \]</p>
<p>Thus, both number must start with 9 and end with either 1, 3, 7 or 9. We also
know that \( 100a + 10b + c \) or \( 100d + 10e + f \) is divisible by 11.
The only numbers divisible by 11 and ending with 1, 3, 7 or 9 in the
\( [900; 999]
\) are :</p>
<p>\[ 913\\ 957\\ 979 \]</p>
<p>This give us:</p>
<p>\[ \text{a = 9}\\ \text{b = 1, 5 or 7}\\ \text{c = 3, 7 or 9}\\ \]</p>
<p>Resulting in the numbers:</p>
<p>\[
(900 + 10 + 3)(900 + 10e + 3) = 824439 + 9130x\\
(900 + 50 + 7)(900 + 10e + 7) = 867999 + 9570x\\
(900 + 70 + 9)(900 + 10e + 1) = 882079 + 9790x \]</p>
<p>The first number implies that \( e \) is equal to 9 because if \( e \) was
equal to 8, then \(824439 * 9130 * 8 = 897479 \) would not start with 9.
With \( e = 9 \) we have \( 913 * 993 \) which is the correct answer. Both
\( (900 + 50 + 7)(900 + 10e + 7) \) and \( (900 + 70 + 9)(900 + 10e + 1) \)
give smaller palindrome.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-3"><a class="header" href="#solution-3">Solution</a></h1>
<hr />
<blockquote>
<p>906609</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="smallest-multiple"><a class="header" href="#smallest-multiple"><a href="https://projecteuler.net/problem=5">Smallest multiple</a></a></h1>
<blockquote>
<p>\( 2520 \) is the smallest number that can be divided by each of the numbers from \( 1 \) to \( 10 \) without any remainder.</p>
<p>What is the smallest positive number that is <em>evenly divisible</em> by all of the numbers from \( 1 \) to \( 20 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-4"><a class="header" href="#brute-force-4">Brute force</a></h1>
<p>As always, the brute force solution is quite simple, first determine if a number
is evenly divisible by all numbers from 1 to 20.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_evenly_divisible(n):
    for i in range(1, 21):
        if n % i != 0:
            return False

    return True
</code></pre>
<p>Then iterate until you find a solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def smallest_multiple():
    i = 1
    while not is_evenly_divisible(i):
        i += 1

    return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-factorization"><a class="header" href="#prime-factorization">Prime factorization</a></h1>
<p>The <a href="problems/problem_0005/solution2.html">Brute force</a> is actually very slow. A better solution can be
found using prime factorization. The key is to understand that when \( x \)
divides \( y \) evenly, it is because the prime factors of \( x\) are
contained in \( y \). For example, \( 20 = 2^2 * 5 \) which means that a
number divisible by 20 is also divisible by 2, 4 and 5.</p>
<p>Calculating the prime factorization of each number from 1 to 20 give us:</p>
<p>\[\begin{align} 20 &amp;= 2^2 * 5\\ 19 &amp;= 19\\ 18 &amp;= 2 * 3^2\\ 17 &amp;= 17\\ 16 &amp;= 2^4\\ 15 &amp;= 3 * 5\\ 14 &amp;= 2 * 7\\ 13 &amp;= 13\\ 12 &amp;= 2^2 * 3\\ 11 &amp;= 11\\ \end{align} \]</p>
<p>We can stop here, because 10 is included in 20, 9 in 18, 8 in 16, 7 in 14, 6 in
12, 5 in 20, 4 in 20, 3 in 18, 2 in 20 and 1 in 20.</p>
<p>It gives us the answer: \( 2^4 * 3^2 * 5 * 7 * 11 * 13 * 17 * 19 =
232792560 \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="least-common-multiple"><a class="header" href="#least-common-multiple">Least common multiple</a></h1>
<p>Actually, the problem is to find
the <a href="https://en.wikipedia.org/wiki/Least_common_multiple#Reduction_by_the_greatest_common_divisor">least common multiple</a>
which is:</p>
<p>\[ LCT(1, 2, ..., N) \]</p>
<p>To find the \( LCT \) of \( 1 \) through \( N \), we need all the primes
\( \leqslant N \). For each prime, we need its maximum power that won't exceed
\( N \). Which can be done easily using logarithms:</p>
<p>\[ \begin{align} p^{k} &amp;\leqslant N\\ k\log( p) &amp;\leqslant \log( N)\\ k&amp;=\left\lfloor \frac{\log( N)}{\log( p)}\right\rfloor\\ \end{align} \]</p>
<p>So the \( LCT \) of \( 1 \) through \( N \) is:</p>
<p>\[ \prod p^{\left\lfloor \frac{\log(N)}{\log(p)} \right\rfloor } \]</p>
<p>We also know that it's pointless to search the maximum power of primes greater
than \( \sqrt{n} \) because it will always be 1.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def smallest_multiple(n=20):
    # Returns a list of all primes &lt;= n
    primes = sieve.primerange(n + 1)
    sqrt_n, log_n = sqrt(n), log(n)
    res = 1
    for p in primes:
        if p &lt; sqrt_n:
            res *= p ** (floor(log_n / log(p)))
        else:
            res *= p

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-4"><a class="header" href="#solution-4">Solution</a></h1>
<hr />
<blockquote>
<p>232792560</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="sum-square-difference"><a class="header" href="#sum-square-difference"><a href="https://projecteuler.net/problem=6">Sum square difference</a></a></h1>
<blockquote>
<p>The sum of the squares of the first ten natural numbers is,</p>
<p>\[
1^2 + 2^2 + ... + 10^2 = 385
\]</p>
<p>The square of the sum of the first ten natural numbers is,</p>
<p>\[
(1 + 2 + ... + 10)^2 = 55^2 = 3025
\]</p>
<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is \( 3025-385=2640 \).</p>
<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-5"><a class="header" href="#brute-force-5">Brute force</a></h1>
<p>Finding the difference between the sum of the squares and the square of the sum
required two steps:</p>
<p>Find the sum of the squares:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_squares(n):
    return sum(i**2 for i in range(1, n + 1))
</code></pre>
<p>And the square of the sum:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def square_of_sum(n):
    return sum(i for i in range(1, n + 1)) ** 2
</code></pre>
<p>Finally, just subtract the square of the sum by the sum of the squares:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_square_difference(n=100):
    return square_of_sum(n) - sum_of_squares(n)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-formula"><a class="header" href="#summation-formula">Summation formula</a></h1>
<p>We learned in <a href="problems/problem_0006/../problem_0001/problem.html">Problem 1: Multiples of 3 and 5</a>
that:</p>
<p>\[ \sum{k} = \frac{n(n+1)}{2} \]</p>
<p>This gives the following formula for the square of the sum:</p>
<p>\[ (1+2+...+10)^2 = \left(\sum{k}\right)^2 = \left(\frac{n(n+1)}{2}\right)^2 = \frac{n^2 (n+1)^2}{4} \]</p>
<p>The sum of the squares can be found using the formula:</p>
<p>\[ \sum{k^2} = \frac{n(n+1)(2n+1)}{6} \]</p>
<p>There are many demonstrations to prove this equation, let's just look at one of
them:</p>
<p>\[ \begin{align} ( k-1)^{3} &amp;=k^{3} -3k^{2} +3k-1\\ k^{3} -( k-1)^{3} &amp;=3k^{2} -3k+1\\ \sum _{k=1}^{n}\left( k^{3} -( k-1)^{3}\right) &amp;=\sum _{k=1}^{n} 3k^{2} -3k+1 \\ \sum _{k=1}^{n} k^{3} -\sum _{k=1}^{n}( k-1)^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\sum _{k=1}^{n} k+\sum _{k=1}^{n} 1\\ \sum _{k=1}^{n} k^{3} -\sum _{k=0}^{n-1} k^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\frac{n( n+1)}{2} +n\\ n^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\frac{n( n+1)}{2} +n\\ \sum _{k=1}^{n} k^{2} &amp;=\frac{1}{3} n^{3} +\frac{n( n+1)}{2} -\frac{1}{3} n\\ \sum _{k=1}^{n} k^{2} &amp;=\frac{n( n+1)( 2n+1)}{6} \end{align} \]</p>
<p>The solution can be found in constant time with these two equations:</p>
<p>\[ \frac{n^2(n+1)^2}{4} - \frac{n(n+1)(2n+1)}{6} = \frac{3n^4+2n^3-3n^2-2n}{12} \]</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_square_difference(n=100):
    return (3 * n**4 + 2 * n**3 - 3 * n**2 - 2 * n) // 12
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-5"><a class="header" href="#solution-5">Solution</a></h1>
<hr />
<blockquote>
<p>25164150</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="10001st-prime"><a class="header" href="#10001st-prime"><a href="https://projecteuler.net/problem=7">10001st prime</a></a></h1>
<blockquote>
<p>By listing the first six prime numbers: \( 2 \), \( 3 \), \( 5 \), \( 7 \), \( 11 \), and \( 13 \), we can see that the \( 6 \)th prime is \( 13 \).</p>
<p>What is the \( 10001 \)st prime number?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-6"><a class="header" href="#brute-force-6">Brute force</a></h1>
<p>A well known and fast way to generate primes is the
<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>.
The only problem is that we need an upper bound, which is not the case here
since we don't know the size of the 10001st prime.</p>
<p>We will have to test the primality of each number, if it is prime, then we store
it, otherwise we continue with the next number until the list of prime numbers
that we stored contains 10001 elements. The last one being the answer.</p>
<p>To determine the primality of a number, we can check if one of the preceding
primes can divide it, if not, the number is prime.</p>
<p>Since even number can not be prime, we can go two by two just like
the <a href="problems/problem_0007/../problem_0003/solution2.html">Two by Two</a> solution
of <a href="problems/problem_0007/../problem_0003/problem.html">Problem 3: Largest prime factor</a>.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    i = 3
    primes = [2]
    while len(primes) &lt; n:
        if all(i % p != 0 for p in primes):  # No divisor in the previous prime.
            primes.append(i)
        i += 2

    return primes[-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="almost-six-by-six"><a class="header" href="#almost-six-by-six">Almost six by six</a></h1>
<p>Actually, it is possible to speed up a little the previous program knowing that
every prime \( n &gt; 3 \) is of the form :</p>
<p>\[ 6k+1 \text{ or } 6k-1 \]</p>
<p>Let's try to persuade ourselves that this is true. All prime numbers are of the
form:</p>
<p>\[ 6k - 1\\ 6k\\ 6k+1\\ 6k+2\\ 6k+3\\ 6k+4\\ \]</p>
<p>Nothing amazing, but as we are looking for prime number, we can remove some of
them :</p>
<p>\( 6k \), \( 6k + 2 \) and \( 6k + 4 \) are even number, so they cannot be
prime.</p>
<p>\( 6k + 3 = 3(3k + 1) \) which is divisible by 3 and thus not prime
(except 3).</p>
<p>Which let us with: \( 6k + 1 \) and \( 6k - 1 \).</p>
<p>Thus, we can rewrite the old program to check only those numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    i = 1
    primes = [2, 3]
    while len(primes) &lt; n:
        if all((6 * i - 1) % p != 0 for p in primes):
            primes.append(6 * i - 1)
        if all((6 * i + 1) % p != 0 for p in primes):
            primes.append(6 * i + 1)
        i += 1

    return primes[n - 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-number-theorem"><a class="header" href="#prime-number-theorem">Prime number theorem</a></h1>
<p>As I said in the <a href="problems/problem_0007/solution1.html">Brute force</a> solution, the fasted way to
generate primes is the sieve of eratosthenes, but it requires an upper bound. We
can not find the exact upper bound, but we can have a good approximation using
the <a href="https://en.wikipedia.org/wiki/Prime_number_theorem">Prime number theorem</a>:</p>
<p>\[  \pi(N) \sim \frac{N}{\log(N)} \]</p>
<p>Where \( \pi(N) \) is the
<a href="https://en.wikipedia.org/wiki/Prime-counting_function">prime-counting function</a>
.</p>
<p>This function give the number of primes \( M \) less than or equal to \( N
\), in our case we want to determine \( N \) knowing \( M \). Which give us
another formula:</p>
<p>\[ \begin{align} \frac{N}{\log(N)} &amp;\leqslant M\\ \frac{\log(N)}{N} &amp;\leqslant \frac{1}{M}\\ -\frac{\log(N)}{N} &amp;\leqslant -\frac{1}{M}\\ -\frac{\log(N)}{e^{\log(N)}} &amp;\leqslant -\frac{1}{M}\\ -\log(N)e^{-\log(N)} &amp;\leqslant -\frac{1}{M} \end{align} \]</p>
<p>The <a href="https://en.wikipedia.org/wiki/Lambert_W_function">Lambert \( W \) function</a>
says that \( we^w = z \Leftrightarrow w = \mathit{W}_{k}(z) \). This give us:</p>
<p>\[ \begin{align} -\log( N) e^{-\log( N)} &amp;\leqslant -\frac{1}{M}\\ -\log( N) &amp;\leqslant W_{k}\left( -\frac{1}{M}\right)\\ N &amp;\leqslant e^{-W_{k}\left( -\frac{1}{M}\right)} \end{align} \]</p>
<p>The solutions of Lambert's \( W \) function with real number can be found with
ony two branches: \( W_0 \) and \( W_{-1} \) suffice.</p>
<p>For real number \( z \) and \( w \) the equation \( we^w = z \) can be
solved for \( w \) only if \( w \geqslant -\frac{1}{e} \). if \( z
\geqslant 0 \) we get \( w = W_0(z) \) and the two values \( w = W_0(z) \)
and \( w = W_{-1}(z) \) if \( -\frac{1}{e} \leqslant w &lt; 0 \).</p>
<p>We have \( w = -\log(N) \) so we are in the second case. We need to determine
which of \(W_0(z) \) and \( W_{-1}(z) \) is the right formula.</p>
<p>The branch 0 converge to 1 when \( z \) converge to 0. Actually, for \( M &gt;
3 \) we have \( \lceil W_k(-\frac{1}{M}) \rceil = 1\). It implies that the
good branch is -1.</p>
<p>We can actually build the sieve of eratosthenes with the upper bound \( e^ {-W_
{-1}(-\frac{1}{M})} \). Lambert's \( W \) function cannot be expressed in
terms of
<a href="https://en.wikipedia.org/wiki/Elementary_function">elementary functions</a>, so
the formula cannot be simplified. The value of Lambert's \( W \) function
requires an iterative method to be found, as this is quite a difficult problem
we will use the
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lambertw.html">lambertw</a>
from <a href="https://docs.scipy.org/doc/scipy/index.html">scipy</a> to determine our upper
bound.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    if n &lt; 3:
        return [2, 3][n - 1]

    limit_pi_1 = ceil(exp(-lambertw(-1 / n, -1).real))
    primes = sieve.primerange(limit_pi_1 + 1)

    return next(islice(primes, n - 1, n))
</code></pre>
<p>Note that <code>sieve.primerange</code> returns a <code>generator</code>, so we use slice to get the
n-th element.</p>
<p>When \( N &lt; 3 \), we have \( -\log(N) \geqslant -\frac{1}{e} \) which means
the Lambert's W function has no solution. We can simply hard-code the case of 1
and 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-6"><a class="header" href="#solution-6">Solution</a></h1>
<hr />
<blockquote>
<p>104743</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-series"><a class="header" href="#largest-product-in-a-series"><a href="https://projecteuler.net/problem=8">Largest product in a series</a></a></h1>
<blockquote>
<p>The four adjacent digits in the \( 1000 \)-digit number that have the greatest product are \( 9×9×8×9=5832 \).</p>
<p>\[
73167176531330624919225119674426574742355349194934\\
96983520312774506326239578318016984801869478851843\\
85861560789112949495459501737958331952853208805511\\
12540698747158523863050715693290963295227443043557\\
66896648950445244523161731856403098711121722383113\\
62229893423380308135336276614282806444486645238749\\
30358907296290491560440772390713810515859307960866\\
70172427121883998797908792274921901699720888093776\\
65727333001053367881220235421809751254540594752243\\
52584907711670556013604839586446706324415722155397\\
53697817977846174064955149290862569321978468622482\\
83972241375657056057490261407972968652414535100474\\
82166370484403199890008895243450658541227588666881\\
16427171479924442928230863465674813919123162824586\\
17866458359124566529476545682848912883142607690042\\
24219022671055626321111109370544217506941658960408\\
07198403850962455444362981230987879927244284909188\\
84580156166097919133875499200524063689912560717606\\
05886116467109405077541002256983155200055935729725\\
71636269561882670428252483600823257530420752963450
\]</p>
<p>Find the thirteen adjacent digits in the \( 1000 \)-digit number that have the greatest product. What is the value of this product?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-7"><a class="header" href="#brute-force-7">Brute force</a></h1>
<p>We are searching for the largest product of 13 adjacent digits in a 1000-digit
number. We want to calculate the product of each 13 adjacent digits and find the
largest one.</p>
<p>The 1000-digit number will be stored in a file, so the first step is to get this
number as a string and remove each trailing newline (\n):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return file.read().replace(&quot;\n&quot;, &quot;&quot;)
</code></pre>
<p>Given this string, we need to calculate the product of 13 adjacent digits, which
can be done easily
using <a href="https://docs.python.org/3/library/math.html#math.prod">math.prod()</a>.
Then, simply repeat this step for all 13 adjacent digits contained in the
1000-digit number and save the maximum of these products.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_product_in_series(n, adj=13):
    res = 0
    for i in range(len(n) - adj):
        res = max(prod(int(digit) for digit in n[i : i + adj]), res)

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0-are-useless"><a class="header" href="#0-are-useless">0 are useless</a></h1>
<p>The problem requires calculating a product, a product of something and 0 will
always give a result of 0. Which means that every 13 adjacent digits containing
0 are useless since the result will never be the largest product.</p>
<p>The 1000-digit number can actually be split around each 0, of course if a number
has less than 13 digits it can be deleted.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def split_series(n):
    return [sub_n for sub_n in n.split(&quot;0&quot;) if len(sub_n) &gt;= 13]
</code></pre>
<p>Another improvement reside in not calculating every product from the start, for
example if we search the product of 3 adjacent digits in 12345, the 3 solutions
are:</p>
<pre><code class="language-python">1*2*3     = 6
  2*3*4   = (6 / 1) * 4 = 24
    3*4*5 = (24 / 3) * 5 = 60
</code></pre>
<p>The second product is the same as the first, just divide the digit that is not
present and multiply the one that is. We have to be careful with the digit 0
because division by 0 is an error, but we have already solved the problem just
before, so we can assume our number will never contain the digit 0.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_product_in_series(n, adj=13):
    res = 0
    current = prod(int(digit) for digit in n[0:adj])
    for i in range(len(n) - adj):
        current = (current // int(n[i])) * int(n[i + adj])
        res = max(res, current)

    return res
</code></pre>
<p>We simply repeat this step for each sub-number of the 1000-digit split around 0.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_product_in_multiples_series(sub_n, adj=13):
    res = 0
    for n in sub_n:
        res = max(largest_product_in_series(n, adj), res)
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-7"><a class="header" href="#solution-7">Solution</a></h1>
<hr />
<blockquote>
<p>23514624000</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-pythagorean-triplet"><a class="header" href="#special-pythagorean-triplet"><a href="https://projecteuler.net/problem=9">Special Pythagorean triplet</a></a></h1>
<blockquote>
<p>A Pythagorean triplet is a set of three natural numbers, \( a&lt;b&lt;c \), for which,</p>
<p>\[
a^{2} + b^{2} = c^{2}
\]</p>
<p>For example, \( 3^{2}+4^{2}=9+16=25=5^{2} \).</p>
<p>There exists exactly one Pythagorean triplet for which \( a+b+c=1000 \).
Find the product \( abc \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-8"><a class="header" href="#brute-force-8">Brute force</a></h1>
<p>We are searching for \( a \), \( b \) and \( c \) such that \( a &lt; b
&lt; c \), \( a + b + c = 1000 \) and \( a^2 + b^2 = c^2 \). The brute force
solution will simply iterate to 1000 for \( a \), \( b \)
and \( c \) and stop when the above equations are true.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for a in range(1001):
        for b in range(a + 1, 1001):
            for c in range(b + 1, 1001):
                if a + b + c == 1000 and a**2 + b**2 == c**2:
                    return a * b * c

    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-a-little-thought"><a class="header" href="#with-a-little-thought">With a little thought</a></h1>
<p>The <a href="problems/problem_0009/solution1.html">Brute force solution</a> can be simplified a bit knowing that
\( a + b + c = 1000 \) implies \( c = 1000 - a - b \). This removes a for
loop and an equation, since \( a + b + c = 1000 \) will always be true.</p>
<p>Another simplification can be made by knowing that \( a &lt; b &lt; c \). This
implies that \( a \), \( b \) and \( c \) are lower than 500, otherwise
\( a + b + c \) will be greater than 1000.</p>
<p>This gives us the following :</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for a in range(501):
        for b in range(a + 1, 501):
            c = 1000 - a - b
            if a**2 + b**2 == c**2:
                return a * b * c

    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-pythagorean-triples"><a class="header" href="#prime-pythagorean-triples">Prime Pythagorean triples</a></h1>
<p>Given an arbitrary pair of integers m and n with m &gt; n &gt; 0. Euclid's formula
states that the integers :</p>
<p>\[ a = m^2 - n^2,\ b=2mn,\ c=m^2+n^2 \]</p>
<p>form a Pythagorean triple: \( a^2 + b^2 = c^2 \)</p>
<p>If we calculate \( a^2 + b ^2 \):</p>
<p>\[ a^2 + b^2 = (m^2-n^2)^2 + (2mn)^2 = m^2 + 4m^2n^2 - 2m^2n^2 + n^2 = (m^2 + n^2)^2 = c^2 \]</p>
<p>Which is coherent, the problem changes from finding \( a \), \( b \) and \(
c \) to finding \( m \) and \( n \), we have:</p>
<p>\[ \begin{align} a+b+c &amp;= 1000\\ 2mn + 2m^2 &amp;= 1000\\ n &amp;= \frac{500}{m} - m\\ \end{align} \]</p>
<p>We have \( m &gt; n \) since b must be positive, solving \( n = m \) gives:</p>
<p>\[ \begin{align} m &amp;= \frac{500}{m} - m\\ 0 &amp;= \frac{500 - 2m^2}{m}\\ 0 &amp;= 500 - 2m^2\\ m &amp;= \sqrt(250)\\ \end{align} \]</p>
<p>Resulting in:</p>
<p>\[ m &gt; 16 &gt; \sqrt(250) \]</p>
<p>We also have \( n &gt; 0 \), solving \( n = 0 \) gives:</p>
<p>\[ \begin{align} 0 &amp;= \frac{500}{m} - m\\ 0 &amp;= 500 - m^2\\ m &amp;= \sqrt(500)\\ \end{align} \]</p>
<p>Resulting in:</p>
<p>\[ m &lt; \sqrt(500) &lt; 23 \]</p>
<p>We also know that \( \frac{500}{m} \) is an integer, so m must divide \(
500 \). The only multiple of that divides \( 500 \) with the constraint \(
16 &gt; m &gt; 23 \) is 20. Having \( m = 20 \) result in \( n = 5 \). It gives
\( a = 200 \), \( b = 375 \) and \( c \) = 425.</p>
<p>The solution can also be found by using a for loop to find \( m \) and \(
n \) with the above constraints.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for m in range(16, 24):
        for n in range(1, m):
            if m * (n + m) == 500:
                return 2 * m * n * (m**4 - n**4)

    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-8"><a class="header" href="#solution-8">Solution</a></h1>
<hr />
<blockquote>
<p>31875000</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-of-primes"><a class="header" href="#summation-of-primes"><a href="https://projecteuler.net/problem=10">Summation of primes</a></a></h1>
<blockquote>
<p>The sum of the primes below \( 10 \) is \( 2+3+5+7=17 \).</p>
<p>Find the sum of all the primes below two million.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-9"><a class="header" href="#brute-force-9">Brute force</a></h1>
<p>We already know, thanks to te previous problems that when one search for all
prime numbers below a certain limit, the sieve of eratosthenes is a good
solution.</p>
<p>It is enough to sum the list of the primes found with the sieve.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def summation_of_primes(limit=2000000):
    return sum(sieve.primerange(limit))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-minus-summation"><a class="header" href="#summation-minus-summation">Summation minus summation</a></h1>
<p>The sieve of eratosthenes is actually quite slow, it's possible to find a better
solution if we consider that we don't need to know all the primes to find their
sum. For example, the sum of the primes less than \( 10 \) is \( 2 + 3 + 5 +
7 = 17 \).</p>
<p>The sum of the primes less than \( 10 \) is the sum of the numbers less than
10 minus the sum of the multiples of the primes less than \( \sqrt{10} \)
plus the primes themselves minus \( 1 \). In this example, the sum of the
multiples of \( 2 \) and \( 3 \):</p>
<p>\[ \begin{alignat}{1} P &amp;&amp;= &amp;&amp;+1&amp;&amp;+2&amp;&amp;+3&amp;&amp;+4&amp;&amp;+5&amp;&amp;+6+7&amp;&amp;+8&amp;&amp;+9&amp;&amp;+10\\ &amp;&amp;&amp;&amp;&amp;&amp;-2&amp;&amp;&amp;&amp;-4&amp;&amp;&amp;&amp;-6&amp;&amp;-8&amp;&amp;&amp;&amp;-10\\ &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;-3&amp;&amp;&amp;&amp;&amp;&amp;-6&amp;&amp;&amp;&amp;-9\\ &amp;&amp;&amp;&amp;-1&amp;&amp;+2&amp;&amp;+3\\ P &amp;&amp;= &amp;&amp;&amp;&amp;+2&amp;&amp;+3&amp;&amp;&amp;&amp;+5&amp;&amp;-6+7\\ \end{alignat} \]</p>
<p>There is just one problem, the number \( 6 \) is both a multiple of \( 2 \)
and \( 3 \). This means we have to remove the multiple of \( 3 \) but not
the multiple of \( 6 \). For numbers larger than 10, if we continue with \( 5
\) we have to remove the multiple of \( 5 \) but not the multiple of \(
2*5=10 \), \( 3*5=15 \) and \( 5*6=30 \).</p>
<p>Let \( \phi(n) \) be the sum of the numbers less than \( n \).</p>
<p>We have the following sequence:</p>
<p>\[ \begin{align} T_0(n) &amp;= \phi(\left\lfloor n \right\rfloor) &amp;&amp;= 1+2+3+\dots\\ T_1(n) &amp;= 2\left(T_0\left(\frac{n}{2}\right)\right) = 2\phi\left (\left\lfloor \frac{n} {2} \right\rfloor \right) &amp;&amp;= 2+4+6+\dots\\ T_2(n) &amp;= 3\left(T_0\left(\frac{n}{3}\right) - T_1\left(\frac{n}{3}\right) \right) = 3\phi \left(\left\lfloor \frac{n}{3} \right\rfloor\right) - 6\phi\left(\left\lfloor \frac{n}{6} \right\rfloor\right) &amp;&amp;= 3+9+15+\dots\\ T_3(n) &amp;= 5\left(T_0\left(\frac{n}{5}\right) - T_1\left(\frac{n}{5}\right) - T_2\left(\frac{n}{5}\right) \right) = 5\phi\left(\left\lfloor\frac{n}{5}\right\rfloor\right) - 10\phi\left(\left\lfloor\frac{n}{10}\right\rfloor\right) - 15\phi\left(\left\lfloor\frac{n}{15} \right\rfloor\right) + 30\phi\left(\left\lfloor\frac{n}{30} \right\rfloor\right) &amp;&amp;= 5+25+35+\dots\\ \end{align} \]</p>
<p>So the k-th term is:</p>
<p>\[ T_k(n) = p_k\left(T_0\left(\frac{n}{p_k}\right) - \dots - T_{k-1}\left (\frac{n} {p_k}\right)\right) \]</p>
<p>Where \( p_k \) is the k-th prime.</p>
<p>We can create a function to find \( T_k \) if we have \( p_k \):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def tk(n, k, primes):
    pk = primes[k - 1]
    t0 = phi(floor(n / pk))
    tn = sum(tk(n / pk, i, primes) for i in range(1, k))
    return pk * (t0 - tn)
</code></pre>
<p>The sum of the primes less than \( n \) is the sum of the numbers less than
\( n \) minus the sum of all the multiples of the primes less than \( \sqrt
{n} \) plus the primes themselves minus \( 1 \):</p>
<p>\[ \left(T_0(n) - T_1(n) - \dots - T_k(n)\right) + \left(p_1 + p_2 + \dots + p_k\right) - 1 \]</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def summation_of_primes(limit=2000):
    primes = list(sieve.primerange(floor(sqrt(limit)) + 1))

    return phi(limit) - sum(tk(limit, i + 1, primes) for i in range(len(primes))) + sum(primes) - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0010/solution2.html">Summation minus summation</a> solution gives an interesting
solution because we found the sum of the primes less than \( n \) with only
the primes less than \( \sqrt{n} \). Unfortunately, this solution is not
efficient because it requires too much recursion for larger n.</p>
<p>The main problem with the previous solution was to remove the numbers that were
multiples of previous primes. For example with the multiples of \( 3 \), the
number \( 6 \) was already removed by the multiples of \( 2 \).</p>
<p>What we really want is to remove the multiples of \( 3 \) that have not
already been removed by the multiples of \( 2 \) such as \( 6 \), \( 12 \)
... For \( 5 \) that would be the number that are neither multiples of \( 2
\) nor \( 3 \).</p>
<p>Instead of the sum of the multiples of a prime, we will search for the sum of
integer that remain after sieving with all primes smaller than the current one.</p>
<p>This solution is well explained by <strong>Lucy_Hedgehog</strong> in this
<a href="https://projecteuler.net/thread=10;page=5#111677">thread</a> (only available if
you solve the problem):</p>
<blockquote>
<p>The main idea is as follows: Let \( S(v,m) \) be the sum of integers in the
range \( 2 \dots v \) that remain after sieving with all primes smaller or
equal than \( m \). That is \( S(v,m) \) is the sum of integers up to
\( v \) that are either prime or the product of primes larger than \( m
\).</p>
<p>\( S(v, p) \) is equal to \(S(v, p-1) \) if \( p \) is not prime or
\( v \) is smaller than \( p*p \). Otherwise (\( p \) prime, \(
p*p\leqslant v \)) \( S(v,p) \) can be computed from \(S(v, p-1)\)
by finding the sum of integers that are removed while sieving with \( p
\). An integer is removed in this step if it is the product of \(p \)
with another integer that has no divisor smaller than \(p \). This can
be expressed as</p>
<p>\[ S\left(v, p \right) = S\left(v, p - 1\right) - p\left(S\left(\frac{v}{p},
p - 1\right) -S\left(p-1, p-1\right)\right) \]</p>
<p>Dynamic programming can be used to implement this. It is sufficient to
compute \( S(v,p) \) for all positive integers \( v \) that are
representable as \( \left\lfloor\frac{n}{k}\right\rfloor \) for some
integer \( k \) and all.</p>
</blockquote>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def partial_prime_sum(n=2000000):
    r = ceil(sqrt(n))
    V = [n // i for i in range(1, r + 1)]
    V += list(range(V[-1] - 1, 0, -1))
    S = {i: i * (i + 1) // 2 - 1 for i in V}
    for p in range(2, r + 1):
        if S[p] &gt; S[p - 1]:  # p is prime
            sp = S[p - 1]  # sum of primes smaller than p
            p2 = p * p
            for v in V:
                if v &lt; p2:
                    break
                S[v] -= p * (S[v // p] - sp)
    return S[n]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-9"><a class="header" href="#solution-9">Solution</a></h1>
<hr />
<blockquote>
<p>142913828922</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-grid"><a class="header" href="#largest-product-in-a-grid"><a href="https://projecteuler.net/problem=11">Largest product in a grid</a></a></h1>
<blockquote>
<p>In the \( 20×20 \) grid below, four numbers along a diagonal line have been marked in red.</p>
<p>\[
08\ 02\ 22\ 97\ 38\ 15\ 00\ 40\ 00\ 75\ 04\ 05\ 07\ 78\ 52\ 12\ 50\ 77\ 91\ 08\\
49\ 49\ 99\ 40\ 17\ 81\ 18\ 57\ 60\ 87\ 17\ 40\ 98\ 43\ 69\ 48\ 04\ 56\ 62\ 00\\
81\ 49\ 31\ 73\ 55\ 79\ 14\ 29\ 93\ 71\ 40\ 67\ 53\ 88\ 30\ 03\ 49\ 13\ 36\ 65\\
52\ 70\ 95\ 23\ 04\ 60\ 11\ 42\ 69\ 24\ 68\ 56\ 01\ 32\ 56\ 71\ 37\ 02\ 36\ 91\\
22\ 31\ 16\ 71\ 51\ 67\ 63\ 89\ 41\ 92\ 36\ 54\ 22\ 40\ 40\ 28\ 66\ 33\ 13\ 80\\
24\ 47\ 32\ 60\ 99\ 03\ 45\ 02\ 44\ 75\ 33\ 53\ 78\ 36\ 84\ 20\ 35\ 17\ 12\ 50\\
32\ 98\ 81\ 28\ 64\ 23\ 67\ 10\ \color{red}{26}\ 38\ 40\ 67\ 59\ 54\ 70\ 66\ 18\ 38\ 64\ 70\\
67\ 26\ 20\ 68\ 02\ 62\ 12\ 20\ 95\ \color{red}{63}\ 94\ 39\ 63\ 08\ 40\ 91\ 66\ 49\ 94\ 21\\
24\ 55\ 58\ 05\ 66\ 73\ 99\ 26\ 97\ 17\ \color{red}{78}\ 78\ 96\ 83\ 14\ 88\ 34\ 89\ 63\ 72\\
21\ 36\ 23\ 09\ 75\ 00\ 76\ 44\ 20\ 45\ 35\ \color{red}{14}\ 00\ 61\ 33\ 97\ 34\ 31\ 33\ 95\\
78\ 17\ 53\ 28\ 22\ 75\ 31\ 67\ 15\ 94\ 03\ 80\ 04\ 62\ 16\ 14\ 09\ 53\ 56\ 92\\
16\ 39\ 05\ 42\ 96\ 35\ 31\ 47\ 55\ 58\ 88\ 24\ 00\ 17\ 54\ 24\ 36\ 29\ 85\ 57\\
86\ 56\ 00\ 48\ 35\ 71\ 89\ 07\ 05\ 44\ 44\ 37\ 44\ 60\ 21\ 58\ 51\ 54\ 17\ 58\\
19\ 80\ 81\ 68\ 05\ 94\ 47\ 69\ 28\ 73\ 92\ 13\ 86\ 52\ 17\ 77\ 04\ 89\ 55\ 40\\
04\ 52\ 08\ 83\ 97\ 35\ 99\ 16\ 07\ 97\ 57\ 32\ 16\ 26\ 26\ 79\ 33\ 27\ 98\ 66\\
88\ 36\ 68\ 87\ 57\ 62\ 20\ 72\ 03\ 46\ 33\ 67\ 46\ 55\ 12\ 32\ 63\ 93\ 53\ 69\\
04\ 42\ 16\ 73\ 38\ 25\ 39\ 11\ 24\ 94\ 72\ 18\ 08\ 46\ 29\ 32\ 40\ 62\ 76\ 36\\
20\ 69\ 36\ 41\ 72\ 30\ 23\ 88\ 34\ 62\ 99\ 69\ 82\ 67\ 59\ 85\ 74\ 04\ 36\ 16\\
20\ 73\ 35\ 29\ 78\ 31\ 90\ 01\ 74\ 31\ 49\ 71\ 48\ 86\ 81\ 16\ 23\ 57\ 05\ 54\\
01\ 70\ 54\ 71\ 83\ 51\ 54\ 69\ 16\ 92\ 33\ 48\ 61\ 43\ 52\ 01\ 89\ 19\ 67\ 48
\]</p>
<p>The product of these numbers is \( 26×63×78×14=1788696 \).</p>
<p>What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the \( 20×20 \) grid?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-10"><a class="header" href="#brute-force-10">Brute force</a></h1>
<p>This problem is not interesting, the solution is simply to iterate on each 
row, column and on the two diagonal.</p>
<p>As with <a href="problems/problem_0011/../problem_0008/problem.html">Largest product in a series</a>, the 
input grid will be stored in a file, so the first step is to obtain this
grid as int matrix.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0011/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return [
            [int(x) for x in line.split(&quot; &quot;)] for line in file.read().split(&quot;\n&quot;)[:-1]
        ]
</code></pre>
<p>And then just iterate on this matrix:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0011/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_product_in_grid(filename):
    g = read_file(filename)

    for y in range(0, 20):
        for x in range(0, 17):
            yield g[x][y] * g[x + 1][y] * g[x + 2][y] * g[x + 3][y]
    for x in range(0, 20):
        for y in range(0, 17):
            yield g[x][y] * g[x][y + 1] * g[x][y + 2] * g[x][y + 3]
    for y in range(0, 17):
        for x in range(0, 17):
            yield g[x][y] * g[x + 1][y + 1] * g[x + 2][y + 2] * g[x + 3][y + 3]
    for x in range(3, 20):
        for y in range(0, 17):
            yield g[x][y] * g[x - 1][y + 1] * g[x - 2][y + 2] * g[x - 3][y + 3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-10"><a class="header" href="#solution-10">Solution</a></h1>
<hr />
<blockquote>
<p>70600674</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="highly-divisible-triangular-number"><a class="header" href="#highly-divisible-triangular-number"><a href="https://projecteuler.net/problem=12">Highly divisible triangular number</a></a></h1>
<blockquote>
<p>The sequence of triangle numbers is generated by adding the natural numbers. So the \( 7^{th} \) triangle number would be \( 1+2+3+4+5+6+7=28 \). The first ten terms would be:</p>
<p>\[
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
\]</p>
<p>Let us list the factors of the first seven triangle numbers:</p>
<p>\[
\begin{align}
1&amp;: 1\\
3&amp;: 1,3\\
6&amp;: 1,2,3,6\\
10&amp;: 1,2,5,10\\
15&amp;: 1,3,5,15\\
21&amp;: 1,3,7,21\\
28&amp;: 1,2,4,7,14,28\end{align}
\]</p>
<p>We can see that \( 28 \) is the first triangle number to have over five divisors.</p>
<p>What is the value of the first triangle number to have over five hundred divisors?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-11"><a class="header" href="#brute-force-11">Brute force</a></h1>
<p>Finding the number of factors of \( n \) can be done by iterating from 1 to
\( n \) and checking each number that can divide \( n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def number_of_factors(n):
    res = 1
    for i in range(2, n):
        if n % i == 0:
            res += 1
    return res
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Triangular_number">Triangular number</a> can be
computed quite easily with a loop, we can generate them as long as their number
of divisor is less than \( 500 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def highly_div_triangular_number(n=500):
    i = 1
    res = 1
    while number_of_factors(res) &lt; n:
        i += 1
        res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-factor"><a class="header" href="#common-factor">Common factor</a></h1>
<p>The <a href="problems/problem_0012/solution1.html">Brute Force</a> solution is really slow, way to slow to be
honest.</p>
<p>First, we can improve the way we find the number of factors. If \( i \)
divides \( n \), then obviously \( \frac{n}{i} \) divides \( n \) too. We
do not need to iterate from 2 to \( n \) but only to \( \sqrt{n} \) and add
the factors two by two. The only exception is that if \( \sqrt{n} \) divides
\( n \) we only need to count it once.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def number_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root):
        if n % i == 0:
            res += 1
    return 2 * res + (root**2 == n)
</code></pre>
<p>This makes the solution much faster, but there is still room for improvement in
the way the triangular numbers are calculated. We already know from the previous
problems that the sum of integer from \( 1 \) to \( n \) is \(\frac{n(n+1)
}{2} \). Since \( n \) and \( n + 1 \) have no factors in common except \(
1 \), we can multiply the number of factor in \( \frac{n}{2} \) and \( n + 1
\) or \( n \) and \( \frac{n+1}{2} \) depending on the parity of \( n \).
This allows us to calculate the number of factors of smaller numbers, which
makes the solution quite fast compared to the <a href="problems/problem_0012/solution1.html">Brute force</a>
solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def highly_div_triangular_number(n=500):
    i = 0
    factors = 0
    while factors &lt; n:
        i += 1
        if i % 2 == 0:
            factors = number_of_factors(i // 2) * number_of_factors(i + 1)
        else:
            factors = number_of_factors(i) * number_of_factors((i + 1) // 2)

    return i * (i + 1) // 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-11"><a class="header" href="#solution-11">Solution</a></h1>
<hr />
<blockquote>
<p>76576500</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="large-sum"><a class="header" href="#large-sum"><a href="https://projecteuler.net/problem=13">Large sum</a></a></h1>
<blockquote>
<p>Work out the first ten digits of the sum of the following one-hundred \( 50 \)-digit numbers.</p>
<p>\[
37107287533902102798797998220837590246510135740250\\\\
46376937677490009712648124896970078050417018260538\\\\
74324986199524741059474233309513058123726617309629\\\\
91942213363574161572522430563301811072406154908250\\\\
23067588207539346171171980310421047513778063246676\\\\
89261670696623633820136378418383684178734361726757\\\\
28112879812849979408065481931592621691275889832738\\\\
44274228917432520321923589422876796487670272189318\\\\
47451445736001306439091167216856844588711603153276\\\\
70386486105843025439939619828917593665686757934951\\\\
62176457141856560629502157223196586755079324193331\\\\
64906352462741904929101432445813822663347944758178\\\\
92575867718337217661963751590579239728245598838407\\\\
58203565325359399008402633568948830189458628227828\\\\
80181199384826282014278194139940567587151170094390\\\\
35398664372827112653829987240784473053190104293586\\\\
86515506006295864861532075273371959191420517255829\\\\
71693888707715466499115593487603532921714970056938\\\\
54370070576826684624621495650076471787294438377604\\\\
53282654108756828443191190634694037855217779295145\\\\
36123272525000296071075082563815656710885258350721\\\\
45876576172410976447339110607218265236877223636045\\\\
17423706905851860660448207621209813287860733969412\\\\
81142660418086830619328460811191061556940512689692\\\\
51934325451728388641918047049293215058642563049483\\\\
62467221648435076201727918039944693004732956340691\\\\
15732444386908125794514089057706229429197107928209\\\\
55037687525678773091862540744969844508330393682126\\\\
18336384825330154686196124348767681297534375946515\\\\
80386287592878490201521685554828717201219257766954\\\\
78182833757993103614740356856449095527097864797581\\\\
16726320100436897842553539920931837441497806860984\\\\
48403098129077791799088218795327364475675590848030\\\\
87086987551392711854517078544161852424320693150332\\\\
59959406895756536782107074926966537676326235447210\\\\
69793950679652694742597709739166693763042633987085\\\\
41052684708299085211399427365734116182760315001271\\\\
65378607361501080857009149939512557028198746004375\\\\
35829035317434717326932123578154982629742552737307\\\\
94953759765105305946966067683156574377167401875275\\\\
88902802571733229619176668713819931811048770190271\\\\
25267680276078003013678680992525463401061632866526\\\\
36270218540497705585629946580636237993140746255962\\\\
24074486908231174977792365466257246923322810917141\\\\
91430288197103288597806669760892938638285025333403\\\\
34413065578016127815921815005561868836468420090470\\\\
23053081172816430487623791969842487255036638784583\\\\
11487696932154902810424020138335124462181441773470\\\\
63783299490636259666498587618221225225512486764533\\\\
67720186971698544312419572409913959008952310058822\\\\
95548255300263520781532296796249481641953868218774\\\\
76085327132285723110424803456124867697064507995236\\\\
37774242535411291684276865538926205024910326572967\\\\
23701913275725675285653248258265463092207058596522\\\\
29798860272258331913126375147341994889534765745501\\\\
18495701454879288984856827726077713721403798879715\\\\
38298203783031473527721580348144513491373226651381\\\\
34829543829199918180278916522431027392251122869539\\\\
40957953066405232632538044100059654939159879593635\\\\
29746152185502371307642255121183693803580388584903\\\\
41698116222072977186158236678424689157993532961922\\\\
62467957194401269043877107275048102390895523597457\\\\
23189706772547915061505504953922979530901129967519\\\\
86188088225875314529584099251203829009407770775672\\\\
11306739708304724483816533873502340845647058077308\\\\
82959174767140363198008187129011875491310547126581\\\\
97623331044818386269515456334926366572897563400500\\\\
42846280183517070527831839425882145521227251250327\\\\
55121603546981200581762165212827652751691296897789\\\\
32238195734329339946437501907836945765883352399886\\\\
75506164965184775180738168837861091527357929701337\\\\
62177842752192623401942399639168044983993173312731\\\\
32924185707147349566916674687634660915035914677504\\\\
99518671430235219628894890102423325116913619626622\\\\
73267460800591547471830798392868535206946944540724\\\\
76841822524674417161514036427982273348055556214818\\\\
97142617910342598647204516893989422179826088076852\\\\
87783646182799346313767754307809363333018982642090\\\\
10848802521674670883215120185883543223812876952786\\\\
71329612474782464538636993009049310363619763878039\\\\
62184073572399794223406235393808339651327408011116\\\\
66627891981488087797941876876144230030984490851411\\\\
60661826293682836764744779239180335110989069790714\\\\
85786944089552990653640447425576083659976645795096\\\\
66024396409905389607120198219976047599490197230297\\\\
64913982680032973156037120041377903785566085089252\\\\
16730939319872750275468906903707539413042652315011\\\\
94809377245048795150954100921645863754710598436791\\\\
78639167021187492431995700641917969777599028300699\\\\
15368713711936614952811305876380278410754449733078\\\\
40789923115535562561142322423255033685442488917353\\\\
44889911501440648020369068063960672322193204149535\\\\
41503128880339536053299340368006977710650566631954\\\\
81234880673210146739058568557934581403627822703280\\\\
82616570773948327592232845941706525094512325230608\\\\
22918802058777319719839450180888072429661980811197\\\\
77158542502016545090413245809786882778948721859617\\\\
72107838435069186155435662884062257473692284509516\\\\
20849603980134001723930671666823555245252804609722\\\\
53503534226472524250874054075591789781264330331690
\]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-12"><a class="header" href="#brute-force-12">Brute force</a></h1>
<p>The main problem is to find a way to add large numbers, because computers can
not store large numbers so easily. That's the point of the problem, to find a
way to add those numbers. We could use an array to store each digit of each
number and add them, but thanks to python and
the <a href="https://www.python.org/dev/peps/pep-0237/">unifying long integers and integers</a>
we can just add these numbers without worrying about memory.</p>
<p>We just need to get the first 10 digits of the additions, which can be done
quite easily by converting the number to a string ang get the first 10
characters.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0013/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def large_sum(filename):
    return str(sum(read_file(filename)))[:10]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-12"><a class="header" href="#solution-12">Solution</a></h1>
<hr />
<blockquote>
<p>5537376230</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-collatz-sequence"><a class="header" href="#longest-collatz-sequence"><a href="https://projecteuler.net/problem=14">Longest Collatz sequence</a></a></h1>
<blockquote>
<p>The following iterative sequence is defined for the set of positive integers:</p>
<p>\[
\begin{align}
&amp; n \rightarrow \frac{n}{2}\ (n\ is\ even)\\
&amp; n \rightarrow 3n + 1\ (n\ is\ odd)
\end{align}
\]</p>
<p>Using the rule above and starting with \( 13 \), we generate the following sequence:</p>
<p>\[
13 \rightarrow 40 \rightarrow 20 \rightarrow 10 \rightarrow 5 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1
\]</p>
<p>It can be seen that this sequence (starting at \( 13 \) and finishing at \( 1 \)) contains \( 10 \) terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at \( 1 \).</p>
<p>Which starting number, under one million, produces the longest chain?</p>
<p><strong>NOTE:</strong> Once the chain starts the terms are allowed to go above one million.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-13"><a class="header" href="#brute-force-13">Brute force</a></h1>
<p>Calculating the number of iterations of the Collatz sequence is easy, just
follow the sequence until it reaches one, and count the number of iterations
to get there:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0014/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def collatz(n):
    iteration = 0
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        iteration += 1

    return iteration
</code></pre>
<p>Then, just check the iteration for each starting number from 1 to 1000000 and
return the largest.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0014/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def longest_collatz_sequence(n=1000000):
    res, max_it = 0, 0
    for i in range(1, n):
        current_it = collatz(i)
        if current_it &gt; max_it:
            res, max_it = i, current_it

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching"><a class="header" href="#caching">Caching</a></h1>
<p>The Collatz sequence of starting numbers \( 4 \) and \( 8 \) are actually
quite similar :
\[
\begin{align} &amp;Collatz(4) = 4 \rightarrow 2 \rightarrow 1\\ &amp;Collatz(8) = 8 \rightarrow 4 \rightarrow 2 \rightarrow 1\\ \end{align} \]</p>
<p>By calculating \( Collatz(8) \) we ended up recalculating \( Collatz(4)
\), if we keep in memory the number of iterations of \( Collatz(4) \), we
could reuse it to find the number of iterations of \( Collatz(8) \).</p>
<p>That is what <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a> is,
storing data so that future requests for that data can be served faster.</p>
<p>In our case, when calculating the number of iteration of \( n \), we first
look if the value has already been computed, if not, we update the cache 
using the formula.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0014/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def longest_collatz_sequence(n=1000000):
    cache = {1: 1}

    def collatz(i):
        if i not in cache:
            cache[i] = collatz(i // 2 if i % 2 == 0 else 3 * i + 1) + 1

        return cache[i]

    return max(range(1, n), key=collatz)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-13"><a class="header" href="#solution-13">Solution</a></h1>
<hr />
<blockquote>
<p>837799</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lattice-paths"><a class="header" href="#lattice-paths"><a href="https://projecteuler.net/problem=15">Lattice paths</a></a></h1>
<blockquote>
<p>Starting in the top left corner of a \( 2×2 \) grid, and only being able to move to the right and down, there are exactly \( 6 \) routes to the bottom right corner.</p>
<p style="text-align: center;"><img alt="" class="dark_img" src="https://projecteuler.net/project/images/p015.png"/></p>
<p>How many such routes are there through a \( 20×20 \) grid?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-14"><a class="header" href="#brute-force-14">Brute force</a></h1>
<p>We are searching for the number of different paths starting from the top left
corner and going to the bottom right corner of a \( 20 \times 20 \)
square. The only possible moves are down and right. This is the same as
searching for the <a href="https://en.wikipedia.org/wiki/Lattice_path">Lattice path</a>.</p>
<p>Since the square is \( 20 \times 20 \) we have 20 moves down and 20 moves to
the right. If we move to the right, then we have 20 moves down and 19 moves to
the right, we can continue as long as we have moves available.</p>
<p>The solution can be done recursively, starting with 20 moves down and right, the
result being the combination of paths down and to the right. Each times we move
down we call the function recursively with the same number of moves to the
right, but one less move down. When the number of move down is 1, the result is
obviously 1: the only remaining path is the one to the right. The same can be
done for the move to the right.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0015/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def lattice_paths(up=20, down=20):
    moves_down = lattice_paths(up, down - 1) if down &gt; 1 else 1
    moves_up = lattice_paths(up - 1, down) if up &gt; 1 else 1

    return moves_up + moves_down
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-1"><a class="header" href="#dynamic-programming-1">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0015/solution1.html">Brute force</a> solution is not efficient at all, for example,
if we go down and then right or right and then down, we end up in the same
place. The <a href="problems/problem_0015/solution1.html">Brute force</a> solution will compute the answer twice.</p>
<p>We could use a cache, but let's do this solution iteratively rather than 
recursively.</p>
<p>We can represent the solution using a matrix, for example, for a \( 3 \times 3
\) square, we have the number of paths from the green point to the red point
for each sub parallelogram.</p>
<p align="center"> <img src="problems/problem_0015/../../images/p0015/p0015-s2-grid.png" style="width: 40%"> </p>
<p>Looking at the \( 2 \times 2 \) sub square, we can see that the number of
different paths is indeed 6.</p>
<p>For each red point, the number of different paths to it is the sum of the path
above and paths on the left.</p>
<p>For the first row and column, the number of different paths is one: either only
downs or only rights. Then, we can simply compute the path to the other red
points using the old ones, we simply return the value at the last cell.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0015/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def lattice_paths(n=20):
    n += 1
    paths = np.zeros((n, n), dtype=int)

    for i in range(1, n):
        paths[i, 0] = 1
        paths[0, i] = 1

    for i in range(1, n):
        for j in range(1, n):
            paths[i, j] = paths[i - 1, j] + paths[i, j - 1]

    return paths[n - 1, n - 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combination"><a class="header" href="#combination">Combination</a></h1>
<p>For a square of dimension \( n \), we know that whatever path we take, there
will be exactly \( n \) movements to the right and \( n \) movements down.
We can represent the path as a string of 'D' for down and 'R' for right.</p>
<p>For example, with a \( 3 \times 3 \) square, a path could be : 'RRRDDD',
'DDDRRR' or 'RDDRDR'. The question now is, 'In how many ways can we place the '
R' and the 'D' in the string ?'</p>
<p>Since there must be as many 'D' as 'R', we can only place the 'R' and leave the
rest as 'D'. That means we are searching for the number of ways we can place \(
n \) 'R' in a string of \( 2n \) characters. This is called
a <a href="https://en.wikipedia.org/wiki/Combination">combination</a>, in our case, it's:</p>
<p>\[ \begin{pmatrix} 2n\\ n \end{pmatrix} = \frac{\left(2n\right)!}{n!\left(2n - n\right)!} = \frac{\left (2n\right)!}{\left(n!\right)^2} \]</p>
<p>This can be calculated using factorial:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0015/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def lattice_paths(n=20):
    return factorial(2 * n) // (factorial(n) ** 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-14"><a class="header" href="#solution-14">Solution</a></h1>
<hr />
<blockquote>
<p>137846528820</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="power-digit-sum"><a class="header" href="#power-digit-sum"><a href="https://projecteuler.net/problem=16">Power digit sum</a></a></h1>
<blockquote>
<p>\( 2^{15}=32768 \) and the sum of its digits is \( 3+2+7+6+8=26 \).</p>
<p>What is the sum of the digits of the number \( 2^{1000} \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-15"><a class="header" href="#brute-force-15">Brute force</a></h1>
<p>Thanks to python, the solution is trivial, we just need to sum the digits of a
number, which can be done by casting it into a string and iterating on it.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0016/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def power_digit_sum(n=1000):
    return sum((int(d) for d in str(2**n)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-15"><a class="header" href="#solution-15">Solution</a></h1>
<hr />
<blockquote>
<p>1366</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-letter-counts"><a class="header" href="#number-letter-counts"><a href="https://projecteuler.net/problem=17">Number letter counts</a></a></h1>
<blockquote>
<p>If the numbers \( 1 \) to \( 5 \) are written out in words: one, two, three, four, five, then there are \( 3+3+5+4+4=19 \) letters used in total.</p>
<p>If all the numbers from \( 1 \) to \( 1000 \) (one thousand) inclusive were written out in words, how many letters would be used?</p>
<p><strong>NOTE:</strong> Do not count spaces or hyphens. For example, \( 342 \) (three hundred and forty-two) contains \( 23 \) letters and \( 115 \) (one hundred and fifteen) contains \( 20 \) letters. The use of &quot;and&quot; when writing out numbers is in compliance with British usage.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-16"><a class="header" href="#brute-force-16">Brute force</a></h1>
<p>This problem is boring, there is nothing interesting to do, we can only count
some word several times. For example, the word &quot;hundred&quot; is used 900 times from
100 to 999, this allows some factoring. We can do the same for the number from 1
to 9, for &quot;and&quot;, for 10, 20, 30, ...</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0017/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def number_letter_counts():
    unit = len(&quot;onetwothreefourfivesixseveneightnine&quot;)
    ten = len(&quot;teneleventwelvethirfourfifsixseveneighnine&quot;) + len(&quot;ten&quot;) * 7
    and_l = len(&quot;and&quot;)
    twenty = len(&quot;twentythirtyfortyfiftysixtyseventyeightyninety&quot;)
    hun = len(&quot;hundred&quot;)
    thou = len(&quot;onethousand&quot;)
    return thou + 900 * hun + 190 * unit + 100 * twenty + 891 * and_l + 10 * ten
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-16"><a class="header" href="#solution-16">Solution</a></h1>
<hr />
<blockquote>
<p>21124</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-path-sum-i"><a class="header" href="#maximum-path-sum-i"><a href="https://projecteuler.net/problem=18">Maximum path sum I</a></a></h1>
<blockquote>
<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is \( 23 \).</p>
<p>\[
\color{red}{3}\\\\
2\ \color{red}{4}\ 6\\\\
8\ 5\ \color{red}{9}\ 3
\]</p>
<p>That is, \( 3+7+4+9=23 \).</p>
<p>Find the maximum total from top to bottom of the triangle below:</p>
<p>\[
75\\\\
95\ 64\\\\
17\ 47\ 82\\\\
18\ 35\ 87\ 10\\\\
20\ 04\ 82\ 47\ 65\\\\
19\ 01\ 23\ 75\ 03\ 34\\\\
88\ 02\ 77\ 73\ 07\ 63\ 67\\\\
99\ 65\ 04\ 28\ 06\ 16\ 70\ 92\\\\
41\ 41\ 26\ 56\ 83\ 40\ 80\ 70\ 33\\\\
41\ 48\ 72\ 33\ 47\ 32\ 37\ 16\ 94\ 29\\\\
53\ 71\ 44\ 65\ 25\ 43\ 91\ 52\ 97\ 51\ 14\\\\
70\ 11\ 33\ 28\ 77\ 73\ 17\ 78\ 39\ 68\ 17\ 57\\\\
91\ 71\ 52\ 38\ 17\ 14\ 91\ 43\ 58\ 50\ 27\ 29\ 48\\\\
63\ 66\ 04\ 68\ 89\ 53\ 67\ 30\ 73\ 16\ 69\ 87\ 40\ 31\\\\
04\ 62\ 98\ 27\ 23\ 09\ 70\ 98\ 73\ 93\ 38\ 53\ 60\ 04\ 23
\]</p>
<p><strong>NOTE:</strong> As there are only \( 16384 \) routes, it is possible to solve this problem by trying every route. However, <a href="https://projecteuler.net/problem=67">Problem 67</a>, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-17"><a class="header" href="#brute-force-17">Brute force</a></h1>
<p>Even if the problem tells us not to use brute force, we will still do it. Not
because we want to do things easily, but because it will be much easier to find
a better solution later after solving the problem the first time.</p>
<p>First, we need to transform the triangle into something easier to manipulate,
for example a two-dimensional array.</p>
<p>The problem can be solved quite easily after that, with a simple recursion: The
maximum score is the current number plus the highest score by choosing the left
or the right.</p>
<p>It is enough to stop when we are outside the triangle, since the lower number is
0, we can consider that leaving the triangle is like adding 0.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0018/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def maximum_path_sum_I(filename):
    triangle = read_file(filename)

    def path(i, j):
        if i &gt;= len(triangle) or j &gt;= len(triangle[i]):
            return 0

        return triangle[i][j] + max(path(i + 1, j), path(i + 1, j + 1))

    return path(0, 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-2"><a class="header" href="#dynamic-programming-2">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0018/solution1.html">Brute force</a> solution has some issue, for example with the
following triangle:</p>
<p>\[ \begin{gather} 01\\ 02\quad 03\\ 04\quad \color{red}{05}\quad 06\\ 07\quad \color{green}{08}\quad \color{green}{09}\quad 10\\ \end{gather} \]</p>
<p>The path \( 1 \rightarrow 2 \rightarrow 5 \) and the path \( 1 \rightarrow 3
\rightarrow 5 \) both end on 5 and then try to find the best solution between 8
and 9. Obviously, the best choice is 9, because it is the largest number between
8 and 9 and there is no path left to take. It doesn't depend on where we come
from, which means that we can replace the number 5 with \( 5 + 9 = 14 \). We
can do the same with 4 and 6, which then gives the following triangle:</p>
<p>\[ \begin{gather} 01\\ 02\quad 03\\ \color{red}{12}\quad \color{red}{14}\quad \color{red}{16}\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>And we can go all the way to the end by reducing the last line each time:</p>
<p>\[ \begin{gather} 01\\ \color{red}{16}\quad \color{red}{19}\\ 12\quad 14\quad 16\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>And finally:</p>
<p>\[ \begin{gather} \color{red}{20}\\ 16\quad 19\\ 12\quad 14\quad 16\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>This solution is much faster because it doesn't recalculate anything twice, it
just chooses the best path from the end, since we don't need to know where we
came from to find the best incoming path.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0018/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def maximum_path_sum_I(filename):
    triangle = read_file(filename)

    for i in range(len(triangle) - 2, -1, -1):
        for j in range(len(triangle[i])):
            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])

    return triangle[0][0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-17"><a class="header" href="#solution-17">Solution</a></h1>
<hr />
<blockquote>
<p>1074</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting-sundays"><a class="header" href="#counting-sundays"><a href="https://projecteuler.net/problem=19">Counting Sundays</a></a></h1>
<blockquote>
<p>You are given the following information, but you may prefer to do some research for yourself.</p>
<ul>
<li>1 Jan 1900 was a Monday.</li>
<li>Thirty days has September,<br />
April, June and November.<br />
All the rest have thirty-one,<br />
Saving February alone,<br />
Which has twenty-eight, rain or shine.<br />
And on leap years, twenty-nine.</li>
<li>A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.</li>
</ul>
<p>How many Sundays fell on the first of the month during the twentieth century (\( 1 \) Jan \( 1901 \) to \( 31 \) Dec \( 2000 \))?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-18"><a class="header" href="#brute-force-18">Brute force</a></h1>
<p>This problem is not fascinating, we could start from the first of January 1901
as a Tuesday, and iterate on each month, for example the first day of February
1901 is Tuesday + \( 31\ \%\ 7 \), which is Friday. We could continue by
taking leap year into account. But thanks to Python, we can solve this problem
with a simpler solution:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0019/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def counting_sundays():
    res = 0
    for year in range(1901, 2001):
        for month in range(1, 13):
            if datetime.datetime(year, month, 1).weekday() == 6:
                res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-18"><a class="header" href="#solution-18">Solution</a></h1>
<hr />
<blockquote>
<p>171 </p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorial-digit-sum"><a class="header" href="#factorial-digit-sum"><a href="https://projecteuler.net/problem=20">Factorial digit sum</a></a></h1>
<blockquote>
<p>\( n! \) means \( n × (n  −1) ×...×3×2×1 \)</p>
<p>For example, \( 10!=10×9×...×3×2×1=3628800 \),
and the sum of the digits in the number \( 10! \) is \( 3+6+2+8+8+0+0=27 \).</p>
<p>Find the sum of the digits in the number \( 100! \)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-19"><a class="header" href="#brute-force-19">Brute force</a></h1>
<p>As always, problems involving large numbers are easy to solve in Python, just
compute the number and iterate on it as a string:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0020/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def factorial_digit_sum(n=100):
    return sum(int(x) for x in str(factorial(n)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-19"><a class="header" href="#solution-19">Solution</a></h1>
<hr />
<blockquote>
<p>648</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="amicable-numbers"><a class="header" href="#amicable-numbers"><a href="https://projecteuler.net/problem=21">Amicable numbers</a></a></h1>
<blockquote>
<p>Let \( d(n) \) be defined as the sum of proper divisors of \( n \) (numbers less than \( n \) which divide evenly into \( n \)).</p>
<p>If \( d(a) =  b \) and \( d(b) = a \), where \( a ≠ b \), then \( a \) and \( b \) are an amicable pair and each of \( a \) and \( b \) are called amicable numbers.</p>
<p>For example, the proper divisors of \( 220 \) are \( 1 \), \( 2 \), \( 4 \), \( 5 \), \( 10 \), \( 11 \), \( 20 \), \( 22 \), \( 44 \), \( 55 \) and \( 110 \); therefore \( d(220)=284 \). The proper divisors of \( 284 \) are \( 1 \), \( 2 \), \( 4 \), \( 71 \) and \( 142 \); so \( d(284)=220 \).</p>
<p>Evaluate the sum of all the amicable numbers under \( 10000 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-20"><a class="header" href="#brute-force-20">Brute force</a></h1>
<p>The problem first requires to find the sum of proper divisors of a number, if
recall, in the
<a href="problems/problem_0021/../problem_0012/problem.html">Problem 12: Highly divisible triangular number</a>, we
found the number of proper divisors, we can reuse this function by adding the
divisors rather than counting them.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0021/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root + 1):
        if n % i == 0:
            res += i + n // i

    return res
</code></pre>
<p>We can simply iterate from 1 to 10000 and sum the amicable numbers found to find
the solution, we just to be aware that even if \( d(6) = 6 \) and so \( d(6)
= 6 \), 6 is not an amicable number because amicable numbers are in pairs.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0021/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def amicable_numbers(n=10000):
    res = 0
    for i in range(2, n):
        current = sum_of_factors(i)
        if i != current and i == sum_of_factors(current):
            res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-20"><a class="header" href="#solution-20">Solution</a></h1>
<hr />
<blockquote>
<p>31626</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="names-scores"><a class="header" href="#names-scores"><a href="https://projecteuler.net/problem=22">Names scores</a></a></h1>
<blockquote>
<p>Using <a href="https://projecteuler.net/project/resources/p022_names.txt">names.txt</a> (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.</p>
<p>For example, when the list is sorted into alphabetical order, COLIN, which is worth \( 3+15+12+9+14=53 \), is the \( 938 \)th name in the list. So, COLIN would obtain a score of \( 938×53=49714 \).</p>
<p>What is the total of all the name scores in the file?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-21"><a class="header" href="#brute-force-21">Brute force</a></h1>
<p>We first get the huge list of names in python, we just need to remove the <code>&quot;&quot;</code>
around them.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0022/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return [name[1:-1] for name in file.read().split(&quot;,&quot;)]
</code></pre>
<p>Then we just need to sum the letters of the names by their position in the
alphabet. Since all the names are capitalized, we can remove <code>ord('A') + 1</code> to
get their position in the alphabet. The last step is to sum the position of the
names in the list by its value.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0022/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def names_scores(filename):
    names = read_file(filename).sort()
    return sum((i + 1) * sum(ord(c) - ord(&quot;A&quot;) + 1 for c in name) for (i, name) in enumerate(names))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-21"><a class="header" href="#solution-21">Solution</a></h1>
<hr />
<blockquote>
<p>871198282</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-abundant-sums"><a class="header" href="#non-abundant-sums"><a href="https://projecteuler.net/problem=23">Non-abundant sums</a></a></h1>
<blockquote>
<p>A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of \( 28 \) would be \( 1+2+4+7+14=28 \), which means that \( 28 \) is a perfect number.</p>
<p>A number \( n \) is called deficient if the sum of its proper divisors is less than \( n \) and it is called abundant if this sum exceeds \( n \).</p>
<p>As \( 12 \) is the smallest abundant number, \( 1+2+3+4+6=16 \), the smallest number that can be written as the sum of two abundant numbers is \( 24 \). By mathematical analysis, it can be shown that all integers greater than \( 28123 \) can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.</p>
<p>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-22"><a class="header" href="#brute-force-22">Brute force</a></h1>
<p>We are searching for all numbers that are <strong>not</strong> the sum of two abundant
numbers. Since every integer larger than 28123 can be written as the sum of two
abundant numbers, our upper limit is therefore 28123.</p>
<p>First, we need to find all the abundant number below 28123, going higher is
pointless because we are searching for positive numbers only. An abundant number
is a number that have a larger sum of divisors than itself. We already have a
function to compute the sum of divisors, we just need to be aware that if \(
\sqrt{n} \) divide \( n \), it only has to count once.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root + 1):
        if n % i == 0:
            res += i + n // i

    if root**2 == n:
        res -= root

    return res
</code></pre>
<p>We just need to check if a number is the sum of two of the abundant numbers
calculated earlier. The naive way to do this is to try every combination of two
abundant numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_sum(i, abundant):
    return any(a1 + a2 == i for a1 in abundant for a2 in abundant)
</code></pre>
<p>Finally, we just have to sum each number less than 28124 that is not the sum 
of two abundant numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def non_abundant_sums():
    abundant = [i for i in range(1, 28124) if sum_of_factors(i) &gt; i]

    return sum(i for i in range(28124) if not is_sum(i, abundant))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set"><a class="header" href="#set">Set</a></h1>
<p>The <a href="problems/problem_0023/solution1.html">Brute Force</a> solution is extremely slow, the biggest issue is
how we determine if a number is the sum of two abundant numbers.</p>
<p>We are searching for any abundant numbers \( a_1 \) and \( a_2 \) such that
\( a_1 + a_2 = n \), which implies that \(a_2 = n - a_2 \). If \( n - a_2
\) is an abundant number, then \( n \) is the sum of two abundant numbers.</p>
<p>Finding a value in a list is slow because we need to go through the whole list,
that's why using a <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">set</a>
to store our abundant is more efficient in our this case. We just need to
iterate over all abundant once and check if \( n \) minus this abundant is
also in the set.</p>
<p>We can also improve the way we build this set of abundant numbers. Since we have
an upper bound, we can construct the sum of divisors of all these numbers at
once. For every \( i \) and \( j \) such that \( i \times j &lt; limit \),
the number \( i \times j \) has both \( i \) and \( j \) as divisors. We
just need to be aware that if \( i = j \) we need to add the divisor only
once.</p>
<p>We start with a list of 1 because 1 divides all numbers. Then we iterate with
\( i \) from 2 to \( \left\lfloor\sqrt{limit}\right\rfloor \) and \( j \)
from \( i + 1 \) (to avoid the case where \( i = j \)) to \( i \times j &gt;
limit \Leftrightarrow j &gt; \left\lfloor \frac{limit}{i} \right\rfloor \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def get_sum_of_factors(n):
    sum_of_factors = [1] * (n + 1)
    for i in range(2, floor(sqrt(n)) + 1):
        sum_of_factors[i * i] += i
        for j in range(i + 1, (n // i) + 1):
            sum_of_factors[i * j] += i + j

    return sum_of_factors
</code></pre>
<p>In the previous solution, we first built the list of abundant numbers and then
searched for the number that was not a sum of two of them, since we always have
\( a_1 &lt;= a_2 \) we can actually do both at the same time.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def non_abundant_sums(n=28123):
    sum_of_factors = get_sum_of_factors(n)
    abundant = set()
    res = 0

    for i in range(1, n + 1):
        if sum_of_factors[i] &gt; i:
            abundant.add(i)
        if all((i - a1 not in abundant) for a1 in abundant):
            res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-22"><a class="header" href="#solution-22">Solution</a></h1>
<hr />
<blockquote>
<p>4179871</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexicographic-permutations"><a class="header" href="#lexicographic-permutations"><a href="https://projecteuler.net/problem=24">Lexicographic permutations</a></a></h1>
<blockquote>
<p>A permutation is an ordered arrangement of objects. For example, \( 3124 \) is one possible permutation of the digits \( 1 \), \( 2 \), \( 3 \) and \( 4 \). If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of \( 0 \), \( 1 \) and \( 2 \) are:</p>
<p>\[
012\ \ 021\ \ 102\ \ 120\ \ 201\ \ 210
\]</p>
<p>What is the millionth lexicographic permutation of the digits \( 0 \), \( 1 \), \( 2 \), \( 3 \), \( 4 \), \( 5 \), \( 6 \), \( 7 \), \( 8 \) and \( 9 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-23"><a class="header" href="#brute-force-23">Brute force</a></h1>
<p>First of all, we need to understand how the lexicographic permutations are
computed. If we enumerate all the permutations of '0123' starting with '0':</p>
<p>\[ 0123\\ 0132\\ 0213\\ 0231\\ 0312\\ 0321\\ \]</p>
<p>By removing the '0' we get:</p>
<p>\[ 123\\ 132\\ 213\\ 231\\ 312\\ 321\\ \]</p>
<p>It's the lexicographic permutations of '123' !</p>
<p>We can continue:</p>
<p>\[\begin{align} &amp;123\ &amp;&amp;213\ &amp;&amp;321\\ &amp;132\ &amp;&amp;231\ &amp;&amp;321 \end{align} \]</p>
<p>By removing the first character each time, it gives:</p>
<p>\[\begin{align} &amp;23\ &amp;&amp;13\ &amp;&amp;21\\ &amp;32\ &amp;&amp;31\ &amp;&amp;21 \end{align} \]</p>
<p>That is, the lexicographic permutations of '23', '13', and '21',</p>
<p>Now, enumerating all permutations of '0123' starting with '1':</p>
<p>\[ 1023\\ 1032\\ 1203\\ 1230\\ 1302\\ 1230 \]</p>
<p>By removing the '1' we get:</p>
<p>\[ 023\\ 032\\ 203\\ 230\\ 302\\ 230 \]</p>
<p>It's the lexicographic permutations of '023' !</p>
<p>This means that we can compute all the lexicographic permutations of a string by
taking each character, placing it at the beginning of the new permutations and
then adding the lexicographic permutations of the rest of the string
recursively.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0024/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def lexicographic_permutations(s):
    if len(s) &lt;= 1:
        yield s
    else:
        for i in range(len(s)):
            for p in lexicographic_permutations(s[:i] + s[i + 1 :]):
                yield s[i] + p
</code></pre>
<p>By using <code>yield</code>, we create a generator, it's better than storing 1 million
elements and then returning the last one, just take the 1000000th element
generated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maths-permutations"><a class="header" href="#maths-permutations">Maths permutations</a></h1>
<p>If you have understood how lexicographic permutation are constructed, you should
have noticed that permutations are made from right to left. Before updating the
number on the left, all permutations on the right must have been made. That is
why with the string '0123', the first 6 permutations begin with '0', then the 6
following permutations with '1', and so on.</p>
<p>The string in our examples contains 4 characters, it implies that every \( ( 4
- 1 )! \) permutations the first digit will change. We can even tell which
one will be placed first by knowing the multipliers of that factorial. If it is
the \( 3 * 3! \)th permutations, the first digit will be the third one in the
string, '3' in this example.</p>
<p>Since this process is recursive, we can find the first digit each time by
reducing the n-th permutations we are looking for.</p>
<p>For example, if we researched the 15th lexicographic permutations, we know that
the first character will be '2' because the \( 3! \) first permutations will
start with '0', the next \( 3! \) with '1'.</p>
<p>The 12th lexicographic permutations is obviously '2013'. It's just '0123', but
the '2' is place at the first position. Now that we have our first digit, we can
remove those 12 permutations from the 15th, which gives us 3 permutations.</p>
<p>Now, we are searching for the third lexicographic permutations of '013', with
the same reasoning, we can find that the first digit will be '1' after \( 1 *
2! \) permutations. It leaves use with 1 permutation and the string '03'.</p>
<p>After \( 1 * 1! \) permutations the first digit will be '3'. It leaves us with
'0' which is the last digit. The 15 lexicographic permutations is '2130' !</p>
<p>We just have to find the quotient and remainder of our nth permutations, the
divisor being the length of the string minus one. We can continue as long as our
string contains more than one character.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0024/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def lexicographic_permutations(s, n):
    if len(s) &lt;= 1:
        return s
    q, r = divmod(n, factorial(len(s) - 1))
    return s[q] + lexicographic_permutations(s[:q] + s[q + 1 :], r)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-23"><a class="header" href="#solution-23">Solution</a></h1>
<hr />
<blockquote>
<p>2783915460</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="1000-digit-fibonacci-number"><a class="header" href="#1000-digit-fibonacci-number"><a href="https://projecteuler.net/problem=25">1000-digit Fibonacci number</a></a></h1>
<blockquote>
<p>The Fibonacci sequence is defined by the recurrence relation:</p>
<p>\[
F_n = F_{n−1} + F_{n−2},\ where\ F_1 = 1\ and\ F_2 = 1.
\]</p>
<p>Hence the first \( 12 \) terms will be:</p>
<p>\[
\begin{align}
F1 &amp;= 1\\
F2 &amp;= 1\\
F3 &amp;= 2\\
F4 &amp;= 3\\
F5 &amp;= 5\\
F6 &amp;= 8\\
F7 &amp;= 13\\
F8 &amp;= 21\\
F9 &amp;= 34\\
F10 &amp;= 55\\
F11 &amp;= 89\\
F12 &amp;= 144
\end{align}
\]</p>
<p>The \( 12 \)th term, \(F_{12} \), is the first term to contain three digits.</p>
<p>What is the index of the first term in the Fibonacci sequence to contain \( 1000 \) digits?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-24"><a class="header" href="#brute-force-24">Brute force</a></h1>
<p>The brute force solution is simple, just iterate until the number of digits 
is at least 1000. We can count the number of digits in a number by turning 
it into a string and counting its length.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0025/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def thousandth_digit_fibonacci_number(n=1000):
    f1 = 1
    f2 = 1
    res = 1
    while len(str(f1)) &lt; n:
        f1, f2 = f2, f1 + f2
        res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-convergence"><a class="header" href="#fibonacci-convergence">Fibonacci convergence</a></h1>
<p>We know from <a href="problems/problem_0025/../problem_0002/solution3.html">Fibonacci and the golden ratio</a>
that the n-th term of Fibonacci can be expressed as :</p>
<p>\[ F_{n} = \frac{\varphi^{n}}{\sqrt{5}} = \frac{\left(\frac{1+\sqrt{5}}{2}
\right)^n}{\sqrt{5}} \]</p>
<p>Searching for a number with at least 1000 digit is the same as searching a
for number that is greater than or equal to \( 10^{999} \)</p>
<p>\[ \begin{align} \frac{\varphi^{n}}{\sqrt{5}} &amp; &gt;= 10^{999}\\
n * \log(\varphi) - \frac{\log(5)}{2} &amp; &gt;= 999 * log(10)\\
n &amp; &gt;= \frac{\frac{\log(5)}{2} + 999}{\log(\varphi)}\\ 
n &amp; = \left\lceil\frac{\frac{\log(5)}{2} + 999}{\log(\varphi)} \right\rceil\\ \end{align} \]</p>
<p>Since n must be an integer, it is sufficient to take the ceiling from the
previous equation.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0025/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def thousandth_digit_fibonacci_number(n=1000):
    return ceil((n - 1 + log10(sqrt(5)) / 2) / log10((1 + sqrt(5)) / 2))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-24"><a class="header" href="#solution-24">Solution</a></h1>
<hr />
<blockquote>
<p>4782</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="reciprocal-cycles"><a class="header" href="#reciprocal-cycles"><a href="https://projecteuler.net/problem=26">Reciprocal cycles</a></a></h1>
<blockquote>
<p>A unit fraction contains \( 1 \) in the numerator. The decimal representation of the unit fractions with denominators \( 2 \) to \( 10 \) are given:</p>
<p>\[
\begin{align}
\frac{1}{2}\ &amp;=0.5\\
\frac{1}{3}\ &amp;=0.(3)\\
\frac{1}{4}\ &amp;=0.25\\
\frac{1}{5}\ &amp;=0.2\\
\frac{1}{6}\ &amp;=0.1(6)\\
\frac{1}{7}\ &amp;=0.(142857)\\
\frac{1}{8}\ &amp;=0.125\\
\frac{1}{9}\ &amp;=0.(1)\\
\frac{1}{10}&amp;=0.1
\end{align}
\]</p>
<p>Where \( 0 \).\( 1 \)(\( 6 \)) means \( 0 \).\( 166666... \), and has a \( 1 \)-digit recurring cycle. It can be seen that \( \frac{1}{7} \) has a \( 6 \)-digit recurring cycle.</p>
<p>Find the value of \( d \) \( &lt;1000 \) for which \( \frac{1}{d} \) contains the longest recurring cycle in its decimal fraction part.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-25"><a class="header" href="#brute-force-25">Brute force</a></h1>
<p>How do you find the decimals of a fraction?</p>
<p>In elementary school, we learned a method to convert fractions to decimals.
Repeat the process of multiplying the numerator by 10:</p>
<ul>
<li>The next numerator is the rest of the Euclidean division by the denominator.</li>
<li>The quotient is the next decimal.</li>
</ul>
<p>For example with \( \frac{1}{7} \):</p>
<p>\[ \begin{align} \frac{1}{7} &amp;= 7 * \mathbf{0} + 1\\ \frac{10}{7} &amp;= 7 * \mathbf{1} + 3\\ \frac{30}{7} &amp;= 7 * \mathbf{4} + 2\\ \frac{20}{7} &amp;= 7 * \mathbf{2} + 6\\ \frac{60}{7} &amp;= 7 * \mathbf{8} + 4\\ \frac{40}{7} &amp;= 7 * \mathbf{5} + 5\\ \frac{50}{7} &amp;= 7 * \mathbf{7} + 1\\ \frac{10}{7} &amp;= \dots\\ \end {align} \]</p>
<p>That give us \( \frac{1}{7} = 0,142857... \).</p>
<p>We just have to pay attention to some special cases:</p>
<ul>
<li>When the rest is 0, the division is finite and there is no cycle. We can
assume that the length of the cycle is 0.</li>
<li>The length of the cycle is not the number of time we repeat the process of
finding the decimals of a fraction. For example with \( \frac{1}{6} = 0,
166... \) the cycle is 1. But there is some leading number before it.</li>
</ul>
<p>Detecting the cycle is possible using a set. But we will have no way of knowing
when it started, which is required to find its length. We need to store both the
numbers and their positions for every decimal. When a duplicate is found, it is
enough to calculate the length between the old and the newly found duplicate.
Rather than a set, using a dictionary whose key is the rest and value its
position in the decimal form of the fraction will solve both problem.</p>
<pre><code class="language-python">def find_cycle(n):
    rest = 1
    seen = {}
    for i in itertools.count(0):
        if rest == 0:
            return 0
        if rest in seen:
            return i - seen[rest]

        seen[rest] = i
        rest = (rest * 10) % n
</code></pre>
<p>The last step is to test all numbers below 1000 and find the one with the
greatest cycle.</p>
<pre><code class="language-python">def reciprocal_cycles(n=1000):
    return max(((find_cycle(i), i) for i in range(2, n)))[1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carmichael-function"><a class="header" href="#carmichael-function">Carmichael function</a></h1>
<p>The <a href="problems/problem_0026/solution1.html">Brute force</a> solution works and is not that slow. Yet, with a
few observations, we can improve it.</p>
<ol>
<li>If you played a bit with the previous snippet of code, you might have notice
that most of the duplicate digits are 1. That's not a coincidence, the first
rest is also 1. In fact, what we are searching for is more known as the
result of
the <a href="https://en.wikipedia.org/wiki/Carmichael_function">Carmichael function</a>:</li>
</ol>
<blockquote>
<p>The Carmichael function associates to every positive interger \( n \) a
positive integer \lambda{n}, defined as the smallest positive integer \(
m \) such that
\[ a^m \equiv 1\ [ n ] \]</p>
</blockquote>
<p>In our case, \( a \) is always 10 and \( m \) is the length of the cycle we
are searching for the number \( n \).</p>
<p>Knowing that, we can try to make some observations:</p>
<ol start="2">
<li>
<p>Let \( f=\frac{1}{2^{a} 5^{b}} \), where \( a,b\in\mathbb{Z}_{\geqslant 0}
\). f has a finite and non-recurring decimal
representation. <a href="https://en.wikipedia.org/wiki/Decimal_representation#Finite_decimal_representations">Proof on Wikipedia</a>
.</p>
</li>
<li>
<p>If \( \frac{1}{m} \) is a repeating decimal and \( \frac{1}{n} \) is a
terminating decimal, them \( \frac{1}{mn} \) has a nonperiodic part whose
length is that of \( \frac{1}{n} \) and a repeating part whose length is
that of \( \frac {1}{m} \).
From <a href="https://mathworld.wolfram.com/RepeatingDecimal.html">Wolfram MathWorld</a></p>
</li>
<li>
<p>The recurring part of \( \frac{1}{d} \) cannot have more than \( d - 1 \)
digits. <a href="https://en.wikipedia.org/wiki/Carmichael_function#Order_of_elements_modulo_n">Proof on Wikipedia</a></p>
</li>
</ol>
<p>Let's try to use this information in our program:</p>
<p>We can reduce \( n \) by dividing it with \( 2 \) or \( 5 \) until it
become coprime with \( 10 \) (3). If after this reduction \( n = 1 \), \(
\frac{1}{n} \) has no recurring part (2).</p>
<p>We do not need to use a dictionary to find our cycle. Since \( n \) will be
coprime with 10, there will not be any leading number before the recurring
part (4). We know that if the rest is 1, we found our cycle (1).</p>
<pre><code class="language-python">def find_cycle(n):
    while n % 2 == 0:
        n /= 2
    while n % 5 == 0:
        n /= 5

    if n == 1:
        return 0

    i = 1
    r = 10
    while r != 1:
        r = (r * 10) % n
        i += 1

    return i
</code></pre>
<p>We can start from 1000 and iterate until \( \frac{n}{2} \) (2). If we find \(
n \) such that \( \lambda{n} == n - 1 \), there will be no point to go any
further (4).</p>
<pre><code class="language-python">def reciprocal_cycles(n=1000):
    max_cycle = 0
    res = 0
    for i in range(n, n // 2, -1):
        current_cycle = find_cycle(i)

        if current_cycle == i - 1:
            return i

        if current_cycle &gt; max_cycle:
            max_cycle = current_cycle
            res = i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-25"><a class="header" href="#solution-25">Solution</a></h1>
<hr />
<blockquote>
<p>983</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="quadratic-primes"><a class="header" href="#quadratic-primes"><a href="https://projecteuler.net/problem=27">Quadratic primes</a></a></h1>
<blockquote>
<p>Euler discovered the remarkable quadratic formula:</p>
<p>\[
n^2 + n + 41
\]</p>
<p>It turns out that the formula will produce \( 40 \) primes for the consecutive integer values \( 0  \leq n \leq 39 \). However, when \( n=40 \), \( 40^2+40+41=40(40+1)+41 \) is divisible by \( 41 \), and certainly when \( n=41 \), \( 41^2+41+41 \) is clearly divisible by \( 41 \).</p>
<p>The incredible formula \( n^2-79n+1601 \) was discovered, which produces \( 80 \) primes for the consecutive values \( 0 \leq n \leq 79 \). The product of the coefficients, \( −79 \) and \( 1601 \), is \( −126479 \).</p>
<p>Considering quadratics of the form:</p>
<p>\[
\begin{align}
&amp; n^2 + an + b,\ where\ |a|&lt; 1000\ and\ |b|\ \leq 1000\\
\\
&amp; where\ |n|\ is\ the\ modulus/absolute value\ of\ n\\
&amp; e.g.\ |11|=11\ and\ |-4|=4
\end{align}
\]</p>
<p>Find the product of the coefficients, \( a \) and \( b \), for the quadratic expression that produces the maximum number of primes for consecutive values of \( n \), starting with \( n=0 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-26"><a class="header" href="#brute-force-26">Brute force</a></h1>
<p>The problem is to find the best combination of \( a \) and \( b \) such that
the formula:</p>
<p>\[ n^2 + an + b \]</p>
<p>produces the largest number of primes for consecutive values of \( n \). The
absolute value of \( a \) and \( b \) must be less than \( 1000 \).</p>
<p>The brute force solution is to iterate from \( -1000 \) to \( 1000 \)
for \( a \) and \( b \) and count the number of consecutive primes each
time.</p>
<pre><code class="language-python">def quadratic_primes(limit=1000):
    res = 0
    max_primes = 0
    for a in range(-limit, limit):
        for b in range(-limit, limit):
            n = 0
            while isprime(n ** 2 + a * n + b):
                n += 1
            if n &gt; max_primes:
                max_primes = n
                res = a * b

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shorten-the-intervals"><a class="header" href="#shorten-the-intervals">Shorten the intervals</a></h1>
<p>If with take a closer look at the equation, we should find useful information.
For example, with some peculiar values of \( n \), we can narrow down the
ranges of \( a \) and \( b \).</p>
<p>We are searching \( p \) prime such that:</p>
<p>\[ p = n^2 + an + b \]</p>
<p>For \( n = 0\), the equation is \( p = b \). That means that \( b \)
must be a prime.</p>
<p>For \( n = b \), the equation is \( p = b^2 + ab + b = b(b + a + 1) \)
which is divisible by \( b \). \( b \) is in fact the limit of consecutive
primes that can be found using this equation.</p>
<p>Rearranging the equation we have:</p>
<p>\[ p = n^2 + an + b \Leftrightarrow p - b = n(n + a) \]</p>
<p>Since both \( p \) and \( b \) are prime, \( p - b \) is an even number.</p>
<p>If \( n \) is even then \( n(n + a) \) will also be even.<br />
If \( n \) is odd, then \( n(n + a) \) will be odd only if \( a \) is odd.</p>
<p>For \( n = 1 \), \( n^2 + an + b \) will never be a prime if \( a \) is
even.</p>
<p>All this information can help quite a bit:</p>
<ul>
<li>\( a \) must be an odd number between.</li>
<li>b must be a prime.</li>
<li>b is the upper limit of consecutive primes.</li>
</ul>
<pre><code class="language-python">def quadratic_primes():
    primes_b = list((primerange(0, 1000)))[::-1]  # b is prime.
    res = 0
    max_primes = 0
    for a in range(-999, 1000, 2):  # a is odd.
        for b in primes_b:
            if b &lt; max_primes:  # b is the limit for consecutive prime.
                continue

            n = 0
            while isprime(n ** 2 + a * n + b):
                n += 1

            if n &gt; max_primes:
                max_primes = n
                res = a * b

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lucky-numbers-of-euler"><a class="header" href="#lucky-numbers-of-euler">Lucky numbers of Euler</a></h1>
<p>Thanks
to <a href="https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">mathworld</a>
, we know that if \( p(n) = n^2 + n + 41 \) is prime-generating for \(
0 \leq n \leq L \), then so is \( p(L - n) \).</p>
<p>\[ \begin{align} &amp;p(n) = n^2 + n + 41\\ &amp;p(L - n) = (L - n)^2 + L - n + 41\\ &amp;p(L - n) = L^2 - 2Ln + n^2 + L - n + 41\\ &amp;p(L - n) = n^2 - (2L + 1)n + L^2 + L + 41\\ &amp;p(L - n) = n^2 - (2L + 1)n + p(L)\\ &amp;p(L - n) = n^2 + an + b\\ &amp;where\ a = -(2L + 1)\ and\ b = L^2 + L + 41\\ \end{align} \]</p>
<p>We also know from the <a href="problems/problem_0027/solution2.html">Shorten the intervals</a> solution that when
\( n = 0 \), \( b = L^2 + L + 41 \) is prime. Since \( |b| &lt; 1000 \) we
have:</p>
<p>\[ b = L^2 + L + 41 &lt; 1000 \Rightarrow -31 \leq L \leq 31 \]</p>
<p>We also know that \( b \) is the upper limit of consecutive primes, it means
that \( b \) must be the largest number possible. It corresponds to \( L = 30
\) and \( b = 30^2 + 30 + 41 = 971 \) and \( a = -(2 \times 30 + 1)
= -61 \).</p>
<p>We can find a general solution based on the limit by searching the value of \(
L \) and then computing \( a \times b = (L^2 + L + 41) \times (-2(L + 1))
\).</p>
<p>The value of \( L \) is the largest solution for \( L^2 + L + 41 &lt; limit \)
.<br />
We have \( \Delta = 1 - 4(41 - limit) \), thus the solution is L = 
\( \left\lfloor \frac{-1 + \sqrt{4(41 - limit)}}{2} \right\rfloor \)</p>
<pre><code class="language-python">def quadratic_primes(limit=1000):
    l = floor((-1 + sqrt(1 - 4 * (41 - limit))) / 2)
    return (l ** 2 + l + 41) * (-(2 * l + 1))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-26"><a class="header" href="#solution-26">Solution</a></h1>
<hr />
<blockquote>
<p>-59231</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-spiral-diagonals"><a class="header" href="#number-spiral-diagonals"><a href="https://projecteuler.net/problem=28">Number spiral diagonals</a></a></h1>
<blockquote>
<p>Starting with the number \( 1 \) and moving to the right in a clockwise direction a \( 5 \) by \( 5 \) spiral is formed as follows:</p>
<p>\[
\begin{gather}
\color{red}{21}\ 22\ 23\ 24\ \color{red}{25}\\
20\ \ \ \color{red}{7}\ \ \ 8\ \ \ \color{red}{9}\ 10\\
19\ \ \ 6\ \ \ \color{red}{1}\ \ \ 2\ 11\\
18\ \ \ \color{red}{5}\ \ \ 4\ \ \ \color{red}{3}\ 12\\
\color{red}{17}\ 16\ 15\ 14\ \color{red}{13}\\
\end{gather}
\]</p>
<p>It can be verified that the sum of the numbers on the diagonals is \( 101 \).</p>
<p>What is the sum of the numbers on the diagonals in a \( 1001 \) by \( 1001 \) spiral formed in the same way?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-27"><a class="header" href="#brute-force-27">Brute force</a></h1>
<p>This problem actually contains two problem. The first is the spiral creation
problem and the second is the diagonal sum problem.</p>
<p>The direction of the spiral is a cycle of 'EAST', 'SOUTH', 'WEST' and 'NORTH'
but the main question is to know when it changes.</p>
<p>There is many ways of creating a spiral matrix, but the idea I had was to insert
number in every cell in the same direction until the cell in the next direction
is empty.</p>
<p>Once the spiral matrix is created, we can compute the diagonal using the
<code>trace</code> function of numpy. We also need to remove the cell in the middle because
it will be counted twice.</p>
<pre><code class="language-python">def number_spiral_diagonals(n=1001):
    dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # EAST, SOUTH, WEST, NORTH
    cur_dir = 0
    (x, y) = (n // 2, n // 2)  # Center of the matrix
    spiral = np.zeros(n * n, dtype=int).reshape(n, n)
    spiral[x, y] = 1

    for i in range(2, n * n + 1):
        # Move along the current direction and update the new cell
        dx, dy = dir[cur_dir]
        x, y = x + dx, y + dy
        spiral[x, y] = i

        # If the cell in the next direction is empty: change direction
        dx, dy = dir[(cur_dir + 1) % 4]
        if spiral[x + dx, y + dy] == 0:
            cur_dir = (cur_dir + 1) % 4

    return np.trace(spiral) + np.trace(np.fliplr(spiral)) - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation"><a class="header" href="#summation">Summation</a></h1>
<p>The sum of the diagonals is actually the sum of the 4 corners of each subcube of
the spiral matrix.</p>
<p>With:</p>
<p>\[
\begin{gather} \color{red}{21}\ 22\ 23\ 24\ \color{red}{25}\\ 20\ \ \ \color{red}{7}\ \ \ 8\ \ \ \color{red}{9}\ 10\\ 19\ \ \ 6\ \ \ \color{red}{1}\ \ \ 2\ 11\\ 18\ \ \ \color{red}{5}\ \ \ 4\ \ \ \color{red}{3}\ 12\\ \color{red}{17}\ 16\ 15\ 14\ \color{red}{13}\\ \end{gather} \]</p>
<p>The sum is \( (1) + (3 + 5 + 7 + 9) + (13 + 17 + 21 + 25) \)</p>
<p>For an \( n \times n \) grid, with n being odd, the top right corner is \( n^
2 \), the top left corner is \( n^2 -n + 1 \), the bottom left corner is \(
n^2 -2n + 2 \) and the bottom right corner is \( n^2 -3n + 3 \). The sum of
these corners is \( 4n^2 -6n + 6 \).</p>
<p>We need to sum these corners for all odd \( n \) between 3 and \( l \). Odd
numbers can be written in the form \( 2k + 1 \). By replacing \( n \)
with \( 2k + 1 \) we have:</p>
<p>\[ 4n^2 -6n + 6 = 4(2k+1)^2 -6(2k+1) + 6 = 16k^2 + 4k + 4 \]</p>
<p>The sum become:</p>
<p>\[ \begin{align} S &amp;= \sum _{k=1}^{m} 16k^{2} + 4k + 4\\ S &amp;= 16\sum _{k=1}^ {m} k^{2} + 4\sum _{k=1}^{m} k + 4\sum _{k=1}^{m} 1\\ S &amp;= \frac{16m(m+1) (2m+1)}{6} + \frac{4m(m + 1)}{2} + 4m\\ S &amp;= \frac{16m^3}{3} + 10m^2 + \frac{26m}{3}\\ \end{align} \]</p>
<p>where \( m = \frac{l - 1}{2} \)</p>
<p>This sum plus \( 1 \) (the center of the spiral matrix) is the solution we are
searching for:</p>
<pre><code class="language-python">def number_spiral_diagonals(n=1001):
    m = (n - 1) // 2
    return int(1 + (16 / 3) * m ** 3 + 10 * m ** 2 + (26 / 3) * m)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-27"><a class="header" href="#solution-27">Solution</a></h1>
<hr />
<blockquote>
<p>669171001</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="distinct-powers"><a class="header" href="#distinct-powers"><a href="https://projecteuler.net/problem=29">Distinct powers</a></a></h1>
<blockquote>
<p>Consider all integer combinations of \( a^b \) for \( 2 ≤ a ≤ 5 \) and \( 2 ≤ b ≤ 5 \):</p>
<p>\[
\begin{align}
&amp;2^2=4, 2^3=8, 2^4=16, 2^5=32\\
&amp;3^2=9, 3^3=27, 3^4=81, 3^5=243\\
&amp;4^2=16, 4^3=64, 4^4=256, 4^5=1024\\
&amp;5^2=25, 5^3=125, 5^4=625, 5^5=3125\\
\end{align}
\]</p>
<p>If they are then placed in numerical order, with any repeats removed, we get the following sequence of \( 15 \) distinct terms:</p>
<p>\[
4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
\]</p>
<p>How many distinct terms are in the sequence generated by \( a^b \) for \( 2 ≤ a ≤ 100 \) and \( 2 ≤ b ≤ 100 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-28"><a class="header" href="#brute-force-28">Brute force</a></h1>
<p>Using
python's <a href="https://python-reference.readthedocs.io/en/latest/docs/comprehensions/set_comprehension.html">{} set comprehension</a>
we can create a set with all the terms generated by the sequence: \( a^b \).
Since a set discards duplicate elements, the solution is the length of that set.</p>
<pre><code class="language-python">def distinct_powers(n=100):
    return len({a ** b for a in range(2, n + 1) for b in range(2, n + 1)})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discarding-duplicate"><a class="header" href="#discarding-duplicate">Discarding duplicate</a></h1>
<p>We can actually solve this problem with pen and paper.</p>
<p>I won't explain the solution since <code>jorgbrown</code> has already done a great job in
his <a href="https://projecteuler.net/thread=29;page=3#6162">post</a>:</p>
<blockquote>
<p>Suppose \( a \) is a perfect square of the smaller \( a \), but not a
square of a square. Then we have a duplicate when \( b \) is \( 2, 3,
4\dots \) up to \( 50 \). That is, \( 49 \) duplicates.</p>
<p>Suppose \( a \) is a perfect cube of a smaller \( a \). When \( b \)
is \( 2 \) through \( 33 \), we have duplicates of smaller \( a \)
raised to the power \( b\times3 \). When \( b \) is \( 34, 36, 38, 40,
42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66 \), we have duplicates
of a smaller \( a \) raised to the power \( (\frac{b}{2})\times3 \).
Total is \( 32 + 17 \), or again, \( 49 \) duplicates.</p>
<p>Suppose \( a \) is the square of the square of a smaller \( a \). When
\( b \) is \( 2 \) through \( 49 \), we have duplicates of the square
root of a raised to the power \( (b\times2) \).<br />
When \( b \) is \( 51, 54, 57, 60, 63, 66, 69, 72, \) or \( 75, \) we
have dupes of \( a^{(\frac{3}{4})} \) raised to the power \( \frac
{b\times4} {3} \). Total is \( 49 + 9 \), or \( 58 \).</p>
<p>Suppose \( a \) is the fifth power of a smaller \( a \). We have dupes of
fifth root of a raised to the power \( (b\times5) \), which covers \( b \)
from \( 2 \) to \( 20 \). Then we have dupes of \( a^{(\frac{2}{5})} \)
raised to the power \( \frac{b\times5}{2} \), which covers \( b \) of
\( 22, 24, 26, 28, 30, 32, 34, 36, 38, 40 \). Then we have dupes of \(
a^{(\frac{3}{5})} \) raised to the power \( \frac{b\times5}{3} \), which
covers \( b \) of \( 21, 27, 33, 39, 42, 45, 48, 51, 54, 57, 60 \).
Last, we have dupes of \( a^\frac{4}{5} \) raised to the power \(
\frac{b\times5}{4} \), which covers \( b \) of \( 44, 52, 56, 64, 68, 72,
76\), and \( 80 \). Total dupes: \( 48 \).</p>
<p>And the last power we have to worry about is \( 6 \). We have dupes of the
square root of a raised to power \( (b\times2) \), which covers \( b \)
from \( 2 \) to \( 50 \). Then we have dupes of the sixth root to the power
\( \frac{b\times6}{4} \), which covers \( b \) of \( 52 \),
\( 54, 56, 58, 60, 62, 64, 66 \). And last we have dupes of the sixth
root to the power \( \frac{b\times6}{5} \), which covers \( b \) of \(
55,
65, 70, 75 \), and \( 80 \). Total dupes: \( 62 \).</p>
<p>Now let's put it all together:</p>
<p>squares: \( 4, 9, 25, 36, 49, 100 \): These \( 6 \) squares have \(
49 \) dupes each, \( 6 \times 49 \) = \( 294 \)</p>
<p>cubes: \( 8, 27 \): These \( 3 \) cubes have \( 49 \) duplicates
each: \( 2 \times 49 = 98 \)</p>
<p>4th power: \( 16, 81 \). These \( 2 \) have \( 58 \) dupes each: \( 2
\times 58 = 116 \)</p>
<p>5th power: \( 32 \). This has \( 48 \) dupes.</p>
<p>6th power: \( 64 \): this has \( 62 \) dupes.</p>
<p>Total # dupes: \( 618 \). \( 9801-618 \) is \( 9183 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-28"><a class="header" href="#solution-28">Solution</a></h1>
<hr />
<blockquote>
<p>9183</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="digit-fifth-powers"><a class="header" href="#digit-fifth-powers"><a href="https://projecteuler.net/problem=30">Digit fifth powers</a></a></h1>
<blockquote>
<p>Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:</p>
<p>\[
\begin{align}
1634 = 1^4 + 6^4 + 3^4 + 4^4\\
8208 = 8^4 + 2^4 + 0^4 + 8^4\\
9474 = 9^4 + 4^4 + 7^4 + 4^4
\end{align}
\]</p>
<p>As \( 1=1^{4} \) is not a sum it is not included.</p>
<p>The sum of these numbers is \( 1634+8208+9474=19316 \).</p>
<p>Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-29"><a class="header" href="#brute-force-29">Brute force</a></h1>
<p>Finding number that can be written as the sum of fifth powers of theirs digits
is easy. The main difficulty of this problem is to find an upper bound and thus
to know when to stop the iteration.</p>
<p>The sum of the fifth powers of a \( n \)-digits number will always be less
than or equal to \( n * 9^5 \). We need to find \( n \) such that \( n *
9^5 &lt; 10^n - 1 \) for all \( n \). The solution is actually very complex, but
with \( n = 5 \) we have \( 5 * 9^5 = 295245 &gt; 10^5 - 1 \) and with \( n =
6 \) we have \( 6 * 9^5 = 354294 &lt; 10^6 - 1 \). Which implies that it is
pointless to try any number with more than 6 digits.</p>
<pre><code class="language-python">def digit_fifth_powers():
    return sum((n for n in range(2, 999999)
                if sum(int(i) ** 5 for i in str(n)) == n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-unique-combination"><a class="header" href="#search-unique-combination">Search unique combination</a></h1>
<p>There is no need to try all numbers with at most 6 digits. What is really
important is to try all combinations of numbers with at most 6 digits. For
example, the sum of the fourth powers of digits of \( 1346 \) is the same as
the sum of \( 1634, 1436\dots \) But even if the sum is the same for \(
1356 \) and \( 1634 \), only \( 1634 \) has a sum equal to itself. So how
can we avoid calculating duplicate combinations but still find the solution ?</p>
<p>We need to build a list of these combinations, which is easily done with a
recursive function. The idea is to create the string so that the digits are
sorted. The stopping condition is the number of digits. Recursive functions are
a pain to understand, but if you print the result and the string after each
iteration, you should understand the function without too much trouble.</p>
<p>I used <code>yield</code> instead of building an entire list, but you can consider that
it's the same thing.</p>
<pre><code class="language-python">def build_combination(d, n=0, s=''):
    if d == 0:
        yield s
    else:
        for i in range(n, 10):
            for v in build_combination(d - 1, i, s + str(i)):
                yield v

</code></pre>
<p>The trick is to compute the sum a first time, for example, taking \( 1346 \)
which sum is equal to \( 1^5 + 3^5 + 4^5 + 6^5 = 1634 \). Then, repeat the
operation a second time \( 1^5 + 6^5 + 3^5 + 4^5 = 1634 \). If the total is
the same for both computations, then you have found one combination that works.</p>
<p>Instead of computing the fifth power of each digit, we can compute them once and
store them in a cache. The rest is just trying all the previously found
combinations. We need to remove <code>1</code> from the final result as the problem
indicates.</p>
<pre><code class="language-python">def digit_fifth_powers():
    cache = [i ** 5 for i in range(0, 10)]
    res = 0
    for n in build_combination(6):
        total = sum(cache[int(c)] for c in n)
        if sum(cache[int(c)] for c in str(total)) == total:
            res += total

    return res - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-29"><a class="header" href="#solution-29">Solution</a></h1>
<hr />
<blockquote>
<p>443839</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="coin-sums"><a class="header" href="#coin-sums"><a href="https://projecteuler.net/problem=31">Coin sums</a></a></h1>
<blockquote>
<p>In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:</p>
<p>\[
\begin{align}
1p,\ 2p,\ 5p,\ 10p,\ 20p,\ 50p,\ £1\ (100p),\ and £2\ (200p).
\end{align}
\]</p>
<p>It is possible to make £\( 2 \) in the following way:</p>
<p>\[
\begin{align}
1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p\end{align}
\]</p>
<p>How many different ways can £\( 2 \) be made using any number of coins?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-30"><a class="header" href="#brute-force-30">Brute force</a></h1>
<p>We are searching for all the combination to make 2 pounds using the eights
following coins in pence:</p>
<blockquote>
<p>1, 2, 5, 10, 20, 50, 100, 200.</p>
</blockquote>
<p>Combination implies that making 2 pounds with <code>100 + 50 + 50</code> pences is the same
as <code>50 + 100 + 50</code> pences. To avoid this, we will try every piece one by one in
increasing order.</p>
<p>The algorithm will use an accumulator that will increase with each iteration of
the function:</p>
<ol>
<li>If the accumulator reaches 200, a combination has been found.</li>
<li>If the accumulator is greater than 200 the current combination will not work.</li>
<li>If the accumulator is less than 200, add a new piece. To avoid duplicate
combinations, always add piece larger than or equal to the last one.</li>
</ol>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]

    def coin_sums_rec(accumulator, minimum_piece):
        if accumulator == n:
            return 1
        if accumulator &gt; n:
            return 0

        return sum(
            coin_sums_rec(accumulator + coins[new_piece], new_piece) for new_piece in range(minimum_piece, len(coins))
        )

    return coin_sums_rec(0, 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-3"><a class="header" href="#dynamic-programming-3">Dynamic programming</a></h1>
<p>The last solution does not scale to the number of parts or the target. We can do
better using dynamic programming, but first, we must divide the problem into
subproblems.</p>
<p>Let's start with the ways to do 1p using all the pieces we have. The table is a
cumulative sum, so the value of each cell is the number of ways to have the
target using the pieces up to the current one. We consider that there is only
one way to do 0p, so the first column is always 1.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
</tbody></table>
</div>
<p>This table means that there is only one way to express 1p, no matter what coins
we are using.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">2p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
</tbody></table>
</div>
<p>2p can be expressed using 1p: 1p + 1p, but also using 2p. With the other coins
the result remain the same.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">2p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center">3p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center">4p</td><td style="text-align: center">1</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center">5p</td><td style="text-align: center">1</td><td style="text-align: center">3</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td></tr>
</tbody></table>
</div>
<p>You might start to understand how this table was computed:</p>
<ul>
<li>The first column is always 1, there is only one way to express any target
with 1p.</li>
<li>The first row is always 1, there is only one way to express 0p.</li>
<li>For the rest we construct the table lines by lines, the current cells is the
sum of two possibilities:
<ul>
<li>The new coin is not used,</li>
<li>The new coin is not used: the number of ways to make \( n \) is the
number of way to make \(n - 1 \) using the same coins, which is the
value in the left cell.</li>
<li>If possible, the new coin is used: the number of ways to make \( n \) is
the number of ways to make \( n - c \) using the same coins, which is
the value in the cell on the same column but on the line \( n - c \).</li>
</ul>
</li>
</ul>
<p>For example with the last line, the first column is obviously 1
and the second is: 1 (left cell) + 2 (the number of ways to make \( 5p -
2p = 3p \), above cell).</p>
<p>So, using a cache table, we can drop the time complexity from \( O(m^n) \) to
\( O(nm) \), where \( n \) is the target and \( m \) the number of
coins. But we now have an \( O(nm) \) space complexity.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    cache = [[1] + [0] * (len(coins) - 1) for _ in range(n + 1)]

    for i in range(n + 1):
        for j in range(1, len(coins)):
            cache[i][j] = cache[i][j - 1]
            if coins[j] &lt;= i:
                cache[i][j] += cache[i - coins[j]][j]

    return cache[-1][-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="better-dynamic-programming"><a class="header" href="#better-dynamic-programming">Better dynamic programming</a></h1>
<p>Dynamic programming can be a bit improved by using a single array instead of a
table. The array will contain the number of ways to make \( n \) using the
coins we have. The array will be initialized with 1, and we will update it by
adding the number of ways to make \( n - c \) to the current value. This way
we will only need \( O(n) \) space. The time complexity will be the same
as the previous solution, but the space complexity will be better.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    cache = [1] + [0] * n

    for coin in coins:
        for i in range(coin, n + 1):
            cache[i] += cache[i - coin]

    return cache[-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-30"><a class="header" href="#solution-30">Solution</a></h1>
<hr />
<blockquote>
<p>73682</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pandigital-products"><a class="header" href="#pandigital-products"><a href="https://projecteuler.net/problem=32">Pandigital products</a></a></h1>
<blockquote>
<p>We shall say that an \( n \)-digit number is pandigital if it makes use of all the digits \( 1 \) to \( n \) exactly once; for example, the \( 5 \)-digit number, \( 15234 \), is \( 1 \) through \( 5 \) pandigital.</p>
<p>The product \( 7254 \) is unusual, as the identity, \( 39×186=7254 \), containing multiplicand, multiplier, and product is \( 1 \) through \( 9 \) pandigital.</p>
<p>Find the sum of all products whose multiplicand/multiplier/product identity can be written as a \( 1 \) through \( 9 \) pandigital.</p>
<p>HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-31"><a class="header" href="#brute-force-31">Brute force</a></h1>
<p>First, we need to know when the multiplicand/multiplier/product triplet is
pandigital. There are several ways to do this, probably the most obvious
being to convert the triplet to a single sorted string and compare it to
&quot;123456789&quot;.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0032/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_pandigital(multiplicand, multiplier, product):
    return sorted(str(multiplicand) + str(multiplier) + str(product)) == list(&quot;123456789&quot;)
</code></pre>
<p>One solution I really like uses a binary number to keep track of the digits.
This is faster than converting the triplet to a string and uses less memory
than a set or list. This method uses the bits as flags to check if a digit
is present. If one of the digits is used twice, the triplet is not
pandigital. If the final binary number is 0b1111111110, the triplet is
pandigital.</p>
<pre><code class="language-python">def is_pandigital3(multiplicand, multiplier, product):
    digits = 0
    for n in (multiplicand, multiplier, product):
        while n:
            if digits &amp; (1 &lt;&lt; (n % 10)):
                return False
            digits |= 1 &lt;&lt; (n % 10)
            n //= 10

    return digits == 0b1111111110
</code></pre>
<p>Next, we need to find all the possible multiplicand/multiplier/product
combinations. We can do this by brute force, trying all the possible
values for the multiplicand and multiplier from 1 to 987654321. But the
calculation will take too long.</p>
<p>We know that if the multiplier is 5 digits, then the result will be at least
5 digits, so the total number of digits will be at least 11 and therefore
not pandigital.</p>
<p>On the contrary, if the multiplier is 1 digit and the multiplicand 3 digits, the
result will be 4 digits and the total number of digits will be 8.</p>
<p>Trying different combinations of multiplicand and multiplier, we find that
only the following one result in a 9-digit triplet.</p>
<ul>
<li>2 digits * 3 digits = product of 4 or 5 digits</li>
<li>1 digit * 4 digits = product of 4 or 5 digits</li>
</ul>
<p>We can limit the search to these combinations. To avoid duplicates, we can
store the current pandigital products in a set and compute the sum at the end.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0032/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pandigital_products():
    products = set()
    for i in range(1, 100):
        for j in range(100 if i &gt; 9 else 1000, 10000 // i + 1):
            if is_pandigital3(i, j, i * j):
                products.add(i * j)

    return sum(products)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-31"><a class="header" href="#solution-31">Solution</a></h1>
<hr />
<blockquote>
<p>45228</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="digit-cancelling-fractions"><a class="header" href="#digit-cancelling-fractions"><a href="https://projecteuler.net/problem=33">Digit cancelling fractions</a></a></h1>
<blockquote>
<p>The fraction \( \frac{49}{98} \) is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that \( \frac{49}{98}=\frac{4}{8} \), which is correct, is obtained by cancelling the\(  9s \).</p>
<p>We shall consider fractions like, \( \frac{30}{50}=\frac{3}{5} \), to be trivial examples.</p>
<p>There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.</p>
<p>If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-32"><a class="header" href="#brute-force-32">Brute force</a></h1>
<p>The first step is to identify curious faction, such as \( \frac{49}{98} \).
A Curious faction can take one of four forms, which can be expressed as follows:</p>
<p>\[
\frac{ax}{bx} = \frac{a}{b} \Rightarrow \frac{10a + x}{10b + x} = \frac{a}{b} \Rightarrow 10ab + bx = 10ab + ax \Rightarrow x(a - b) = 0
\]</p>
<p>This implies that either \( x = 0 \) or \( a = b \). Both solutions are trivial.</p>
<p>\[
\frac{xa}{xb} = \frac{a}{b} \Rightarrow \frac{10x + a}{10x + b} = \frac{a}{b} \Rightarrow 10bc + ba = 10ax + ab \Rightarrow x(a - b) = 0
\]</p>
<p>This yields the same trivial solutions as the first case.</p>
<p>The only non-trivial solutions are of the form \( \frac{ax}{xb} \) or \( \frac{xa}{bx} \).
We simply need to determine whether we are dealing with the first or second case and verify whether the fractions are the same with and without \( x \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0033/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_curious_fraction(numerator, denominator):
    if numerator % 10 == denominator // 10:
        return abs((numerator / denominator) - (numerator // 10 / (denominator % 10))) &lt; 0.0000001
    elif numerator // 10 == denominator % 10:
        return abs((numerator / denominator) - (numerator % 10 / (denominator // 10))) &lt; 0.0000001
    return False
</code></pre>
<p>To ensure accuracy in the presence of floating-point values, the returned value must be compared to a small value to ensure it is close enough to zero.</p>
<p>The second step is to iterate over every fraction, with the numerator being smaller than the denominator, as all fractions must be smaller than 1.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0033/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def digit_cancelling_fractions():
    final_numerator, final_denominator = 1, 1
    for numerator in range(10, 100):
        for denominator in range(numerator + 1, 100):
            if numerator % 10 == 0 or denominator % 10 == 0:
                continue
            if is_curious_fraction(numerator, denominator):
                final_numerator *= numerator
                final_denominator *= denominator

    return final_denominator // gcd(final_numerator, final_denominator)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-32"><a class="header" href="#solution-32">Solution</a></h1>
<hr />
<blockquote>
<p>100</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="digit-factorials"><a class="header" href="#digit-factorials"><a href="https://projecteuler.net/problem=34">Digit factorials</a></a></h1>
<blockquote>
<p>\( 145 \) is a curious number, as \( 1!+4!+5!=1+24+120=145 \).</p>
<p>Find the sum of all numbers which are equal to the sum of the factorial of their digits.</p>
<p>Note: As \( 1!=1 \) and \( 2!=2 \) are not sums they are not included.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-33"><a class="header" href="#brute-force-33">Brute force</a></h1>
<p>To identify curious numbers, we first need to iterate over each digit of the number and calculate the factorial of each digit.
Then, we need to sum all the factorials and compare the result with the original number.
If the sum is equal to the original number, then we have found a curious number.</p>
<p>To speed up the process, we can precompute the factorials and iterate over all digits using Python's string.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0034/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_criterion(x):
    facts = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
    return x == sum(facts[int(i)] for i in str(x))
</code></pre>
<p>The next step is to iterate over all numbers and find curious numbers, but we need to find an upper bound.
If we take a number \( x \) with \( d \) digits, we have \( 10^{d-1} \leq x &lt; 10^d \).
If \( x \) is the equal to the sum of factorials of its digits, then with \( x_i \) being the ith digit of \( x \), we have \( x = \sum_{i=1}^d x_i! &lt; d * 9! \).</p>
<p>Thus, we have \( 10^{d-1} \leq x &lt; d * 9! \). With d=8, the equation is wrong. Therefore, our upper bound is \( 7 * 9!\).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0034/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def digit_factorials():
    return sum(i for i in range(3, 7 * 362880) if is_criterion(i))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-33"><a class="header" href="#solution-33">Solution</a></h1>
<hr />
<blockquote>
<p>40730</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="circular-primes"><a class="header" href="#circular-primes"><a href="https://projecteuler.net/problem=35">Circular primes</a></a></h1>
<blockquote>
<p>The number, \( 197 \), is called a circular prime because all rotations of the digits: \( 197 \), \( 971 \), and \( 719 \), are themselves prime.</p>
<p>There are thirteen such primes below \( 100 \): \( 2 \), \( 3 \), \( 5 \), \( 7 \), \( 11 \), \( 13 \), \( 17 \), \( 31 \), \( 37 \), \( 71 \), \( 73 \), \( 79 \), and \( 97 \).</p>
<p>How many circular primes are there below one million?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-34"><a class="header" href="#brute-force-34">Brute force</a></h1>
<p>Determining whether a number is a circular prime can be achieved by rotating the digits of the number with Python's string slicing functionality, followed by a check for primality.
Instead of a loop, we used the built-in function <a href="https://docs.python.org/fr/3/library/functions.html?highlight=all#all">all</a> to check whether all rotations of the number are prime.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0035/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_circular_prime(n):
    return all(isprime(int(n[i:] + n[:i])) for i in range(len(n)))
</code></pre>
<p>The solution is then a simple sum of all numbers below one million that are circular primes.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0035/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def circular_primes():
    return sum(is_circular_prime(str(i)) for i in range(2, 1000000))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-3-7-9"><a class="header" href="#1-3-7-9">1, 3, 7, 9</a></h1>
<p>It is possible to reduce the number of candidate numbers that need to be checked for circular primality by taking into account that prime numbers cannot end with the digits 0, 2, 4, 5, 6 or 8.
Therefore, numbers containing these digits can be skipped from consideration.</p>
<p>By using the <a href="https://docs.python.org/3/library/itertools.html#itertools.product">itertools.product</a>,
it is possible to generate all possible combinations of the digits 1, 3, 7 and 9.
This approach reduces the number of potential circular prime to less than 6,000,
rather than the previous 1,000,000.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0035/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def circular_primes():
    res = 4
    for number_digits in range(2, 7):
        for n in itertools.product(&quot;1379&quot;, repeat=number_digits):
            if is_circular_prime(&quot;&quot;.join(n)):
                res += 1
    return res
</code></pre>
<p>Although the current solution is effective, it's possible to further optimize the solution.
For instance, since we check all circular permutations of a given number, we may be checking the same number multiple times.
Additionally, we know that all prime numbers can be expressed as either \( 6n+1 \) or \( 6n-1 \).
However, implementing these optimizations may not be worthwhile.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-34"><a class="header" href="#solution-34">Solution</a></h1>
<hr />
<blockquote>
<p>55</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="double-base-palindromes"><a class="header" href="#double-base-palindromes"><a href="https://projecteuler.net/problem=36">Double-base palindromes</a></a></h1>
<blockquote>
<p>The decimal number, \( 585=10010010012 \) (binary), is palindromic in both bases.</p>
<p>Find the sum of all numbers, less than one million, which are palindromic in base \( 10 \) and base \( 2 \).</p>
<p>(Please note that the palindromic number, in either base, may not include leading zeros.)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-35"><a class="header" href="#brute-force-35">Brute force</a></h1>
<p>Detecting palindromes with Python's string slicing is easy.
We can use the same approach to detect palindromes in binary form.
Python's <a href="https://docs.python.org/3/library/functions.html#bin">bin</a> function returns the binary representation of an integer with a <code>0b</code> prefix.
If you remove this prefix, we can use the same function to check if the number is a palindrome in binary form.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0036/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_double_palindrome(n):
    is_palindrome = lambda s: s == s[::-1]
    return is_palindrome(str(n)) and is_palindrome(bin(n)[2:])
</code></pre>
<p>To find the solution, we can sum all the number below 1 million that are palindromes in both decimal and binary form. </p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0036/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def double_base_palindromes():
    return sum(n for n in range(1000000) if is_double_palindrome(n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-palindromes"><a class="header" href="#generating-palindromes">Generating palindromes</a></h1>
<p>The <a href="problems/problem_0036/./solution1.html">Brute force</a> solution iterates over all numbers and check if they are palindromes.
We can directly generate palindromes in decimal form and then check if they are palindromic in binary form.</p>
<p>Palindrome are of the form:</p>
<ul>
<li><code>abccba</code></li>
<li><code>abcba</code></li>
<li><code>abba</code></li>
<li><code>aba</code></li>
<li><code>aa</code></li>
<li><code>a</code></li>
</ul>
<p>To generate these, we can create the left half of the palindrome and then mirror it to get the full palindrome.
We just have to be careful with the even and odd cases, like <code>abba</code> and <code>aba</code>.</p>
<p>Because the palindromes limit is 1 million, the left part must be smaller than 1000.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0036/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def make_palindrome():
    left = 1
    while left &lt; 1000:
        yield int(str(left) + str(left)[::-1][1:])  # Odd length palindromes
        yield int(str(left) + str(left)[::-1])  # Even length palindromes
        left += 1
</code></pre>
<p>The final solution just need to check palindromes in their binary form.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0036/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def double_base_palindromes():
    return sum(n for n in make_palindrome() if is_bin_palindrome(n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-35"><a class="header" href="#solution-35">Solution</a></h1>
<hr />
<blockquote>
<p>872187</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="truncatable-primes"><a class="header" href="#truncatable-primes"><a href="https://projecteuler.net/problem=37">Truncatable primes</a></a></h1>
<blockquote>
<p>The number \( 3797 \) has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: \( 3797 \), \( 797 \), \( 97 \), and \( 7 \). Similarly we can work from right to left: \( 3797 \), \( 379 \), \( 37 \), and \( 3 \).</p>
<p>Find the sum of the only eleven primes that are both truncatable from left to right and right to left.</p>
<p>NOTE: \( 2 \), \( 3 \), \( 5 \), and \( 7 \) are not considered to be truncatable primes.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-36"><a class="header" href="#brute-force-36">Brute force</a></h1>
<p>To solve the problem of finding truncatable primes, we will use Python's slicing again to check whether the left and right slices of a number are prime.
Using the <a href="https://docs.python.org/3/library/functions.html#all">all</a> function, we can check both slices at once efficiently.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0037/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_truncatable_prime(n):
    return all(isprime(int(n[i:])) and isprime(int(n[:i])) for i in range(1, len(n)))
</code></pre>
<p>Since the problem states that there are only eleven primes, we don't need to set an upper bound for our iteration.
We can use <a href="https://docs.python.org/3/library/itertools.html#itertools.count">itertools.count</a> to make the code more concise.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0037/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def truncatable_primes():
    res = []
    for i in itertools.count(10):
        if isprime(i) and is_truncatable_prime(str(i)):
            res.append(i)
            if len(res) == 11:
                return sum(res)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="construct-them-all"><a class="header" href="#construct-them-all">Construct them all</a></h1>
<p>The <a href="problems/problem_0037/./solution1.html">Brute force</a> solution stops when the eleven primes are found.
This is not a very efficient solution. Instead, we can construct all the truncatable primes.</p>
<p>The first digit must be 2, 3, 5 or 7 because the left slice will leave that digit at the end.
For the same reason, the last digit must be 2, 3, 5 or 7.
Since our solution must have at least 2 digits, the last digit cannot end with 2 or 5, as the right slice will leave a multiple of 2 or 5 at the end.</p>
<p>So the first digit is either 2, 3, 5 or 7 and the last digit is either 3 or 7.</p>
<p>The process is recursive. We will append numbers to the right.
It is only possible to add 1, 3, 7 or 9 to the right. In this case we can use 1 or 9 because if it ends in the middle of a number, it won't be a single digit with left or right truncating.
Obviously, the number will not be a truncatable prime, but the next iterations might be.</p>
<p>If the number is not a prime, there is no point to continue the recursion.
Indeed, if we continue, the right-truncating will end on this number, which is not prime and thus not truncatable.
On the contrary, the recursion can be continued until the number is not prime.</p>
<p>By construction, the number is prime and right-truncatable.
As explained before, we need to check if it is left-truncatable only if the number ends with 3 or 7.
If so, we can add it to the list of truncatable primes.</p>
<p>We will use the keyword <a href="https://docs.python.org/3/reference/simple_stmts.html#yield">yield</a> and <a href="https://docs.python.org/3/reference/simple_stmts.html#yield">yield from</a> to return the results as we find them.
The <code>yield from</code> statement is similar to the <code>yield</code> statement, but it is used to return the results of a generator function.
In a nutshell, we just have to use the <a href="https://docs.python.org/3/library/functions.html#sum">sum</a> builtin on the returned values.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0037/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def construct_truncatable_primes(num):
    if isprime(num):
        if num &gt; 10 and num % 10 in (3, 7) and is_left_truncatable(str(num)):
            yield num
        for new_digit in (1, 3, 7, 9):
            yield from construct_truncatable_primes(num * 10 + new_digit)
</code></pre>
<p>The final solution is just the sum of all the constructed truncatable primes starting with 2, 3, 5 and 7.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0037/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def truncatable_primes():
    return sum(sum(construct_truncatable_primes(d)) for d in (2, 3, 5, 7))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-36"><a class="header" href="#solution-36">Solution</a></h1>
<hr />
<blockquote>
<p>748317</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pandigital-multiples"><a class="header" href="#pandigital-multiples"><a href="https://projecteuler.net/problem=38">Pandigital multiples</a></a></h1>
<blockquote>
<p>Take the number \( 192 \) and multiply it by each of \( 1 \), \( 2 \), and \( 3 \):</p>
<p>\[
\begin{align}
192 × 1 = 192\\
192 × 2 = 384\\
192 × 3 = 576\end{align}
\]</p>
<p>By concatenating each product we get the \( 1 \) to \( 9 \) pandigital, \( 192384576 \). We will call \( 192384576 \) the concatenated product of \( 192 \) and \(( 1 \),\( 2 \),\( 3 )\)</p>
<p>The same can be achieved by starting with \( 9 \) and multiplying by \( 1 \), \( 2 \), \( 3 \), \( 4 \), and \( 5 \), giving the pandigital, \( 918273645 \), which is the concatenated product of \( 9 \) and \(( 1 \),\( 2 \),\( 3 \),\( 4 \),\( 5 )\).</p>
<p>What is the largest \( 1 \) to \( 9 \) pandigital \( 9 \)-digit number that can be formed as the concatenated product of an integer with \(( 1 \),\( 2 \), \( ... \) , \( n )\) where \( n&gt;1 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-37"><a class="header" href="#brute-force-37">Brute force</a></h1>
<p>I choose to take one number as a seed, and detect if the product of this seed can form a pandigital number.
To do this, you multiply the seed number by increasing numbers until the resulting number is either greater than 9 digits or a pandigital number.
Python's string functions make it easy to concatenate numbers, and a set is used to check if a number is pandigital.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0038/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_pandigital_multiples(seed):
    digits = str(seed)
    for j in itertools.count(2):
        digits += str(seed * j)
        if len(digits) &gt; 9:
            return -1
        if len(digits) == 9 and set(digits) == set(&quot;123456789&quot;):
            return int(digits)
</code></pre>
<p>The maximum value for the seed is 10000 because if we multiply 10000 by 1 and 2 and concatenate the results, we get a 10-digit number, which cannot be pandigital.
The solution is then given by iterating over every seed and returning the maximum pandigital number found.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0038/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pandigital_multiples():
    return max(is_pandigital_multiples(seed) for seed in range(1, 10000))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="good-old-pen-and-paper"><a class="header" href="#good-old-pen-and-paper">Good old pen and paper</a></h1>
<p>As is often the case with Project Euler problems, the problem can be solved with pen and paper.</p>
<p>Before anything, know that \( [0-9] \) means any digit between \( 0 \) and \( 9 \).</p>
<p>We know that the number to beat is \( 918273645 \), so any solution we find must be greater than that number.
We also know that the first multiplier is \( 1 \), so the first digit of our seed must start with \( 9 \).
We can discard any number in the form \( 9[0-9], 9[0-9][0-9] \) or any number greater than \( 100000 \), because none of them will result in a 9-digit number when multiplied by (1, 2, 3) or (1, 2, 3, 4).</p>
<p>Therefore, the solution must be of the form \( 9[0-9][0-9][0-9] \).</p>
<p>The solution must contain different digits and no zeros, because of the *1 multiplier.
It can not contain any 1 at all because it will be present twice.
One with the *1 multiplier and another because the *2 multiplier will result with the number of the form \( 18[0-9][0-9] \).</p>
<p>Therefore, the solution must be of the form \( 9[2-9][2-9][2-9] \).</p>
<p>We can continue these eliminations rules:</p>
<p>\[
\begin{align}
&amp;9[5-9][2-9][2-9] * 2 = 19[0-9][0-9][0-9] \text{, the *1 multiplier already contains a 9.}\\
&amp;94[5-9][2-9] * 2 = 189[0-9][0-9] \text{, the *1 multiplier already contains a 9.}\\
&amp;94[2-4][2-9] * 2 = 188[0-9][0-9] \text{, the double 8 is obviously wrong.}\\
&amp;937[2-7] * 2 = 187[0-9][0-9] \text{, the *1 multiplier already contains a 7.}\\
&amp;936[2-7] * 2 = 18724, 18726, 18728, 18730, 18732 \text{ or } 18734 \text{. They always lack the number 5 except for 18730 which have the number 4.}\\
&amp;935[2-7] * 2 = 187[0-1][0-9] \text{, contains either a 0 or a double 1.}\\
&amp;934[2-7] * 2 = 186[8-9][0-9] \text{, contains either a 9 or a double 8.}\\
&amp;933[2-7]  \text{ is obviously wrong because of the double 3.}\\
&amp;932[2-6] * 2 = 1864, 1866, 1868, 1870 \text{ or } 1872 \text{. They always lack the number 5 except for 1870 which lack the number 4.}\\
\end{align}
\]</p>
<p>Thus, the number must be \( 9327 \). Indeed, \( 9327 + 18654 \) is the number we are looking for.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-37"><a class="header" href="#solution-37">Solution</a></h1>
<hr />
<blockquote>
<p>932718654</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-right-triangles"><a class="header" href="#integer-right-triangles"><a href="https://projecteuler.net/problem=39">Integer right triangles</a></a></h1>
<blockquote>
<p>If \( p \) is the perimeter of a right angle triangle with integral length sides, \( \{a,b,c\} \), there are exactly three solutions for \( p=120 \).</p>
<p>\( \{20,48,52\}, \{24,45,51\}, \{30,40,50\} \)</p>
<p>For which value of \( p \leq 1000 \), is the number of solutions maximised?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-38"><a class="header" href="#brute-force-38">Brute force</a></h1>
<p>The problem actually requires us to find <a href="https://en.wikipedia.org/wiki/Pythagorean_triple">Pythagorean triples</a> with a perimeter of \( p \) less than \( 1000 \).
To find the solution for this problem, we can try every possible combination of values for \( \{a,b,c\} \) for every \( p \) and check if \( p = a + b + c \) and \( a^2 + b^2 = c^2 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def count_pythagorean_triple(p):
    count = 0
    for a in range(1, p):
        for b in range(1, p):
            for c in range(1, p):
                if a + b + c == p and a * a + b * b == c * c:
                    count += 1
    return count
</code></pre>
<p>We want to find the maximum value returned by <code>count_right_triangles</code> but return the \( p \) that corresponds to that value.
We can use the Python <a href="https://docs.python.org/3/library/functions.html#max">max</a> builtin with key equal to our function to get the \( p \) that corresponds to the maximum value returned by <code>count_right_triangles</code>.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def integer_right_triangles():
    return max(range(1, 1001), key=count_pythagorean_triple)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fewer-loops-is-better"><a class="header" href="#fewer-loops-is-better">Fewer loops is better</a></h1>
<p>The <a href="problems/problem_0039/./solution1.html">Brute force</a> solution is too slow because it tries too many combinations.
We should try to reduce the number of possible combinations using the following observations:</p>
<ul>
<li>\( 0 &lt; a \leq b &lt; c \) because \( a \) and \( b \) are the shorter sides of the triangle. (1)</li>
<li>\( c = p - a - b \) because \( a + b + c \) is the perimeter of the triangle. (2)</li>
</ul>
<p>We can remove one loop thanks to (2), and reduces the number of possible combinations by half thanks to (1).
Furthermore, we do not need to check the condition \( p = a + b + c \) because we defined \( c \) using this equation.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def count_pythagorean_triple(p):
    count = 0
    for a in range(1, p):
        for b in range(1, a):
            c = p - a - b
            if a * a + b * b == c * c:
                count += 1
    return count
</code></pre>
<p>Using the equations \( a^2 + b^2 = c^2 \) and \( p = a + b + c \) we can deduct the following:</p>
<ul>
<li>If both \( a \) and \( b \) are even, \( c \) will be even, thus \( p \) will be even.</li>
<li>If both \( a \) and \( b \) are odd, \( c \) will be even, thus \( p \) will be even.</li>
<li>If one is even and the other is odd, \( c \) will be odd, thus \( p \) will be even.</li>
</ul>
<p>Therefore, we can reduce the number of possible combinations by only considering \( p \) that are even.
The solution to the problem is the maximum number of solutions for \( p \) below \( 1000 \).</p>
<p>The function will be the same as the last one, except that we will only iterate over even values of \( p \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def integer_right_triangles():
    return max(range(2, 1001, 2), key=count_pythagorean_triple)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-fewer-loops"><a class="header" href="#even-fewer-loops">Even fewer loops</a></h1>
<p>The <a href="problems/problem_0039/./solution2.html">Fewer loops is better</a> solution is still very slow.
However, we can make the solution faster by using the equations \( c = p - a - b \) and \( a^2 + b^2 = c^2 \) together.</p>
<p>We can rewrite \( a^2 + b^2 = c^2 \) as \( a^2 + b^2 = (p - a - b)^2 \) and simplify it to \( 2b(p - a) = p(p - 2a) \).</p>
<p>Using this equation, we have \( b = \frac{p(p - 2a)}{2(p - a)} \).
We can use this information to remove the loop for \( b \).</p>
<p>Furthermore, \( b \) must be a positive integer and since \( 2(p - a) \) is always positive, \( p - 2a \) must be positive as well.
It implies that \( a &lt; 500 \).</p>
<p>Finally, we can iterate over all values of \( a \) less than \( 500 \), and check whether \( p(p - 2a) \) is divisible by \( 2(p - a) \).
Summing the number of solutions will give us the number of pythagorean triples for a given \( p \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def count_pythagorean_triple(p):
    return sum(p * (p - 2 * a) % (2 * (p - a)) == 0 for a in range(1, p // 2))
</code></pre>
<p>The rest is the same as the previous solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def integer_right_triangles():
    return max(range(2, 1001, 2), key=count_pythagorean_triple)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-of-primitive-pythagorean-triples"><a class="header" href="#tree-of-primitive-pythagorean-triples">Tree of primitive Pythagorean triples</a></h1>
<p>The <a href="problems/problem_0039/./solution3.html">Even fewer loops</a> solution is already fast, but we can continue to improve it.
Indeed, Pythagorean triples are a generalization of a special case called <a href="https://en.wikipedia.org/wiki/Pythagorean_triple#Primitive_Pythagorean_triple">primitive Pythagorean triples</a>, where \( a \), \( b \) and \( c \) are coprime.
There exists multiple ways to generate them, such as the <a href="https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple">Euclid's formula</a>.</p>
<p>I prefer the <a href="https://en.wikipedia.org/wiki/Tree_of_primitive_Pythagorean_triples">Tree of primitive Pythagorean triples</a> method.
This method is based on the fact that all primitive Pythagorean triples has the structure of a tree.
We start with the root \( (3, 4, 5) \), which is the first primitive pythagorean triples, and then recursively generate the children of each node by multiplying it by a matrix \( A \), \( B \) or \( C \).</p>
<p>\( A \), \( B \) and \( C \) that are defined as:
\[
A = \begin{bmatrix}
1 &amp; -2 &amp; 2 \\
2 &amp; -1 &amp; 2 \\
2 &amp; -2 &amp; 3 \\
\end{bmatrix},
B = \begin{bmatrix}
1 &amp; 2 &amp; 2 \\
2 &amp; 1 &amp; 2 \\
2 &amp; 2 &amp; 3 \\
\end{bmatrix},
C = \begin{bmatrix}
-1 &amp; 2 &amp; 2 \\
-2 &amp; 1 &amp; 2 \\
-2 &amp; 2 &amp; 3 \\
\end{bmatrix}
\]</p>
<p>In our case we are also interested in the non-primitive Pythagorean triples.
To generate these triples, we can start with a primitive Pythagorean triple like \( a,b,c \) and multiply each value by a positive integer.
This will create a new triplet \( (k \times a, k \times b, k \times c) \) with perimeter \( p = k \times (a + b + c) \).
The limit of this multiplication factor \( k \) is restricted by \( p \) being less than \( 1000 \).</p>
<p>To put it all together, we can write a recursive function that will generate all the primitive Pythagorean triples with perimeter less than \( 1000 \).
From there, we can generate all the Pythagorean triples with perimeter less than \( 1000 \).
We will use <a href="https://numpy.org/">numpy</a> to represent the matrices and perform the multiplication.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution4.py">solution4.py</a>:</p>
<pre><code class="language-python">def compute_all_pythagorean_triples(results, max_p, abc):
    curr_p = sum(abc)
    if curr_p &lt; max_p:
        for perimeter in range(curr_p, max_p, curr_p):
            results[perimeter] += 1
        compute_all_pythagorean_triples(results, max_p, A @ abc)
        compute_all_pythagorean_triples(results, max_p, B @ abc)
        compute_all_pythagorean_triples(results, max_p, C @ abc)
</code></pre>
<p>Finally, we can count the number of solutions for each perimeter and return the one with the maximum number of solutions.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution4.py">solution4.py</a>:</p>
<pre><code class="language-python">def integer_right_triangles():
    results = defaultdict(int)
    compute_all_pythagorean_triples(results, 1001, np.array([3, 4, 5]))
    return max(results, key=results.get)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-38"><a class="header" href="#solution-38">Solution</a></h1>
<hr />
<blockquote>
<p>840</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="champernownes-constant"><a class="header" href="#champernownes-constant"><a href="https://projecteuler.net/problem=40">Champernowne's constant</a></a></h1>
<blockquote>
<p>An irrational decimal fraction is created by concatenating the positive integers:</p>
<p>\[
0.12345678910\color{red}{1}112131415161718192021...
\]</p>
<p>It can be seen that the \( 12 \)th digit of the fractional part is \( 1 \).</p>
<p>If \( d_n \) represents the nth digit of the fractional part, find the value of the following expression.</p>
<p>\[
d_{1} × d_{10} × d_{100} × d_{1000} × d_{10000} × d_{100000} × d_{1000000}
\]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-39"><a class="header" href="#brute-force-39">Brute force</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Champernowne_constant">Champernowne constant</a> is a number obtained by concatenating positive integers in decimal form.
The simplest way to solve this problem is to create a string with the required 1000000 digits and then extract the ones we need.</p>
<p>In Python, we can use the built-in <a href="https://docs.python.org/3/library/stdtypes.html#str.join">join</a> method to construct this string easily.
This function creates a string which is the concatenation of an iterable ; a range of integers in our case.</p>
<p>The final result is the product of the digits we need.
Combining the <a href="https://docs.python.org/3/library/functools.html#functools.reduce">reduce</a> function from the <a href="https://docs.python.org/3/library/functools.html">functools</a> module and the <a href="https://docs.python.org/3/library/functions.html#int">int</a> function with <a href="https://docs.python.org/3/library/operator.html#operator.mul">operator.mul</a>, we can get the product of a iterable of integers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0040/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def champernownes_constant():
    s = &quot;&quot;.join(str(i) for i in range(1, 1000000))
    print([int(s[10**i - 1]) for i in range(7)])
    return reduce(operator.mul, (int(s[10**i - 1]) for i in range(7)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreshadowing"><a class="header" href="#foreshadowing">Foreshadowing</a></h1>
<p>Although the <a href="problems/problem_0040/./solution1.html">Brute force</a> solution is fast, it will not scale well for larger values and is not an elegant solution.
To find a better solution, we need to understand how the champernowne constant is constructed.</p>
<p>For instance, a one-digit number (\(0...9\)) represents \( 9 \) digits in the string.
Meanwhile, a two-digit number (\(10...99\)) represents \( 180 \) digits in the string.
This is because there are \( 99 - 9 \) number between \( 10 \) and \( 99 \) with each two digits.
Thus, their concatenation results in \( 180 \) digits.</p>
<p>By examining the construction of the champernowne constant, we can find a pattern with \( d \) digits:</p>
<ul>
<li>\( d = 1 \): \( 1 \times (9 - 0) = 1 \times 9 = 9 \) digits</li>
<li>\( d = 2 \): \( 2 \times (99 - 9) = 2 \times 90 = 180 \) digits</li>
<li>\( d = 3 \): \( 3 \times (999 - 99) = 3 \times 900 = 2700 \) digits</li>
<li>\( d = 4 \): \( 4 \times (9999 - 999) = 4 \times 9000 = 36000 \) digits</li>
</ul>
<p>We can observ a clear pattern.
Specifically, for number with \( d \) digits, the number of digits of the concatenation is \( p(d) = 9d * 10^{d-1} \).</p>
<p>This patten allows us to divide the constant into chunks of digits that correspond to the concatenation of numbers with the same number of digits.
For instance:</p>
<ul>
<li>The first number with one digit starts at the \( 1^{th} \) digit of the champernowne constant.</li>
<li>The first number with two digits starts at the \( 1 + 9 = 10^{th} \) digit of the champernowne constant.</li>
<li>The first number with three digits start at the \( 1 + 9 + 180 = 190^{th} \) digit of the champernowne constant.</li>
</ul>
<p>To find the first number with \( d \) digits, we just need to sum the number of digits of all numbers with fewer digits.
We can define \( s(d) = 1 + \sum_{i=1}^{d-1} p(i) \) as the index of the first number with \( d \) digits in the champernowne constant.</p>
<p>Being able to find the first number with \( d \) digits is very useful.
Let's say we want to find \( d(1000) \), we know that \( s(3) = 190 \) and \( s(4) = 2890 \).
Thus, \( d(1000) \) is among the numbers with three digits.
The first number with three digits is at index \( 190 \), the second at index \( 190 + 3 \), the third at index \( 190 + 6 \) and so on.
To generalize, \( d(190 + 3k) \) is the first digit of the \( (100 + k)^{th} \) number.
We just need to find the greatest \( k \) such that \( 190 + 3k \leq 1001 \), which is \( k = 270 \).
So \( d(190 + 3 \times 270) = d(1000) \) is the first digit of \( 10^{d-1} + k = 100 + 270 = 370 \).
Hence \( d(1001) = 7 \).</p>
<p>In summary, to find \( d(n) \), we need to first search in which chunk of digits it lies.
This is achieved by finding the largest \( d \) such that \( s(d) \leq n \).
Next, we need to find the index of the number that contains \( d(n) \).
This is done by finding the largest \( k \) such that \( s(d) + d \times k \leq n \).
Finally, we can extract the \( (n - (s(d) + k \times d))^{th} \) digit from this number to obtain \( d(n) \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0040/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def d(n):
    s = lambda n: 1 + 9 * sum(i * 10 ** (i - 1) for i in range(1, n))
    digit = 1
    while s(digit) &lt;= n:
        digit += 1
    digit -= 1
    sd = s(digit)
    k = floor((n - sd) / digit)
    number = str(10 ** (digit - 1) + k)
    return int(number[n - (sd + k * digit)])
</code></pre>
<p>The final solution is obtained by multiplying the digit with the index of the problem.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0040/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def champernownes_constant():
    return reduce(operator.mul, (d(10**i) for i in range(7)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-39"><a class="header" href="#solution-39">Solution</a></h1>
<hr />
<blockquote>
<p>210</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pandigital-prime"><a class="header" href="#pandigital-prime"><a href="https://projecteuler.net/problem=41">Pandigital prime</a></a></h1>
<blockquote>
<p>We shall say that an \( n \)-digit number is pandigital if it makes use of all the digits \( 1 \) to \( n \) exactly once. For example, \( 2143 \) is a \( 4 \)-digit pandigital and is also prime.</p>
<p>What is the largest \( n \)-digit pandigital prime that exists?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-40"><a class="header" href="#brute-force-40">Brute force</a></h1>
<p>Based on the definition of a pandigital number, we can deduce that it cannot contain more than 9 digits.
Therefore, we can iterate through every permutation of the digits in decreasing order until we find a prime number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0041/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pandigital_prime():
    initial = &quot;987654321&quot;
    while True:
        for s in itertools.permutations(initial):
            n = int(&quot;&quot;.join(s))
            if isprime(n):
                return n
        initial = initial[1:]
</code></pre>
<p>Moreover, we can optimize the function slightly by taking into account that the sum of the digits in a 9-digit pandigital number is always 45, which makes it divisible by 3 and hence not prime.
The same applies to 8-digit pandigital numbers.
Therefore, we can skip these cases and start directly with 7-digit pandigital numbers.
However, the overall algorithm remains the same.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-40"><a class="header" href="#solution-40">Solution</a></h1>
<hr />
<blockquote>
<p>7652413</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="coded-triangle-numbers"><a class="header" href="#coded-triangle-numbers"><a href="https://projecteuler.net/problem=42">Coded triangle numbers</a></a></h1>
<blockquote>
<p>The n\( ^{th} \) term of the sequence of triangle numbers is given by, \( t_n=\frac{1}{2}n(n+1) \); so the first ten triangle numbers are:</p>
<p>\[
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
\]</p>
<p>By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is \( 19+11+25=55=t_{10} \). If the word value is a triangle number then we shall call the word a triangle word.</p>
<p>Using <a href="https://projecteuler.net/project/resources/p042_words.txt">words.txt</a> (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-41"><a class="header" href="#brute-force-41">Brute force</a></h1>
<p>The problem gave us a file with quoted words separated by commas.
The first step is to read the file and split the words into a list.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0042/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as f:
        return [word.strip('&quot;') for word in f.read().split(&quot;,&quot;)]
</code></pre>
<p>Subsequently, we need to check if the word is a triangle word.
A word is considered a triangle word if the sum of the alphabetical position of its letters is a triangle number.
A triangle number is defined by the formula \( \frac{1}{2}n(n+1) \), but we are interested in finding the \( n \) that satisfies this formula.
To solve it, we can use the equation:</p>
<p>\[
x = \frac{1}{2}n(n+1) \Rightarrow n^2 + n - 2x = 0 \Rightarrow n = \frac{\pm \sqrt{1 + 8x} - 1}{2}
\]</p>
<p>The negative solution \( \frac{- \sqrt{1 + 8x} - 1}{2} \) can be disregarded since we are only interested in positive integers.
We can determine if \( x \) is a triangle number by checking if the value of \( \frac{\sqrt{1 + 8x} - 1}{2} \) is an integer.
Which can be done easily using the <a href="https://docs.python.org/3/library/stdtypes.html#float.is_integer">is_integer</a> python function.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0042/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_triangle_number(x):
    return (((1 + 8 * x) ** 0.5 - 1) / 2).is_integer()
</code></pre>
<p>Finally, we can iterate over each word in the list, calculate its value, and verify if it is a triangle number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0042/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def coded_triangle_numbers():
    words = read_file(&quot;words.txt&quot;)
    return sum(is_triangle_number(sum(ord(c) - ord(&quot;A&quot;) + 1 for c in word)) for word in words)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-41"><a class="header" href="#solution-41">Solution</a></h1>
<hr />
<blockquote>
<p>162</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="sub-string-divisibility"><a class="header" href="#sub-string-divisibility"><a href="https://projecteuler.net/problem=43">Sub-string divisibility</a></a></h1>
<blockquote>
<p>The number, \( 1406357289 \), is a \( 0 \) to \( 9 \) pandigital number because it is made up of each of the digits \( 0 \) to \( 9 \) in some order, but it also has a rather interesting sub-string divisibility property.</p>
<p>Let \( d_1 \) be the \( 1^{st} \) digit, \( d_2 \) be the \( 2^{nd} \) digit, and so on. In this way, we note the following:</p>
<p>\[
\begin{align}
&amp;d_2d_3d_4=406\text{ is divisible by }2\\
&amp;d_3d_4d_5=063\text{ is divisible by }3\\
&amp;d_4d_5d_6=635\text{ is divisible by }5\\
&amp;d_5d_6d_7=357\text{ is divisible by }7\\
&amp;d_6d_7d_8=572\text{ is divisible by }11\\
&amp;d_7d_8d_9=728\text{ is divisible by }13\\
&amp;d_8d_9d_{10}=289\text{ is divisible by }17\\
\end{align}
\]</p>
<p>Find the sum of all \( 0 \) to \( 9 \) pandigital numbers with this property.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-42"><a class="header" href="#brute-force-42">Brute force</a></h1>
<p>The problem can be split into two parts:</p>
<ul>
<li>Check if the permutation satisfies the divisibility property.</li>
<li>Find all the permutations of the digits \( 0 \) to \( 9 \).</li>
</ul>
<p>The first part can be done by checking if a particular section of the number is divisible by the corresponding prime number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0043/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_sub_string_divisible(n):
    divisors = [2, 3, 5, 7, 11, 13, 17]
    return all(int(str(n)[i + 1 : i + 4]) % d == 0 for i, d in enumerate(divisors))
</code></pre>
<p>The second part is done by using the <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations">itertools.permutations</a> function.
With the caveat that any permutation starting with \( 0 \) should be disregarded.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0043/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sub_string_divisibility():
    res = 0
    for i in itertools.permutations(&quot;9876543210&quot;):
        if i[0] == &quot;0&quot;:
            continue
        x = int(&quot;&quot;.join(i))
        if is_sub_string_divisible(x):
            res += x
    return res
</code></pre>
<p>It is worth noting that if we encounter a permutation beginning with \( 0 \), we can immediately return the result without further iterations, as all other permutations will also start with \( 0 \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generation-over-iteration"><a class="header" href="#generation-over-iteration">Generation over iteration</a></h1>
<p>Rather than iterating over all permutations and verifying the divisibility property like the <a href="problems/problem_0043/./solution2.html">Brute force</a> method, a more efficient solution is to recursively generate permutations that satisfy the divisibility property.</p>
<p>The process begins with all pandigital permutations with 3 digits that are divisible by \( 2 \).
Then we can generate all the permutations with 4 digits that are divisible by \( 3 \) by appending the new digits at the end of the previous permutations.
We can continue this process until all permutations with 10 digits are generated.</p>
<p>Since the first digit is not important in the divisibility property, it is simpler to start from the end of the number.
Thus, we begin with the permutations that are divisible by \( 17 \) and continue adding the remaining digits at the beginning of the previous permutations.</p>
<p>Because the final number cannot start with \( 0 \), we can disregard the permutations that start with \( 0 \) in the final concatenation.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0043/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sub_string_divisibility():
    digits = &quot;0123456789&quot;
    items = [x + y for x in digits for y in digits if x != y]  # Permutations of 2 digits

    for d in [17, 13, 11, 7, 5, 3, 2]:
        items = [
            y + x for x in items for y in digits if int((y + x)[:3]) % d == 0 and y not in x
        ]  # Concatenation at the beginning

    items = [int(y + x) for x in items for y in digits[1:] if y not in x]  # Last concatenation

    return sum(items)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-pen-and-paper-1"><a class="header" href="#with-pen-and-paper-1">With pen and paper</a></h1>
<p>As often with these problems, it is possible to find the solution by hand.
The crucial aspect of these solutions is reducing the set of potential solutions.</p>
<p>The \( d_4d_5d_6 \) must be divisible by \( 5 \), thus \( d_6 \) must be \( 0 \) or \( 5 \).
If \( d_6 = 0 \), \( 0d_7d_8 \) must be divisible by \( 11 \), which implies that \( d_7 = d_8 \).
This is a contradiction since the number is pandigital, thus \( d_6 \) must be \( 5 \).</p>
<p>All the number \( 5d_7d_8 \) that can be divided by \( 17 \) are: \( 506, 517, 528, 539, 550, 561, 572, 583 \) and \( 594 \), but \( 550 \) is not pandigital.
Let us now check the number \( d_6d_7d_8 \) that are divisible by \( 13 \), with \( d_6d_7 \) being defined with the above solution:</p>
<ul>
<li>\( 06x \Rightarrow x = 5 \), but \( 5 \) is already used.</li>
<li>\( 17x \) has no solution.</li>
<li>\( 28x \Rightarrow x = 6\), gives \( 286 \) as a possible solution.</li>
<li>\( 39x \Rightarrow x = 0 \), gives \( 390 \) as a possible solution.</li>
<li>\( 61x \Rightarrow x = 1 \), but \( 1 \) is already used.</li>
<li>\( 72x \Rightarrow x = 8 \), gives \( 728 \) as a possible solution.</li>
<li>\( 83x \Rightarrow x = 2 \), gives \( 832 \) as a possible solution.</li>
<li>\( 94x \Rightarrow x = 9 \), but \( 9 \) is already used.</li>
</ul>
<p>The current only possible solution for \( d_6d_7d_8d_9 \) are \( 5286, 5390, 5728\text{ and }5832 \).</p>
<p>We can continue with the same process for the divisibility by \( 17 \):</p>
<ul>
<li>\( 86x \Rightarrow x = 7 \), gives \( 867 \) as a possible solution.</li>
<li>\( 90x \Rightarrow x = 1 \), gives \( 901 \) as a possible solution.</li>
<li>\( 28x \Rightarrow x = 9 \), gives \( 289 \) as a possible solution.</li>
<li>\( 32x \Rightarrow x = 3 \), but \( 3 \) is already used.</li>
</ul>
<p>The current only possible solution for \( d_6d_7d_8d_9d_{10} \) are \( 52867, 53901\text{ and }57289 \).</p>
<p>We can continue with the same process for the divisibility by \( 7 \):</p>
<ul>
<li>\( x52 \Rightarrow x = 2 \) or \( x = 9 \), but \( 2 \) is already used, gives \( 952 \) as a possible solution.</li>
<li>\( x53 \Rightarrow x = 5 \), but \( 5 \) is already used.</li>
<li>\( x57 \Rightarrow x = 3 \), gives \( 357 \) as a possible solution.</li>
</ul>
<p>The current only possible solution for \( d_5d_6d_7d_8d_9d_{10} \) are \( 952867, \text{ and }357289 \).</p>
<p>For \( d_2d_3d_4 \) to be divisible by \( 2 \), \( d_4 \) must be even, with the remaining possible digits being \( 0 \) or \( 4 \) for \( 952867 \) and \( 0, 4 \) or \( 6 \) for \( 357289 \).</p>
<p>Thus, the only possible solutions are for \( d_4d_5d_6d_7d_8d_9d_{10} \) are \( 0952867\), \( 4952867 \), \( 0357289 \), \( 4357289 \), and \( 6357289 \).</p>
<p>The last divisibility property requires \( d_3d_4d_5 \) to be divisible by \( 3 \), which implies that \( d_3 + d_4 + d_5 \) must be divisible by \( 3 \).
With the remaining digits, we can check all the possible solutions:</p>
<ul>
<li>\( x09 \Rightarrow x = 3 \), gives \( 309 \) as a possible solution.</li>
<li>\( x49 \) has no solution with the available digit \( 0 \), \( 1 \), or \( 3 \).</li>
<li>\( x03 \Rightarrow x = 6 \), gives \( 603 \) as a possible solution.</li>
<li>\( x43 \) has no solution with the available digit \( 0 \), \( 1 \), or \( 6 \).</li>
<li>\( x63 \Rightarrow x = 0 \), gives \( 063 \) as a possible solution. </li>
</ul>
<p>The current only possible solution for \( d_3d_4d_5d_6d_7d_8d_9d_{10} \) are \( 30952867 \), \( 60357289 \), and \( 06357289 \).
All permutations of these numbers with the remaining digits give a solution that satisfies the divisibility property.</p>
<p>The sum of all this numbers is the solution to the problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-42"><a class="header" href="#solution-42">Solution</a></h1>
<hr />
<blockquote>
<p>16695334890</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pentagon-numbers"><a class="header" href="#pentagon-numbers"><a href="https://projecteuler.net/problem=44">Pentagon numbers</a></a></h1>
<blockquote>
<p>Pentagonal numbers are generated by the formula, \( P_n=\frac{n(3n−1)}{2} \). The first ten pentagonal numbers are:</p>
<p>\[ 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ... \]</p>
<p>It can be seen that \( P_4 + P_7 = 22 + 70 = 92 = P_8 \). However, their difference, \( 70 − 22 = 48 \), is not pentagonal.</p>
<p>Find the pair of pentagonal numbers, \( P_j \) and \( P_k \), for which their sum and difference are pentagonal and \( D = |P_k − P_j| \) is minimised; what is the value of \( D \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-43"><a class="header" href="#brute-force-43">Brute force</a></h1>
<p>The problem can be decomposed into two distinct tasks:</p>
<ul>
<li>Verification whether a number is pentagonal or not.</li>
<li>Determination of the lower bound for the iteration through pentagonal pairs.</li>
</ul>
<p>The first task can be approached similarly to <a href="problems/problem_0044/../problem_0042/solution1.html">problem 42</a>, by using the equation \( x = \frac{1}{2}n(3n-1) \) and searching for \( n \).</p>
<p>\[
x = \frac{1}{2}n(3n-1) \Rightarrow 3n^2 - n - 2x = 0 \Rightarrow n = \frac{\pm \sqrt{1 + 24x} + 1}{6}
\]</p>
<p>Since we are only concerned with positive integers, the negative solution \( \frac{- \sqrt{1 + 24x} + 1}{6} \) can be disregarded.
There, a number is pentagonal if \( \frac{\sqrt{1 + 24x} + 1}{6} \) is an integer.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0044/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_pentagonal(n):
    return ((1 + (1 + 24 * n) ** 0.5) / 6).is_integer()
</code></pre>
<p>The second task is a bit more tricky since there is no obvious lower bound to terminates the iteration.
The only constraints is that that solution \( D \) must be minimal.
As the sequence of pentagonal numbers is strictly increasing, at some point, the difference between two successive numbers will exceed the current result.
Consequently, the iteration can be stopped, as all subsequent numbers will also surpass the current solution.</p>
<p>The difference between \( P_n \) and \( P_{n+1} \) is:
\[ P_{n+1} - P_n = \frac{1}{2}(n+1)(3(n+1)-1) - \frac{1}{2}n(3n-1) = 3n + 1 \]</p>
<p>Hence, the iteration should stop when \( 3n + 1 &gt; D \), which is finite assuming there is a solution.</p>
<p>The approach is to iterate through all pairs of pentagonal numbers \( P_i \) and \( P_j \) with \( j &lt; i \) and verify if both \( P_i + P_j \) and \( P_i - P_j \) are pentagonal.
If they are, we have found a solution, and the iteration continues until \( 3 * i + 1 &gt; D \), at which point the current result is the final solution.</p>
<p>To optimize the search, it is more efficient to iterate backwards through \( P_j \) since we are searching for the smallest \( D \) that satisfies the condition.
When \( P_i - P_j &gt; D \), the iteration through \( P_j \) can be stopped.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0044/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pentagon_numbers():
    res = float(&quot;inf&quot;)
    pn = lambda n: n * (3 * n - 1) // 2
    for i in itertools.count(2):
        if 3 * i + 1 &gt; res:
            break
        for j in range(i - 1, 0, -1):
            a = pn(i)
            b = pn(j)
            if a - b &gt; res:
                break
            if is_pentagonal(a + b) and is_pentagonal(a - b) and a - b &lt; res:
                res = a - b
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimal-iteration"><a class="header" href="#optimal-iteration">Optimal iteration</a></h1>
<p>The main reason the <a href="problems/problem_0044/./solution1.html">Brute force</a> approach is slow is that the iteration does not increase \( D \) monotonically.
For example, the previous solution tries the values of \( D \) in the following order: \( 4 \),\( 7 \),\( 11 \),\( 10 \),\( 17 \),\( 21 \),\( 13 \),\( 23 \),\( 30 \),\( 34 \),\( 16 \)...</p>
<p>Starting with the smallest possible value of \( D \) and increasing it until a solution is found is the optimal iteration approach, as it guarantees the solution with the minimal \( D \).
To implement it, we need to iterate through values of \( D \).
By definition \( D = P_d = P_i - P_j \) where \( j &lt; i \), it is necessary to determine a method for computing \( i \) and \( j \) from \( d \).</p>
<p>\[
\begin{aligned}
P_d &amp;= P_i - P_j\\
&amp;= P_{j+x} - P_{j}\\
&amp;= \frac{6jx +3x^2 - x}{2}\\
&amp;= 3jx + P_x\\
&amp;\Rightarrow j = \frac{P_d - P_x}{3x}\\
\end{aligned}
\]</p>
<p>The following can be concluded from the above equation:</p>
<ul>
<li>\( j \) must be an integer, so \( P_d &gt; P_x \), thus \( 0 &lt; x &lt; d \) and \( P_d - P_x \equiv 0 \pmod{3x} \).</li>
<li>\( P_d - P_x = 3(d^2 - x^2) + d - x \Rightarrow x \equiv d \pmod{3} \).</li>
</ul>
<p>Therefore, we can iterate over every \( d \) and \( x \) such that \( 0 &lt; x &lt; d \) and \( x \equiv d \pmod{3} \).
If \( P_d - P_x \equiv 0 \pmod{3x} \), then we can compute \( j \) and \( i = x + j \).
By definition, \( P_d \) is pentagonal, so if \( P_i + P_j \) is also pentagonal, then \( D = P_d \) is the solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0044/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def pentagon_numbers():
    for d in itertools.count(4):
        pd = pn(d)
        for x in range(d - 3, 0, -3):
            px = pn(x)
            if (pd - px) % (3 * x) == 0:
                j = (pd - px) // (3 * x)
                k = x + j
                if is_pentagonal(pn(k) + pn(j)):
                    return pd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-better-iteration"><a class="header" href="#even-better-iteration">Even better iteration</a></h1>
<p>The <a href="problems/problem_0044/./solution2.html">Optimal iteration</a> approach is much faster than the <a href="problems/problem_0044/./solution1.html">Brute force</a> approach.
However, for large value of \( d \) the iteration through all the possible \( x \) is still slow.
Let's try to add more constraints to reduce the numbers of possibility.</p>
<p>The last solution gave the following equation:</p>
<p>\[
\begin{aligned}
P_d &amp; = P_i - P_j\\
\Leftrightarrow d(3d - 1) &amp;= i(3i - 1) - j(3j - 1) \\
&amp;= (i - j)(3(i + j) - 1) \\
\end{aligned}
\]</p>
<p>The following can be concluded from the above equation:</p>
<ul>
<li>\( i - j \equiv 0 \pmod{d(3d + 1)} \).</li>
<li>Since \( i \), \( j \), and \( d \) are positive integers, it follows that \( 0 &lt; i - j &lt; d \) because if \( d &lt; i - j \), then \( 3d - 1 &lt; 3(i - j) - 1 &lt; 3(i + j) - 1 \) which implies that \( d(3d - 1) &lt; (i - j)(3i - 3i - 1) \) because \(d, i, j \), a contradiction.</li>
<li>\( i - j \equiv d \pmod{3} \) because \( 3d - 1 \equiv 3(i + j) - 1 \equiv 2 \pmod{3} \).</li>
</ul>
<p>To summarize, we are searching for all \( i \) and \( j \) that satisfy:
\[
\begin{align}
&amp;i\text{ and }j\text{ are positive integers.} \tag{0}\\
&amp;0 &lt; i - j &lt; d \tag{1}\\
&amp;i - j \equiv d \pmod{3} \tag{2}\\
&amp;3(i + j) - 1 \equiv 2 \pmod{3} \tag{3}\\
&amp;i - j \equiv 0 \pmod{d(3d + 1)} \tag{4}\\
\end{align}
\]</p>
<p>The solution can be found by iterating through all values of \( d \) and find all divisors \( r_1 = i - j \) that satisfy equation \( 3 \) and \( 4 \).</p>
<p>If \( i = \frac{r_1 + \frac{(r_2 + 1)}{3}}{2} \) is an integer (equation 0), then \( j = i - r_1 \).
If both \( P_i \) and \( P_j \) are pentagonal numbers, then the solution is \( P_d \).</p>
<p>It is important to know that this approach is not as efficient as the previous one for small values of \( d \), but it is significantly faster for large values of \( d \), especially if the function for obtaining all the divisors of \( d(3d + 1) \) is optimized.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0044/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def pentagon_numbers():
    pn = lambda n: n * (3 * n - 1) // 2
    for d in itertools.count(4):
        for r1 in get_divisors(d):  # Equation 4
            r2 = d * (3 * d - 1) // r1
            if r2 % 3 == 2:  # Equation 3
                i = (r1 + (r2 + 1) // 3) / 2
                if i.is_integer():  # Equation 0
                    j = i - r1
                    if is_pentagonal(pn(i) + pn(j)):
                        return pn(d)
</code></pre>
<p>It is also worth noting that the pandigital number could be cached, as many of them are computed multiple times.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-43"><a class="header" href="#solution-43">Solution</a></h1>
<hr />
<blockquote>
<p>5482660</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="triangular-pentagonal-and-hexagonal"><a class="header" href="#triangular-pentagonal-and-hexagonal"><a href="https://projecteuler.net/problem=45">Triangular, pentagonal, and hexagonal</a></a></h1>
<blockquote>
<p>Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:</p>
<p>\[
\begin{align*}
&amp;\text{Triangle }&amp;&amp;Tn=\frac{n(n+1)}{2} &amp;&amp;1, 3, 6, 10, 15, ...\\
&amp;\text{Pentagonal }&amp;&amp;Pn=\frac{n(3n−1)}{2} &amp;&amp; 1, 5, 12, 22, 35, ...\\
&amp;\text{Hexagonal }&amp;&amp;Hn=n(2n−1) &amp;&amp;1, 6, 15, 28, 45, ...\\
\end{align*}
\]
It can be verified that \( T_{285} = P_{165} = H_{143} = 40755 \).</p>
<p>Find the next triangle number that is also pentagonal and hexagonal.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-44"><a class="header" href="#brute-force-44">Brute force</a></h1>
<p>The brute force approach for solving this problem is straightforward.
To start, a function is needed to compute \( T_n \), \( P_n \) and \( H_n \) for a given \( n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def tn(n):
    return n * (n + 1) // 2
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pn(n):
    return n * (3 * n - 1) // 2
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def hn(n):
    return n * (2 * n - 1)
</code></pre>
<p>Then, a while loop can be implemented to iterate until all three numbers are equal.
At each iteration, only update one of the two smallest value among \( T_n \), \( P_n \) and \( H_n \).
This is because \( T_n \), \( P_n \) and \( H_n \) are all increasing functions of \( n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def triangular_pentagonal_and_hexagonal():
    t, p, h = 286, 166, 144
    ti, pi, hi = tn(t), pn(p), hn(h)
    while not (ti == pi == hi):
        if ti &lt; pi:
            t += 1
            ti = tn(t)
        elif pi &lt; hi:
            p += 1
            pi = pn(p)
        else:
            h += 1
            hi = hn(h)
    return ti
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="triangular-numbers-are-useless"><a class="header" href="#triangular-numbers-are-useless">Triangular numbers are useless</a></h1>
<p>Let's start by observing the first ten Triangular, pentagonal, and hexagonal numbers:</p>
<ul>
<li>Triangular: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...</li>
<li>Pentagonal: 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...</li>
<li>Hexagonal: 1, 6, 15, 28, 45, 66, 91, 120, 153, 190, ...</li>
</ul>
<p>It appears that every Hexagonal number is also a Triangular number, specifically \( H_n = T_{2n - 1} \).
This relationship is true because \( T_{2n - 1} = \frac{(2n - 1)(2n)}{2} = H_n \).
Since every Hexagonal number is also a Triangular number, it's pointless to compute Triangular numbers.
Therefore, it is sufficient to iterate through every Hexagonal number and verify if it is also a Pentagonal number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def is_pentagonal(n):
    return ((1 + (1 + 24 * n) ** 0.5) / 6).is_integer()
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def triangular_pentagonal_and_hexagonal():
    h = 145
    while not is_pentagonal(hn(h)):
        h += 1
    return hn(h)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diophantine-equations"><a class="header" href="#diophantine-equations">Diophantine equations</a></h1>
<p>The <a href="problems/problem_0045/./solution2.html">Triangular numbers are useless</a> approach exploits the fact that Triangular numbers are useless.
Thus, it is sufficient to find \( H_n = T_n \Leftrightarrow 3n^2 - n + 4m^2 - 4m = 0 \).
This is known as a <a href="https://en.wikipedia.org/wiki/Diophantine_equation">Diophantine equation</a>.
This problem is very hard to solve in general, so we will use this <a href="https://www.alpertron.com.ar/QUAD.HTM">solver</a> to find the solution.</p>
<p>It gives the following recurrence relation:</p>
<p>\[ 
x_{n + 1} = 97x_n + 112y_n - 44\\
y_{n + 1} = 84x_n + 97y_n - 38
\]</p>
<p>Starting with the solution \( (n, m) = (1, 1) \), we can easily find the third solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def triangular_pentagonal_and_hexagonal():
    x_n = lambda x_i, y_i: 97 * x_i + 112 * y_i - 44
    y_n = lambda x_i, y_i: 84 * x_i + 97 * y_i - 38

    x, y = 1, 1
    x, y = x_n(x, y), y_n(x, y)
    y = y_n(x, y)
    return y * (2 * y - 1)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-44"><a class="header" href="#solution-44">Solution</a></h1>
<hr />
<blockquote>
<p>1533776805</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="goldbachs-other-conjecture"><a class="header" href="#goldbachs-other-conjecture"><a href="https://projecteuler.net/problem=46">Goldbach's other conjecture</a></a></h1>
<blockquote>
<p>It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.</p>
<p>\[
9 = 7 + 2×1^{2}\\\\
15 = 7 + 2×2^{2}\\\\
21 = 3 + 2×3^{2}\\\\
25 = 7 + 2×3^{2}\\\\
27 = 19 + 2×2^{2}\\\\
33 = 31 + 2×1^{2}
\]</p>
<p>It turns out that the conjecture was false.</p>
<p>What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-45"><a class="header" href="#brute-force-45">Brute force</a></h1>
<p>The brute force approach for determining the minimal odd composite number that does not satisfy the Goldbach's other conjecture can be separated into two steps:</p>
<ul>
<li>Verify whether a number satisfies the Goldbach's other conjecture.</li>
<li>Iterate through all odd composite numbers.</li>
</ul>
<p>The first step can be brute force by iterating through every \( i \leq n \) and verify if \( i \) is prime and \( \sqrt{\frac{n-i}{2}} \) is an integer.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0046/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_odd_goldbach(n):
    return any(isprime(i) and (((n - i) / 2) ** 0.5).is_integer() for i in range(1, n + 1))
</code></pre>
<p>Assuming the existence of a solution, the second part is straightforward and can be done by iterating through all odd composite numbers until a solution is found.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0046/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def goldbachs_other_conjecture():
    for i in itertools.count(7, 2):
        if not is_odd_goldbach(i):
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="better-iteration-and-caching"><a class="header" href="#better-iteration-and-caching">Better iteration and caching</a></h1>
<p>The <a href="problems/problem_0046/./solution1.html">Brute force</a> approach is fast enough because the solution is small.
But the function that determines whether a number satisfies the Goldbach's other conjecture can be further optimized.</p>
<p>The key is to iterate through all double squares \( 2i^2 \) with \( i \leq \sqrt{\frac{n}{2}} \) and check whether \(n - 2i^2 \) is prime.
Additionally, a cache of prime numbers can be used and updated when a new prime number is found.
New primes can only be found if \( n \) is prime, because \( n - 2i^2 \) prime implies that a previous composite number was prime.
Thus, the cache is updated if \( n \) is prime, if not, it can be used to determine whether \( n - 2i^2 \) is prime.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0046/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def is_odd_goldbach(n, primes_cache):
    if isprime(n):
        primes_cache.add(n)
        return True

    return any(n - 2 * i**2 in primes_cache for i in range(1, int(n**0.5) + 1))
</code></pre>
<p>The rest stays the same.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0046/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def goldbachs_other_conjecture():
    primes_cache = {2, 3, 5}
    for i in itertools.count(7, 2):
        if not is_odd_goldbach(i, primes_cache):
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-45"><a class="header" href="#solution-45">Solution</a></h1>
<hr />
<blockquote>
<p>5777</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="distinct-primes-factors"><a class="header" href="#distinct-primes-factors"><a href="https://projecteuler.net/problem=47">Distinct primes factors</a></a></h1>
<blockquote>
<p>The first two consecutive numbers to have two distinct prime factors are:</p>
<p>\[
14 = 2 × 7\\\\
15 = 3 × 5
\]</p>
<p>The first three consecutive numbers to have three distinct prime factors are:</p>
<p>\[
\begin{align}
644 &amp;= 2^2 × 7 × 23\\
645 &amp;= 3 × 5 × 43\\
646 &amp;= 2 × 17 × 19.
\end{align}
\]</p>
<p>Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-46"><a class="header" href="#brute-force-46">Brute force</a></h1>
<p>To find the first four consecutive integers that possess four distinct prime factors each using a brute force approach can be separated into two steps:</p>
<ul>
<li>Find the prime decomposition of a number.</li>
<li>Iterate over all numbers and check if the next four numbers have four distinct prime factors each.</li>
</ul>
<p>The prime decomposition has previously been implemented in other problems and, therefore, is not an important component for this approach.
To solve this part, the <a href="https://docs.sympy.org/latest/modules/ntheory.html#sympy.ntheory.factor_.primefactors">sympy.primefactors</a> function can be used.</p>
<p>The iteration process is straightforward, and the number of distinct primes can be determined using the length of the set of the prime decomposition.
To identify the solution, check the next four numbers that have four distinct prime factors each, and return the first number that satisfies this condition.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0047/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def distinct_primes_factors():
    for i in itertools.count(5):
        if (
            len(set(primefactors(i)))
            == len(set(primefactors(i + 1)))
            == len(set(primefactors(i + 2)))
            == len(set(primefactors(i + 3)))
            == 4
        ):
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cache-is-life"><a class="header" href="#cache-is-life">Cache is life</a></h1>
<p>A clear strategy to enhance the <a href="problems/problem_0047/./solution1.html">Brute force</a> approach is to cache some results.
At each iteration, only the prime decomposition of the current number needs to be computed.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0047/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def distinct_primes_factors():
    cache = [False] * 4
    for i in itertools.count(1):
        cache[i % 4] = len(set(primefactors(i))) == 4
        if all(cache):
            return i - 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="good-old-sieve"><a class="header" href="#good-old-sieve">Good old Sieve</a></h1>
<p>The <a href="problems/problem_0047/./solution2.html">Cache is life</a> approach involves computing the prime decomposition of each number, which is a costly operation that can be avoided using a sieve.
The downside of this approach is that the sieve requires an arbitrary limit, but it can be increased until the solution is found.
Instead of determining which number are primes, the sieve stores the number of distinct prime factors for each number.</p>
<p>The <a href="https://docs.sympy.org/latest/modules/ntheory.html#sympy.ntheory.factor_.primefactors">sympy.primefactors</a> function combined multiples algorithm, making its exact complexity difficult to determine.
Nevertheless, it is expected to be no more than \( O(sqrt{n}) \), resulting in a previous approach of \( O(n\sqrt{n}) \).</p>
<p>The Sieve of Eratosthenes complexity is \( O(n\log\log{n}) \), which is better than the previous approach.
In practive, \( \log\log{n} \) is very small and can be disregarded for simplicity, resulting in a complexity of \( O(n) \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0047/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def factors_sieves(n):
    factors = [0] * (n + 1)
    consecutive = 0
    for i in range(2, n + 1):
        if factors[i] == 0:
            for j in range(2, int(n / i)):
                factors[i * j] += 1
            consecutive = 0
        elif factors[i] == 4:
            consecutive += 1
        else:
            consecutive = 0

        if consecutive == 4:
            return i - 3
    return None
</code></pre>
<p>To find the final solution, one can arbitrarily choose a limit and attempt to find a solution.
If no solution is found, the limit can be multiplied by two, and the process can be repeated.
The complexity of this operation is \( O(1 + 2 + 4 + 8 ... + n) \) which is equal to \( O(2n) \) and equivalent to \( O(n) \).</p>
<p>In theory, this approach should be faster than the previous one, but in practice, it may not be faster for small limits.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0047/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def distinct_primes_factors():
    for i in itertools.count(1):
        res = factors_sieves(2**i)
        if res is not None:
            return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-46"><a class="header" href="#solution-46">Solution</a></h1>
<hr />
<blockquote>
<p>134043</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-powers"><a class="header" href="#self-powers"><a href="https://projecteuler.net/problem=48">Self powers</a></a></h1>
<blockquote>
<p>The series, \( 1^{1}+2^{2}+3^{3}+...+10^{10}=10405071317 \).</p>
<p>Find the last ten digits of the series, \( 1^{1}+2^{2}+3^{3}+...+1000^{1000} \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-47"><a class="header" href="#brute-force-47">Brute force</a></h1>
<p>The naive approach consists of computing the sum of the series and then take the last 10 digits.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0048/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def self_powers():
    return sum(i**i for i in range(1, 1001)) % 10**10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modulus-reduction"><a class="header" href="#modulus-reduction">Modulus reduction</a></h1>
<p>The <a href="problems/problem_0048/./solution1.html">Brute force</a> approach only works thanks to Python's infinite precision integers.
In other languages, the result of \( 1000^{1000} \) is too large to be stored in an integer.</p>
<p>Thus, the need of a <a href="https://en.wikipedia.org/wiki/Modular_exponentiation#Direct_method">modulus exponentiation</a> algorithm, which exploits the property that \(a \times b \pmod{m} = [(a \pmod{m}) \times (b \pmod{m})] \pmod{m} \) for any \( m \).
Although modulus exponentiation may involve more multiplications than exponentiation followed by modulus, because optimized exponentiation algorithms are better than \( O(n) \).
In modulus exponentiation the base is always bound by \( m \), leading to smaller exponentiation and faster computation overall.
Consequently, this method reduce both the memory usage, which make it suitable for other languages, and the computation time.</p>
<p>The use of <a href="https://docs.python.org/3/library/functools.html#functools.reduce">functools.reduce</a> eliminates the need for a loop and is a more efficient and elegant solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0048/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def mod_pow(b, e, mod):
    return reduce(lambda acc, _: (acc * b) % mod, range(e), 1)
</code></pre>
<p>Similarly, the cumulative sum can also be computed using <a href="https://docs.python.org/3/library/functools.html#functools.reduce">functools.reduce</a>.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0048/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def self_powers():
    mod = 10**10
    sums = (mod_pow(i, i, mod) for i in range(1, 1001))
    return reduce(lambda acc, y: (acc + y) % mod, sums)
</code></pre>
<p>It is worth mentioning that there exists many optimized techniques for <a href="https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method">modular exponentiation</a> which can be implemented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-47"><a class="header" href="#solution-47">Solution</a></h1>
<hr />
<blockquote>
<p>9110846700</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-permutations"><a class="header" href="#prime-permutations"><a href="https://projecteuler.net/problem=49">Prime permutations</a></a></h1>
<blockquote>
<p>The arithmetic sequence, \( 1487 \), \( 4817 \), \( 8147 \), in which each of the terms increases by \( 3330 \), is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the \( 4 \)-digit numbers are permutations of one another.</p>
<p>There are no arithmetic sequences made up of three \( 1 \)-, \( 2 \)-, or \( 3 \)-digit primes, exhibiting this property, but there is one other \( 4 \)-digit increasing sequence.</p>
<p>What \( 12 \)-digit number do you form by concatenating the three terms in this sequence?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-48"><a class="header" href="#brute-force-48">Brute force</a></h1>
<p>The brute force approach iterates over all four-digit numbers, \( i \), and all numbers \( j \) until \( i \), \( i + j \) and \( i + 2j \) are primes and permutations of each other.
The requirement for the four-digit numbers implies that \(1000 \leq i &lt; 10000 \) and \( i + 2j &lt; 10000 \Rightarrow j &lt; \frac{10000 - i}{2} \).</p>
<p>The permutations condition can be verified by sorting the digits of each number and comparing the sorted strings.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0049/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def prime_permutations():
    for i in range(1000, 10000):
        if i == 1487:
            continue
        for j in range(1, (10000 - i) // 2):
            if (
                isprime(i)
                and isprime(i + j)
                and isprime(i + 2 * j)
                and sorted(str(i)) == sorted(str(i + j)) == sorted(str(i + 2 * j))
            ):
                return str(i) + str(i + j) + str(i + 2 * j)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primes-permutations"><a class="header" href="#primes-permutations">Primes permutations</a></h1>
<p>An improvement to the <a href="problems/problem_0049/./solution1.html">Brute force</a> approach can be made by avoiding the iterations over all numbers.
The most restrictive requirements of the problem are that the solution must be four-digit and prime.
Fortunately, meeting this condition is really simple as generating the Sieve of Eratosthenes between \( 1000 \) and \( 10000 \) gives a list of all four-digit primes.</p>
<p>The remaining conditions require that the three numbers must be permutations of each other and in arithmetic progression.
However, it's difficult to determine all primes that are in arithmetic progression efficiently.
As a result, it is better to focus on the permutation requirement.
By grouping all primes based on their sorted digits results in lists of four-digit primes with the same permutations.</p>
<p>Finally, the arithmetic constraint can be verified by iterating through each group to find \( p_1 \), \( p_2 \), and \( p_3 \) such that \( p_3 = 2p_2 - p_1 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0049/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def prime_permutations():
    primes = list(sieve.primerange(1000, 10000))
    primes_permutations = defaultdict(list)
    for prime in primes:
        primes_permutations[&quot;&quot;.join(sorted(str(prime)))].append(prime)

    for perm in primes_permutations.values():
        if len(perm) &lt; 3 or perm[0] == 1487:
            continue

        for i, p1 in enumerate(perm):
            for p2 in perm[i + 1 :]:
                p3 = 2 * p2 - p1
                if p3 in perm:
                    return str(p1) + str(p2) + str(p3)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-48"><a class="header" href="#solution-48">Solution</a></h1>
<hr />
<blockquote>
<p>296962999629</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="consecutive-prime-sum"><a class="header" href="#consecutive-prime-sum"><a href="https://projecteuler.net/problem=50">Consecutive prime sum</a></a></h1>
<blockquote>
<p>The prime \( 41 \), can be written as the sum of six consecutive primes:</p>
<p>\[
41 = 2 + 3 + 5 + 7 + 11 + 13
\]</p>
<p>This is the longest sum of consecutive primes that adds to a prime below one-hundred.</p>
<p>The longest sum of consecutive primes below one-thousand that adds to a prime, contains \( 21 \) terms, and is equal to \( 953 \).</p>
<p>Which prime, below one-million, can be written as the sum of the most consecutive primes?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-49"><a class="header" href="#brute-force-49">Brute force</a></h1>
<p>To solve the problem of finding the prime number below one million that can be expressed as the longest sum of consecutive primes, the first idea is to generate all the primes below one million.
Subsequently, brute-forcing all possible combinations of consecutive primes can be evaluated to identify the longest sequence whose sum is also a prime.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0050/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def consecutive_prime_sum(lim=10**6):
    primes = list(sieve.primerange(2, lim))
    res = 0
    max_len = 0
    for i in range(len(primes)):
        for j in range(i + max_len, len(primes)):
            s = sum(primes[i:j])
            if s &gt;= lim:
                break
            if j - i &gt; max_len and s in primes:
                max_len = j - i
                res = s
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cumulative-sum"><a class="header" href="#cumulative-sum">Cumulative sum</a></h1>
<p>The <a href="problems/problem_0050/./solution1.html">Brute force</a> approach has a time complexity of \( O(n^3) \), due to the double loop and the computation of the sum of consecutive primes at each iteration.
However, the Sieve of Eratosthenes used for generated the primes has a time complexity of \( O(n\log(\log(n))) \), suggesting that it might be possible to improve the brute force approach.</p>
<p>A major drawback of the brute force approach is the computation of the sum of consecutive primes at each iteration.
This can be optimized by using a cumulative sum, which has the additional benefit that the sum of consecutive primes between \( i \) and \( j \) is equal to \( S_j - S_i \), where \( S_i \) is the cumulative sum of the first \( i \) primes.
Therefore, searching for the sum of any consecutive primes can be done in constant time.</p>
<p>To effectively iterate over all possible combinations of consecutive primes, it's best to start from the longest possible sequence and then decrease the size of the sequence until a sum is prime.
This sequence can be obtained by finding the first cumulative sum that is greater than \( 1000000 \) since it is obvious that the sequence must start from the first prime.
Using a binary search this window size can be found in \( O(\log(n)) \).</p>
<p>The remaining step involve iterating over all the possible windows of consecutive primes until a sum is prime.
Using a set to store the primes can further improve the time complexity of searching if a sum is prime.</p>
<p>In theory, the time complexity of this approach is \( O(wn) \), where \( w \) is the size of the longest window and \( n \) is the number of primes below \( 1000000 \).
Estimating \( w \) based on the size of \( n \) is difficult, but it's clear that it is much smaller than \( n \).
For example in our case \( w \) is \( 546 \) and \( n \) is \( 664579 \).
In practice, this approach only take a couple of iterations since \( w \) is very small, and the iteration is done starting from the largest window.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0050/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def consecutive_prime_sum(lim=10**6):
    primes = list(sieve.primerange(2, lim))
    primes_set = set(primes)
    cumul_sum = list(accumulate(primes))
    max_window = bisect.bisect_left(cumul_sum, lim)
    for window in range(max_window, 0, -1):
        for i in range(len(cumul_sum) - window):
            s = cumul_sum[i + window] - cumul_sum[i]
            if s &gt;= lim:
                break
            if s in primes_set:
                return s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-49"><a class="header" href="#solution-49">Solution</a></h1>
<hr />
<blockquote>
<p>997651</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-digit-replacements"><a class="header" href="#prime-digit-replacements"><a href="https://projecteuler.net/problem=51">Prime digit replacements</a></a></h1>
<blockquote>
<p>By replacing the \( 1^{st} \) digit of the \( 2 \)-digit number \( *3 \), it turns out that six of the nine possible values: \( 13 \), \( 23 \), \( 43 \), \( 53 \), \( 73 \), and \( 83 \), are all prime.</p>
<p>By replacing the \( 3 \)rd and \( 4 \)th digits of \( 56 \)*\( * \)3 with the same digit, this \( 5 \)-digit number is the first example having seven primes among the ten generated numbers, yielding the family: \( 56003 \), \( 56113 \), \( 56333 \), \( 56443 \), \( 56663 \), \( 56773 \), and \( 56993 \). Consequently \( 56003 \), being the first member of this family, is the smallest prime with this property.</p>
<p>Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-50"><a class="header" href="#brute-force-50">Brute force</a></h1>
<p>A straightforward approach to determine the smallest prime that belongs to an eight prime value family involves iterating through all primes and checking whether it is possible to replace \( k \) digits with numbers \( d \) ranging from \( 0 \) to \( 9 \) while still retaining 8 primes.
The condition being the difficulty of the problem, can be split into two parts:</p>
<ul>
<li>Find all the permutation of digits that should be replaced.</li>
<li>Replace the digits with numbers ranging from \( 0 \) to \( 9 \) and check whether the resulting number is prime.</li>
</ul>
<p>The first part can be done quite simply by generating a mask using <a href="https://docs.python.org/3/library/itertools.html#itertools.product">itertools.product</a>.
The mask is binary list with a length equal to the length of the number to verify, where the value <code>True</code> indicates that the digit at the same index should be replaced.</p>
<p>Although the second part may present some challenges in terms of efficiency, its implementation should remain straightforward since the method is intended to be naive.
To solve this, a string of the same length as the original number is constructed, where each digit is selected from either the initial number or the value \( d \), depending on the mask.</p>
<p>Certain corner cases requires some consideration:</p>
<ul>
<li>Number starting with \( 0 \) are invalid, otherwise the smallest seven prime value family would start at \( 03 \). Thus any permutation where the first digit is replaced by \( 0 \) should be skipped.</li>
<li>The mask can not consist of only <code>False</code> values, as this would mean that no digit is replaced. Consequently, any permutations with an all-<code>False</code> mask should be discarded.</li>
</ul>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0051/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_nth_prime_value_family(n):
    for mask in itertools.product([False, True], repeat=len(n)):
        seq_len = 0
        res = 0
        for d in &quot;0123456789&quot;:
            if mask[0] and d == &quot;0&quot; or not any(mask):
                continue
            first = int(&quot;&quot;.join((d if mask[j] else n[j] for j in range(len(n)))))
            if isprime(first):
                if seq_len == 0:
                    res = first

                seq_len += 1
                if seq_len == 8:
                    return res
    return None
</code></pre>
<p>The remaining step simply iterate through all primes and verify whether the number is an eight prime value family.
For simplicity, the <a href="https://docs.sympy.org/latest/modules/ntheory.html#sympy.ntheory.generate.sieve">sympy.sieve</a> functions is used to generate an infinite sequence of primes.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0051/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def prime_digit_replacements():
    for i in sieve:
        res = is_nth_prime_value_family(str(i))
        if res is not None:
            return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-observations"><a class="header" href="#simple-observations">Simple observations</a></h1>
<p>The <a href="problems/problem_0051/./solution1.html">Brute force</a> approach is very slow and highly inefficient, mainly due to redundant verification.
For example, several numbers, such as \( 12345 \) and \( 12346 \), are checked multiples times when the replacement includes the last digit.
Therefore, it is necessary to find a better approach to determine which numbers and which replacements are required.</p>
<p>Let's start with some simple observations that can be made to improve the efficiency of the algorithm:</p>
<ol>
<li>Since the first number of the sequence must be a prime, there is no need to check numbers lower than the current one during digit replacement.
This is because smaller prime are already been verified.</li>
<li>Since the family is an eight prime value family, at least 8 replacements must be prime.
Using <strong>1</strong>, it's unnecessary to replace digits greater than \( 2 \), as this would result in fewer than 8 possible replacements.</li>
<li>Only replacements of \( 3k \) digits, with \( k &gt; 0 \) can give a solution.
Let's first remember that a number \( n \) is divisible by \( 3 \) if and only if the sum of its digits is divisible by \( 3 \).
The rest modulo \( 3 \) of the sum of the digits of the initial numbers excluding the one that will be replaced is either \( 0 \), \( 1 \) or \( 2 \).
If the number of replacements is \( 2 \), then the rest modulo \( 3 \) of the sum of the replacements for \( 0 \) to \( 9 \) is: \( 0 \), \( 2 \), \( 1 \), \( 0 \), \( 2 \), \( 1 \), \( 0 \), \( 2 \), \( 1 \), \( 0 \) respectively.
Therefore, whatever the initial number is, the sum of the digits will always be divisible by \( 3 \) at least 3 times, and thus the maximum value family is \( 7 \).
The same reasoning can be applied to other non-multiples of \( 3 \) digits replacements.</li>
<li>Using <strong>1</strong>, it is possible to generate the replacements more efficiently by adding to the current number the mask multiplied by the nth digit.
For example, if the current number is \( 12345 \) and the mask is \( 00101 \), then the replacement is \( 12345 + 101 * d \).</li>
</ol>
<p>Using these observations, it is possible to compute much more efficiently the prime digit replacements.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0051/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def is_nth_prime_value_family(n):
    for d in range(3):  # Observation 2
        mask = 0
        occurrences = 0
        for i, m in enumerate(str(n)[::-1]):  # Reverse string for easier mask creation
            if m == str(d):
                mask += 10**i
                occurrences += 1

        if occurrences == 0 or occurrences % 3 != 0:  # Observation 3
            continue

        seq_len = 0
        for r in range(10 - d):
            if seq_len + 10 - r &lt; 8:  # Observation 2
                break
            if isprime(n + r * mask):  # Observation 4
                seq_len += 1
            if seq_len == 8:
                return n
</code></pre>
<p>The remaining step is the same as the <a href="problems/problem_0051/./solution1.html">Brute force</a> approach.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0051/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def prime_digit_replacements():
    for i in sieve:
        res = is_nth_prime_value_family(i)
        if res is not None:
            return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-50"><a class="header" href="#solution-50">Solution</a></h1>
<hr />
<blockquote>
<p>121313</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>You can download each solution and modify it as much as you like. However, 
please do not copy the answer to the Euler project without thinking about it 
first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>You can contribute as much as you want to the project, for more information
please see <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/README.md">README.md</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
