<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Project Euler</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Solution of Project Euler problems">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="problems/project_euler.html"><strong aria-hidden="true">2.</strong> Project Euler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0001/problem.html"><strong aria-hidden="true">2.1.</strong> Problem 1: Multiples of 3 or 5</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0001/solution1.html"><strong aria-hidden="true">2.1.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0001/solution2.html"><strong aria-hidden="true">2.1.2.</strong> Three by three</a></li><li class="chapter-item "><a href="problems/problem_0001/solution3.html"><strong aria-hidden="true">2.1.3.</strong> Summing everything</a></li><li class="chapter-item "><a href="problems/problem_0001/solution.html"><strong aria-hidden="true">2.1.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0002/problem.html"><strong aria-hidden="true">2.2.</strong> Problem 2: even Fibonacci numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0002/solution1.html"><strong aria-hidden="true">2.2.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0002/solution2.html"><strong aria-hidden="true">2.2.2.</strong> Fibonacci recurrence</a></li><li class="chapter-item "><a href="problems/problem_0002/solution3.html"><strong aria-hidden="true">2.2.3.</strong> Fibonacci and the golden ratio</a></li><li class="chapter-item "><a href="problems/problem_0002/solution.html"><strong aria-hidden="true">2.2.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0003/problem.html"><strong aria-hidden="true">2.3.</strong> Problem 3: Largest prime factor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0003/solution1.html"><strong aria-hidden="true">2.3.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0003/solution2.html"><strong aria-hidden="true">2.3.2.</strong> Two by two</a></li><li class="chapter-item "><a href="problems/problem_0003/solution.html"><strong aria-hidden="true">2.3.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0004/problem.html"><strong aria-hidden="true">2.4.</strong> Problem 4: Largest palindrome product</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0004/solution1.html"><strong aria-hidden="true">2.4.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0004/solution2.html"><strong aria-hidden="true">2.4.2.</strong> Factorisation is the key</a></li><li class="chapter-item "><a href="problems/problem_0004/solution3.html"><strong aria-hidden="true">2.4.3.</strong> With pen and paper</a></li><li class="chapter-item "><a href="problems/problem_0004/solution.html"><strong aria-hidden="true">2.4.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0005/problem.html"><strong aria-hidden="true">2.5.</strong> Problem 5: Smallest multiple</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0005/solution1.html"><strong aria-hidden="true">2.5.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0005/solution2.html"><strong aria-hidden="true">2.5.2.</strong> Prime factorization</a></li><li class="chapter-item "><a href="problems/problem_0005/solution3.html"><strong aria-hidden="true">2.5.3.</strong> Least common multiple</a></li><li class="chapter-item "><a href="problems/problem_0005/solution.html"><strong aria-hidden="true">2.5.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0006/problem.html"><strong aria-hidden="true">2.6.</strong> Problem 6: Sum square difference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0006/solution1.html"><strong aria-hidden="true">2.6.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0006/solution2.html"><strong aria-hidden="true">2.6.2.</strong> Summation formula</a></li><li class="chapter-item "><a href="problems/problem_0006/solution.html"><strong aria-hidden="true">2.6.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0007/problem.html"><strong aria-hidden="true">2.7.</strong> Problem 7: 10001st prime</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0007/solution1.html"><strong aria-hidden="true">2.7.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0007/solution2.html"><strong aria-hidden="true">2.7.2.</strong> Almost six by six</a></li><li class="chapter-item "><a href="problems/problem_0007/solution3.html"><strong aria-hidden="true">2.7.3.</strong> Prime number theorem</a></li><li class="chapter-item "><a href="problems/problem_0007/solution.html"><strong aria-hidden="true">2.7.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0008/problem.html"><strong aria-hidden="true">2.8.</strong> Problem 8: Largest product in a series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0008/solution1.html"><strong aria-hidden="true">2.8.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0008/solution2.html"><strong aria-hidden="true">2.8.2.</strong> 0 are useless</a></li><li class="chapter-item "><a href="problems/problem_0008/solution.html"><strong aria-hidden="true">2.8.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0009/problem.html"><strong aria-hidden="true">2.9.</strong> Problem 9: Special Pythagorean triplet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0009/solution1.html"><strong aria-hidden="true">2.9.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0009/solution2.html"><strong aria-hidden="true">2.9.2.</strong> With a little thought</a></li><li class="chapter-item "><a href="problems/problem_0009/solution3.html"><strong aria-hidden="true">2.9.3.</strong> Prime Pythagorean triples</a></li><li class="chapter-item "><a href="problems/problem_0009/solution.html"><strong aria-hidden="true">2.9.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0010/problem.html"><strong aria-hidden="true">2.10.</strong> Problem 10: Summation of primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0010/solution1.html"><strong aria-hidden="true">2.10.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0010/solution2.html"><strong aria-hidden="true">2.10.2.</strong> Summation minus summation</a></li><li class="chapter-item "><a href="problems/problem_0010/solution3.html"><strong aria-hidden="true">2.10.3.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0010/solution.html"><strong aria-hidden="true">2.10.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0011/problem.html"><strong aria-hidden="true">2.11.</strong> Problem 11: Largest product in a grid</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0011/solution1.html"><strong aria-hidden="true">2.11.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0011/solution.html"><strong aria-hidden="true">2.11.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0012/problem.html"><strong aria-hidden="true">2.12.</strong> Problem 12: Highly divisible triangular number</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0012/solution1.html"><strong aria-hidden="true">2.12.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0012/solution2.html"><strong aria-hidden="true">2.12.2.</strong> Common factor</a></li><li class="chapter-item "><a href="problems/problem_0012/solution.html"><strong aria-hidden="true">2.12.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0013/problem.html"><strong aria-hidden="true">2.13.</strong> Problem 13: Large sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0013/solution1.html"><strong aria-hidden="true">2.13.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0013/solution.html"><strong aria-hidden="true">2.13.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0014/problem.html"><strong aria-hidden="true">2.14.</strong> Problem 14: Longest Collatz sequence</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0014/solution1.html"><strong aria-hidden="true">2.14.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0014/solution2.html"><strong aria-hidden="true">2.14.2.</strong> Caching</a></li><li class="chapter-item "><a href="problems/problem_0014/solution.html"><strong aria-hidden="true">2.14.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0015/problem.html"><strong aria-hidden="true">2.15.</strong> Problem 15: Lattice paths</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0015/solution1.html"><strong aria-hidden="true">2.15.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0015/solution2.html"><strong aria-hidden="true">2.15.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0015/solution3.html"><strong aria-hidden="true">2.15.3.</strong> Combination</a></li><li class="chapter-item "><a href="problems/problem_0015/solution.html"><strong aria-hidden="true">2.15.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0016/problem.html"><strong aria-hidden="true">2.16.</strong> Problem 16: Power digit sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0016/solution1.html"><strong aria-hidden="true">2.16.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0016/solution.html"><strong aria-hidden="true">2.16.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0017/problem.html"><strong aria-hidden="true">2.17.</strong> Problem 17: Number letter counts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0017/solution1.html"><strong aria-hidden="true">2.17.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0017/solution.html"><strong aria-hidden="true">2.17.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0018/problem.html"><strong aria-hidden="true">2.18.</strong> Problem 18: Maximum path sum I</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0018/solution1.html"><strong aria-hidden="true">2.18.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0018/solution2.html"><strong aria-hidden="true">2.18.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0018/solution.html"><strong aria-hidden="true">2.18.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0019/problem.html"><strong aria-hidden="true">2.19.</strong> Problem 19: Counting Sundays</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0019/solution1.html"><strong aria-hidden="true">2.19.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0019/solution.html"><strong aria-hidden="true">2.19.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0020/problem.html"><strong aria-hidden="true">2.20.</strong> Problem 20: Factorial digit sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0020/solution1.html"><strong aria-hidden="true">2.20.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0020/solution.html"><strong aria-hidden="true">2.20.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0021/problem.html"><strong aria-hidden="true">2.21.</strong> Problem 21: Amicable numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0021/solution1.html"><strong aria-hidden="true">2.21.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0021/solution.html"><strong aria-hidden="true">2.21.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0022/problem.html"><strong aria-hidden="true">2.22.</strong> Problem 22: Names scores</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0022/solution1.html"><strong aria-hidden="true">2.22.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0022/solution.html"><strong aria-hidden="true">2.22.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0023/problem.html"><strong aria-hidden="true">2.23.</strong> Problem 23: Non-abundant sums</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0023/solution1.html"><strong aria-hidden="true">2.23.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0023/solution2.html"><strong aria-hidden="true">2.23.2.</strong> Set</a></li><li class="chapter-item "><a href="problems/problem_0023/solution.html"><strong aria-hidden="true">2.23.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0024/problem.html"><strong aria-hidden="true">2.24.</strong> Problem 24: Lexicographic permutations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0024/solution1.html"><strong aria-hidden="true">2.24.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0024/solution2.html"><strong aria-hidden="true">2.24.2.</strong> Maths permutations</a></li><li class="chapter-item "><a href="problems/problem_0024/solution.html"><strong aria-hidden="true">2.24.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0025/problem.html"><strong aria-hidden="true">2.25.</strong> Problem 25: 1000-digit Fibonacci number</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0025/solution1.html"><strong aria-hidden="true">2.25.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0025/solution2.html"><strong aria-hidden="true">2.25.2.</strong> Fibonacci convergence</a></li><li class="chapter-item "><a href="problems/problem_0025/solution.html"><strong aria-hidden="true">2.25.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0026/problem.html"><strong aria-hidden="true">2.26.</strong> Problem 26: Reciprocal cycles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0026/solution1.html"><strong aria-hidden="true">2.26.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0026/solution2.html"><strong aria-hidden="true">2.26.2.</strong> Carmichael function</a></li><li class="chapter-item "><a href="problems/problem_0026/solution.html"><strong aria-hidden="true">2.26.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0027/problem.html"><strong aria-hidden="true">2.27.</strong> Problem 27: Quadratic primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0027/solution1.html"><strong aria-hidden="true">2.27.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0027/solution2.html"><strong aria-hidden="true">2.27.2.</strong> Shorten the intervals</a></li><li class="chapter-item "><a href="problems/problem_0027/solution3.html"><strong aria-hidden="true">2.27.3.</strong> Lucky numbers of Euler</a></li><li class="chapter-item "><a href="problems/problem_0027/solution.html"><strong aria-hidden="true">2.27.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0028/problem.html"><strong aria-hidden="true">2.28.</strong> Problem 28: Number spiral diagonals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0028/solution1.html"><strong aria-hidden="true">2.28.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0028/solution2.html"><strong aria-hidden="true">2.28.2.</strong> Summation</a></li><li class="chapter-item "><a href="problems/problem_0028/solution.html"><strong aria-hidden="true">2.28.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0029/problem.html"><strong aria-hidden="true">2.29.</strong> Problem 29: Distinct powers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0029/solution1.html"><strong aria-hidden="true">2.29.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0029/solution2.html"><strong aria-hidden="true">2.29.2.</strong> Discarding duplicate</a></li><li class="chapter-item "><a href="problems/problem_0029/solution.html"><strong aria-hidden="true">2.29.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0030/problem.html"><strong aria-hidden="true">2.30.</strong> Problem 30: Digit fifth powers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0030/solution1.html"><strong aria-hidden="true">2.30.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0030/solution2.html"><strong aria-hidden="true">2.30.2.</strong> Search unique combination</a></li><li class="chapter-item "><a href="problems/problem_0030/solution.html"><strong aria-hidden="true">2.30.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0031/problem.html"><strong aria-hidden="true">2.31.</strong> Problem 31: Coin sums</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0031/solution1.html"><strong aria-hidden="true">2.31.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0031/solution2.html"><strong aria-hidden="true">2.31.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0031/solution3.html"><strong aria-hidden="true">2.31.3.</strong> Better dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0031/solution.html"><strong aria-hidden="true">2.31.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0032/problem.html"><strong aria-hidden="true">2.32.</strong> Problem 32: Pandigital products</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0032/solution1.html"><strong aria-hidden="true">2.32.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0032/solution.html"><strong aria-hidden="true">2.32.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0033/problem.html"><strong aria-hidden="true">2.33.</strong> Problem 33: Digit cancelling fractions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0033/solution1.html"><strong aria-hidden="true">2.33.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0033/solution.html"><strong aria-hidden="true">2.33.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0034/problem.html"><strong aria-hidden="true">2.34.</strong> Problem 34: Digit factorials</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0034/solution1.html"><strong aria-hidden="true">2.34.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0034/solution.html"><strong aria-hidden="true">2.34.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0035/problem.html"><strong aria-hidden="true">2.35.</strong> Problem 35: Circular primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0035/solution1.html"><strong aria-hidden="true">2.35.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0035/solution2.html"><strong aria-hidden="true">2.35.2.</strong> 1, 3, 7, 9</a></li><li class="chapter-item "><a href="problems/problem_0035/solution.html"><strong aria-hidden="true">2.35.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0036/problem.html"><strong aria-hidden="true">2.36.</strong> Problem 36: Double-base palindromes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0036/solution1.html"><strong aria-hidden="true">2.36.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0036/solution2.html"><strong aria-hidden="true">2.36.2.</strong> Generating palindromes</a></li><li class="chapter-item "><a href="problems/problem_0036/solution.html"><strong aria-hidden="true">2.36.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0037/problem.html"><strong aria-hidden="true">2.37.</strong> Problem 37: Truncatable primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0037/solution1.html"><strong aria-hidden="true">2.37.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0037/solution2.html"><strong aria-hidden="true">2.37.2.</strong> Construct them all</a></li><li class="chapter-item "><a href="problems/problem_0037/solution.html"><strong aria-hidden="true">2.37.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0038/problem.html"><strong aria-hidden="true">2.38.</strong> Problem 38: Pandigital multiples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0038/solution1.html"><strong aria-hidden="true">2.38.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0038/solution2.html"><strong aria-hidden="true">2.38.2.</strong> Good old pen and paper</a></li><li class="chapter-item "><a href="problems/problem_0038/solution.html"><strong aria-hidden="true">2.38.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0039/problem.html"><strong aria-hidden="true">2.39.</strong> Problem 39: Integer right triangles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0039/solution1.html"><strong aria-hidden="true">2.39.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0039/solution2.html"><strong aria-hidden="true">2.39.2.</strong> Fewer loops is better</a></li><li class="chapter-item "><a href="problems/problem_0039/solution3.html"><strong aria-hidden="true">2.39.3.</strong> Even fewer loops</a></li><li class="chapter-item "><a href="problems/problem_0039/solution4.html"><strong aria-hidden="true">2.39.4.</strong> Tree of primitive Pythagorean triples</a></li><li class="chapter-item "><a href="problems/problem_0039/solution.html"><strong aria-hidden="true">2.39.5.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0040/problem.html"><strong aria-hidden="true">2.40.</strong> Problem 40: Champernowne's constant</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0040/solution1.html"><strong aria-hidden="true">2.40.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0040/solution2.html"><strong aria-hidden="true">2.40.2.</strong> Foreshadowing</a></li><li class="chapter-item "><a href="problems/problem_0040/solution.html"><strong aria-hidden="true">2.40.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0041/problem.html"><strong aria-hidden="true">2.41.</strong> Problem 41: Pandigital prime</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0041/solution1.html"><strong aria-hidden="true">2.41.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0041/solution.html"><strong aria-hidden="true">2.41.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0042/problem.html"><strong aria-hidden="true">2.42.</strong> Problem 42: Coded triangle numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0042/solution1.html"><strong aria-hidden="true">2.42.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0042/solution.html"><strong aria-hidden="true">2.42.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0043/problem.html"><strong aria-hidden="true">2.43.</strong> Problem 43: Sub-string divisibility</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0043/solution1.html"><strong aria-hidden="true">2.43.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0043/solution2.html"><strong aria-hidden="true">2.43.2.</strong> Generation over iteration</a></li><li class="chapter-item "><a href="problems/problem_0043/solution3.html"><strong aria-hidden="true">2.43.3.</strong> With pen and paper</a></li><li class="chapter-item "><a href="problems/problem_0043/solution.html"><strong aria-hidden="true">2.43.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0044/problem.html"><strong aria-hidden="true">2.44.</strong> Problem 44: Pentagon numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0044/solution1.html"><strong aria-hidden="true">2.44.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0044/solution2.html"><strong aria-hidden="true">2.44.2.</strong> Optimal iteration</a></li><li class="chapter-item "><a href="problems/problem_0044/solution3.html"><strong aria-hidden="true">2.44.3.</strong> Even better iteration</a></li><li class="chapter-item "><a href="problems/problem_0044/solution.html"><strong aria-hidden="true">2.44.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0045/problem.html"><strong aria-hidden="true">2.45.</strong> Problem 45: Triangular, pentagonal, and hexagonal</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0045/solution1.html"><strong aria-hidden="true">2.45.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0045/solution2.html"><strong aria-hidden="true">2.45.2.</strong> Triangular numbers are useless</a></li><li class="chapter-item "><a href="problems/problem_0045/solution3.html"><strong aria-hidden="true">2.45.3.</strong> Diophantine equations</a></li><li class="chapter-item "><a href="problems/problem_0045/solution.html"><strong aria-hidden="true">2.45.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0046/problem.html"><strong aria-hidden="true">2.46.</strong> Problem 46: Goldbach's other conjecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0046/solution1.html"><strong aria-hidden="true">2.46.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0046/solution2.html"><strong aria-hidden="true">2.46.2.</strong> Better iteration and caching</a></li><li class="chapter-item "><a href="problems/problem_0046/solution.html"><strong aria-hidden="true">2.46.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0047/problem.html"><strong aria-hidden="true">2.47.</strong> Problem 47: Distinct primes factors</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0047/solution1.html"><strong aria-hidden="true">2.47.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0047/solution2.html"><strong aria-hidden="true">2.47.2.</strong> Cache is life</a></li><li class="chapter-item "><a href="problems/problem_0047/solution3.html"><strong aria-hidden="true">2.47.3.</strong> Good old Sieve</a></li><li class="chapter-item "><a href="problems/problem_0047/solution.html"><strong aria-hidden="true">2.47.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0048/problem.html"><strong aria-hidden="true">2.48.</strong> Problem 48: Self powers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0048/solution1.html"><strong aria-hidden="true">2.48.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0048/solution2.html"><strong aria-hidden="true">2.48.2.</strong> Modulos reduction</a></li><li class="chapter-item "><a href="problems/problem_0048/solution.html"><strong aria-hidden="true">2.48.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0049/problem.html"><strong aria-hidden="true">2.49.</strong> Problem 49: Prime permutations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0049/solution1.html"><strong aria-hidden="true">2.49.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0049/solution2.html"><strong aria-hidden="true">2.49.2.</strong> Primes permutations</a></li><li class="chapter-item "><a href="problems/problem_0049/solution.html"><strong aria-hidden="true">2.49.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0050/problem.html"><strong aria-hidden="true">2.50.</strong> Problem 50: Consecutive prime sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0050/solution1.html"><strong aria-hidden="true">2.50.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0050/solution2.html"><strong aria-hidden="true">2.50.2.</strong> Cumulative sum</a></li><li class="chapter-item "><a href="problems/problem_0050/solution.html"><strong aria-hidden="true">2.50.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0051/problem.html"><strong aria-hidden="true">2.51.</strong> Problem 51: Prime digit replacements</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0051/solution1.html"><strong aria-hidden="true">2.51.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0051/solution2.html"><strong aria-hidden="true">2.51.2.</strong> Simple observations</a></li><li class="chapter-item "><a href="problems/problem_0051/solution.html"><strong aria-hidden="true">2.51.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0052/problem.html"><strong aria-hidden="true">2.52.</strong> Problem 52: Permuted multiples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0052/solution1.html"><strong aria-hidden="true">2.52.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0052/solution2.html"><strong aria-hidden="true">2.52.2.</strong> Observation is insight</a></li><li class="chapter-item "><a href="problems/problem_0052/solution.html"><strong aria-hidden="true">2.52.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0053/problem.html"><strong aria-hidden="true">2.53.</strong> Problem 53: Combinatoric selections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0053/solution1.html"><strong aria-hidden="true">2.53.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0053/solution2.html"><strong aria-hidden="true">2.53.2.</strong> Pascal's Triangle</a></li><li class="chapter-item "><a href="problems/problem_0053/solution.html"><strong aria-hidden="true">2.53.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0054/problem.html"><strong aria-hidden="true">2.54.</strong> Problem 54: Poker hands</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0054/solution1.html"><strong aria-hidden="true">2.54.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0054/solution.html"><strong aria-hidden="true">2.54.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0055/problem.html"><strong aria-hidden="true">2.55.</strong> Problem 55: Lychrel numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0055/solution1.html"><strong aria-hidden="true">2.55.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0055/solution.html"><strong aria-hidden="true">2.55.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0056/problem.html"><strong aria-hidden="true">2.56.</strong> Problem 56: Powerful digit sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0056/solution1.html"><strong aria-hidden="true">2.56.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0056/solution.html"><strong aria-hidden="true">2.56.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0057/problem.html"><strong aria-hidden="true">2.57.</strong> Problem 57: Square root convergents</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0057/solution1.html"><strong aria-hidden="true">2.57.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0057/solution2.html"><strong aria-hidden="true">2.57.2.</strong> A better recurrence?</a></li><li class="chapter-item "><a href="problems/problem_0057/solution.html"><strong aria-hidden="true">2.57.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0058/problem.html"><strong aria-hidden="true">2.58.</strong> Problem 58: Spiral primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0058/solution1.html"><strong aria-hidden="true">2.58.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0058/solution.html"><strong aria-hidden="true">2.58.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0059/problem.html"><strong aria-hidden="true">2.59.</strong> Problem 59: XOR decryption</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0059/solution1.html"><strong aria-hidden="true">2.59.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0059/solution.html"><strong aria-hidden="true">2.59.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0060/problem.html"><strong aria-hidden="true">2.60.</strong> Problem 60: Prime pair sets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0060/solution1.html"><strong aria-hidden="true">2.60.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0060/solution2.html"><strong aria-hidden="true">2.60.2.</strong> Clique's graph theory</a></li><li class="chapter-item "><a href="problems/problem_0060/solution.html"><strong aria-hidden="true">2.60.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0061/problem.html"><strong aria-hidden="true">2.61.</strong> Problem 61: Cyclical figurate numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0061/solution1.html"><strong aria-hidden="true">2.61.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0061/solution2.html"><strong aria-hidden="true">2.61.2.</strong> Caching polygonal numbers</a></li><li class="chapter-item "><a href="problems/problem_0061/solution.html"><strong aria-hidden="true">2.61.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0062/problem.html"><strong aria-hidden="true">2.62.</strong> Problem 62: Cubic permutations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0062/solution1.html"><strong aria-hidden="true">2.62.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0062/solution2.html"><strong aria-hidden="true">2.62.2.</strong> Iterating and caching</a></li><li class="chapter-item "><a href="problems/problem_0062/solution.html"><strong aria-hidden="true">2.62.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0063/problem.html"><strong aria-hidden="true">2.63.</strong> Problem 63: Powerful digit counts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0063/solution1.html"><strong aria-hidden="true">2.63.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0063/solution2.html"><strong aria-hidden="true">2.63.2.</strong> Back to initial equation</a></li><li class="chapter-item "><a href="problems/problem_0063/solution.html"><strong aria-hidden="true">2.63.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0064/problem.html"><strong aria-hidden="true">2.64.</strong> Problem 64: Odd period square roots</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0064/solution1.html"><strong aria-hidden="true">2.64.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0064/solution2.html"><strong aria-hidden="true">2.64.2.</strong> Another property of continued fractions</a></li><li class="chapter-item "><a href="problems/problem_0064/solution.html"><strong aria-hidden="true">2.64.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0065/problem.html"><strong aria-hidden="true">2.65.</strong> Problem 65: Convergents of e</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0065/solution1.html"><strong aria-hidden="true">2.65.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0065/solution.html"><strong aria-hidden="true">2.65.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0066/problem.html"><strong aria-hidden="true">2.66.</strong> Problem 66: Diophantine equation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0066/solution1.html"><strong aria-hidden="true">2.66.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0066/solution2.html"><strong aria-hidden="true">2.66.2.</strong> Solving Pell's equations</a></li><li class="chapter-item "><a href="problems/problem_0066/solution.html"><strong aria-hidden="true">2.66.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0067/problem.html"><strong aria-hidden="true">2.67.</strong> Problem 67: Maximum path sum II</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0067/solution1.html"><strong aria-hidden="true">2.67.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0067/solution.html"><strong aria-hidden="true">2.67.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0068/problem.html"><strong aria-hidden="true">2.68.</strong> Problem 68: Magic 5-gon ring</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0068/solution1.html"><strong aria-hidden="true">2.68.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0068/solution.html"><strong aria-hidden="true">2.68.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0069/problem.html"><strong aria-hidden="true">2.69.</strong> Problem 69: Totient maximum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0069/solution1.html"><strong aria-hidden="true">2.69.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0069/solution2.html"><strong aria-hidden="true">2.69.2.</strong> Caching totients</a></li><li class="chapter-item "><a href="problems/problem_0069/solution3.html"><strong aria-hidden="true">2.69.3.</strong> Euler's totient function</a></li><li class="chapter-item "><a href="problems/problem_0069/solution.html"><strong aria-hidden="true">2.69.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0070/problem.html"><strong aria-hidden="true">2.70.</strong> Problem 70: Totient permutation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0070/solution1.html"><strong aria-hidden="true">2.70.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0070/solution2.html"><strong aria-hidden="true">2.70.2.</strong> Euler's totient function</a></li><li class="chapter-item "><a href="problems/problem_0070/solution.html"><strong aria-hidden="true">2.70.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0071/problem.html"><strong aria-hidden="true">2.71.</strong> Problem 71: Ordered fractions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0071/solution1.html"><strong aria-hidden="true">2.71.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0071/solution2.html"><strong aria-hidden="true">2.71.2.</strong> Farey sequence</a></li><li class="chapter-item "><a href="problems/problem_0071/solution.html"><strong aria-hidden="true">2.71.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0072/problem.html"><strong aria-hidden="true">2.72.</strong> Problem 72: Counting fractions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0072/solution1.html"><strong aria-hidden="true">2.72.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0072/solution2.html"><strong aria-hidden="true">2.72.2.</strong> Farey sequence and Euler's totient function</a></li><li class="chapter-item "><a href="problems/problem_0072/solution.html"><strong aria-hidden="true">2.72.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0073/problem.html"><strong aria-hidden="true">2.73.</strong> Problem 73: Counting fractions in a range</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0073/solution1.html"><strong aria-hidden="true">2.73.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0073/solution.html"><strong aria-hidden="true">2.73.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0074/problem.html"><strong aria-hidden="true">2.74.</strong> Problem 74: Digit factorial chains</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0074/solution1.html"><strong aria-hidden="true">2.74.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0074/solution2.html"><strong aria-hidden="true">2.74.2.</strong> Caching the chain</a></li><li class="chapter-item "><a href="problems/problem_0074/solution.html"><strong aria-hidden="true">2.74.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0075/problem.html"><strong aria-hidden="true">2.75.</strong> Problem 75: Singular Integer Right Triangles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0075/solution1.html"><strong aria-hidden="true">2.75.1.</strong> Tree of primitive Pythagorean triples</a></li><li class="chapter-item "><a href="problems/problem_0075/solution.html"><strong aria-hidden="true">2.75.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0076/problem.html"><strong aria-hidden="true">2.76.</strong> Problem 76: Counting Summations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0076/solution1.html"><strong aria-hidden="true">2.76.1.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0076/solution.html"><strong aria-hidden="true">2.76.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0077/problem.html"><strong aria-hidden="true">2.77.</strong> Problem 77: Prime Summations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0077/solution1.html"><strong aria-hidden="true">2.77.1.</strong> Dynamic programming is hidden recursion problem</a></li><li class="chapter-item "><a href="problems/problem_0077/solution.html"><strong aria-hidden="true">2.77.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0078/problem.html"><strong aria-hidden="true">2.78.</strong> Problem 78: Coin Partitions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0078/solution1.html"><strong aria-hidden="true">2.78.1.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0078/solution2.html"><strong aria-hidden="true">2.78.2.</strong> Euler partition function</a></li><li class="chapter-item "><a href="problems/problem_0077/solution.html"><strong aria-hidden="true">2.78.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0079/problem.html"><strong aria-hidden="true">2.79.</strong> Problem 79: Passcode Derivation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0079/solution1.html"><strong aria-hidden="true">2.79.1.</strong> Topological sorting</a></li><li class="chapter-item "><a href="problems/problem_0079/solution.html"><strong aria-hidden="true">2.79.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0080/problem.html"><strong aria-hidden="true">2.80.</strong> Problem 80: Square Root Digital Expansion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0080/solution1.html"><strong aria-hidden="true">2.80.1.</strong> Square roots by subtraction</a></li><li class="chapter-item "><a href="problems/problem_0080/solution.html"><strong aria-hidden="true">2.80.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0081/problem.html"><strong aria-hidden="true">2.81.</strong> Problem 81: Path Sum: Two Ways</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0081/solution1.html"><strong aria-hidden="true">2.81.1.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0081/solution.html"><strong aria-hidden="true">2.81.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0082/problem.html"><strong aria-hidden="true">2.82.</strong> Problem 82: Path Sum: Three Ways</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0082/solution1.html"><strong aria-hidden="true">2.82.1.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0082/solution.html"><strong aria-hidden="true">2.82.2.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="usage/usage.html"><strong aria-hidden="true">3.</strong> Usage</a></li><li class="chapter-item expanded "><a href="contributing/contributing.html"><strong aria-hidden="true">4.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Project Euler</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/TurtleSmoke/Project-Euler" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This document gathers explanations on the solutions of the
<a href="https://projecteuler.net">Euler Project</a> exercises.
Each exercise has its own part, which can be discovered in the table of 
contents.
You can find the source code of every solution as well as the source code of my
<a href="https://rust-lang.github.io/mdBook/">mdBook</a> on my <a href="https://github.com/">Github</a>:
<a href="https://github.com/TurtleSmoke/Project-Euler">TurtleSmoke Project Euler</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-euler"><a class="header" href="#project-euler"><a href="https://projecteuler.net/">Project Euler</a></a></h1>
<h2 id="what-is-project-euler"><a class="header" href="#what-is-project-euler"><strong>What is Project Euler?</strong></a></h2>
<blockquote>
<p>Project Euler is a series of challenging mathematical/computer programming
problems that will require more than just mathematical insights to solve.
Although mathematics will help you arrive at elegant and efficient methods,
the use of a computer and programming skills will be required to solve
most problems.</p>
<p>The motivation for starting Project Euler, and its continuation, is to
provide a platform for the inquiring mind to delve into unfamiliar areas
and learn new concepts in a fun and recreational context.</p>
</blockquote>
<h2 id="who-are-the-problems-aimed-at"><a class="header" href="#who-are-the-problems-aimed-at"><strong>Who are the problems aimed at?</strong></a></h2>
<blockquote>
<p>The intended audience include students for whom the basic curriculum is not
feeding their hunger to learn, adults whose background was not primarily
mathematics but had an interest in things mathematical, and professionals
who want to keep their problem solving and mathematics on the cutting edge.</p>
<p>Currently we have 1036139 registered members who have solved at least one
problem, representing 220 locations throughout the world, and collectively
using 108 different programming langues to solve the problems.</p>
</blockquote>
<h2 id="can-anyone-solve-the-problems"><a class="header" href="#can-anyone-solve-the-problems"><strong>Can anyone solve the problems?</strong></a></h2>
<blockquote>
<p>The problems range in difficulty and for many the experience is inductive
chain learning. That is, by solving one problem it will expose you to a
new concept that allows you to undertake a previously inaccessible problem.
So the determined participant will slowly but surely work his/her way
through every problem.</p>
</blockquote>
<h2 id="what-next"><a class="header" href="#what-next"><strong>What next?</strong></a></h2>
<blockquote>
<p>In order to track your progress it is necessary to setup an account and
have Cookies enabled.</p>
<p>If you already have an account, then
<a href="https://projecteuler.net/sign_in">Sign In</a>. Otherwise, please
<a href="https://projecteuler.net/register">Register</a> – it's completely free!
However, as the problems are challenging, then you may wish to view the
<a href="https://projecteuler.net/archives">Problems</a> before registering.</p>
</blockquote>
<hr />
<p style="text-align: center; font-size: 125%; font-style: italic; color: #bbb">
Project Euler exists to encourage, challenge, and develop the skills 
and enjoyment of anyone with an interest in the fascinating world of mathematics.
</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiples-of-3-or-5"><a class="header" href="#multiples-of-3-or-5"><a href="https://projecteuler.net/problem=1">Multiples of 3 or 5</a></a></h1>
<blockquote>
<p>If we list all the natural numbers below \( 10 \) that are multiples of \( 3 \) or \( 5 \), we get \( 3 \), \( 5 \), \( 6 \) and \( 9 \). The sum of these multiples is \( 23 \).</p>
<p>Find the sum of all the multiples of \( 3 \) or \( 5 \) below \( 1000 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force"><a class="header" href="#brute-force">Brute force</a></h1>
<p>The first problem is actually quite easy, the naive solution is to iterate over
each number between 0 and 1000 and check those that are multiples of 3 or 5.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=1000):
    return sum(i for i in range(limit) if i % 3 == 0 or i % 5 == 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="three-by-three"><a class="header" href="#three-by-three">Three by three</a></h1>
<p>The <a href="problems/problem_0001/solution1.html">Brute force</a> is actually quite slow, at least it would be if
the limit was greater than 1000. Since only multiples of 3 and 5 are useful,
iterating 3 by 3 and then 5 by 5 will be faster. We have to be careful with the
multiples of 3 and 5 because they will be counted twice. So we have to subtract
them from the result.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=1000):
    sum_3 = sum(i for i in range(0, limit, 3) if i % 3 == 0)
    sum_5 = sum(i for i in range(0, limit, 5) if i % 5 == 0)
    sum_15 = sum(i for i in range(0, limit, 15) if i % 15 == 0)

    return sum_3 + sum_5 - sum_15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summing-everything"><a class="header" href="#summing-everything">Summing everything</a></h1>
<p>The <a href="problems/problem_0001/solution2.html">Three by three</a> solution is quite interesting because it
reduces the problem into smaller parts. For example, the sum of multiples of
three is the following:</p>
<p>\[ 3 + 6 + 9 + 12 + 15 + ... \]
\[ 3 * ( 1 + 2 + 3 + 4 + 5 ...) \]
\[ 3 * \sum_{i=0}^{\lfloor\frac{1000}{3}\rfloor} x_i \]</p>
<p>It is the sum of an arithmetic sequences, which is equal to:</p>
<p>\[ \frac{n*(n+1)}{2} \]</p>
<p>The <a href="problems/problem_0001/solution2.html">Three by three</a> solution can be reduced to:</p>
<p>\[ 3 * \frac{\lfloor\frac{999}{3}\rfloor * (\lfloor\frac{999}{3}\rfloor + 1)}{2} +5 * \frac{\lfloor\frac{999}{5}\rfloor * (\lfloor\frac{999}{5}\rfloor + 1)}{2} -15 * \frac{\lfloor\frac{999}{15}\rfloor * (\lfloor\frac{999}{15}\rfloor + 1)}{2} \]</p>
<p>Note that the limit is 999 because 1000 should not be included.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=999):
    limit_3 = limit // 3
    limit_5 = limit // 5
    limit_15 = limit // 15

    sum_3 = 3 * (limit_3 * (limit_3 + 1) // 2)
    sum_5 = 5 * (limit_5 * (limit_5 + 1) // 2)
    sum_15 = 15 * (limit_15 * (limit_15 + 1) // 2)

    return sum_3 + sum_5 - sum_15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution"><a class="header" href="#solution">Solution</a></h1>
<hr />
<blockquote>
<p>233168</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-fibonacci-numbers"><a class="header" href="#even-fibonacci-numbers"><a href="https://projecteuler.net/problem=2">Even Fibonacci numbers</a></a></h1>
<blockquote>
<p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with \( 1 \) and \( 2 \), the first \( 10 \) terms will be:</p>
<p>\[
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
\]</p>
<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-1"><a class="header" href="#brute-force-1">Brute force</a></h1>
<blockquote>
<p>The <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a> form
a sequence, called the Fibonacci
<a href="https://en.wikipedia.org/wiki/Integer_sequence">sequence</a>, such that each
number is the sum of the two preceding ones, starting from 0 and 1.</p>
</blockquote>
<p>The sum of all even numbers in the Fibonacci sequence less than 4 million can be
calculated quite easily by iterating over the sequence until the threshold is
reached by adding each even number to the result.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    f0 = 1
    f1 = 2
    res = 0
    while f0 &lt; limit:
        if f0 % 2 == 0:
            res += f0
        f0, f1 = f1, f0 + f1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-recurrence"><a class="header" href="#fibonacci-recurrence">Fibonacci recurrence</a></h1>
<p>If we take a look at the Fibonacci series:</p>
<blockquote>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...</p>
</blockquote>
<p>Since our only concern is the parity of the numbers, with O being odd and E
even:</p>
<blockquote>
<p>E, O, O, E, O, O, E, O, O, E, O, O, E, O, O, E, ...</p>
</blockquote>
<h4 id="it-seems-that-every-third-number-of-the-series-is-even-lets-try-to-prove-it-properly"><a class="header" href="#it-seems-that-every-third-number-of-the-series-is-even-lets-try-to-prove-it-properly">It seems that every third number of the series is even, let's try to prove it properly.</a></h4>
<p>\[ \begin{gather} If\ n=0\ then\ F_{0}=0\ is\ even\\\\ Assuming\ that\ F_ {3n} \ is\ even.\\ \\ F_{3( n+1)} =F_{3n+2} +F_{3n+1} =( F_{3n+1} +F_{3n}) +F_{3n+1} =2F_{3n+1} +F_ {3n}\\ \\ Since\ F_{3n} \ is\ even\ and\ 2F_{3n+1} \ is\ also\ even,\ we\ have\ F_{3( n+1)} \ even\\ because\ it\ is\ the\ sum\ of\ two\ even\ numbers. \end{gather} \]</p>
<h4 id="this-mean-that-the-series-of-even-fibonacci-number-is"><a class="header" href="#this-mean-that-the-series-of-even-fibonacci-number-is">This mean that the series of even Fibonacci number is:</a></h4>
<p>\[ \begin {gather} E_{n} = F_{3n}\\ E_{n+2} = F_{3n+6} = F_{3n+5} + F_ {3n+4}\\ E_{n+2} = (F_{3n+4} + F_{3n+3}) + (F_{3n+3} + F_{3n+2})\\ E_{n+2} = (F_{3n+3} + F_{3n+2} + F_{3n+3}) + (F_{3n+3} + F_{3n+1} + F_{3n})\\ E_{n+2} = 3F_{3n+3} + (F_{3n+2} + F_{3n+1}) + F_{3n}\\ E_{n+2} = 4F_{3(n+1)} + F_{3n}\\ E_{n+2} = 4E_{n+1} + E_{n}\\ \end{gather} \]</p>
<h4 id="which-result-int-the-following-recurrence-relation"><a class="header" href="#which-result-int-the-following-recurrence-relation">Which result int the following recurrence relation:</a></h4>
<p>\[ E_{n} = 4E_ {n-1} + E_{n-2} \]</p>
<h4 id="we-are-searching-for"><a class="header" href="#we-are-searching-for">We are searching for:</a></h4>
<p>\[ \sum_{k=1}^ {n}E_k \]</p>
<h4 id="this-can-be-simplified-as-follows"><a class="header" href="#this-can-be-simplified-as-follows">This can be simplified as follows:</a></h4>
<p>\[ \begin{align} \sum_{k=1}^{n}E_ {k+1} &amp;= \sum_{k=1}^{n}4E_{k} + \sum_{k=1} ^{n}E_{k-1}\\ \sum_{k=1}^{n}E_{k}&amp;= \frac{1}{4}(\sum_{k=1}^{n}E_{k+1} - \sum_{k=1}^{n}E_{k-1})\\ &amp;= \frac{1}{4}(\sum_{k=2}^{n+1}E_{k} - \sum_{k=0}^{n-1}E_{k})\\ &amp;= \frac{1}{4}(E_{n+1} + E_{n} - E_1 - E_0)\\ &amp;= \frac{1}{4}(E_{n+1} + E_{n} - 2)\\ \end{align} \]</p>
<p>The result can be calculated by iterating until \( E_{n+1} \) is greater than
the limit, so that \( E_n \) is less than the limit, then apply the previous
function.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    e0 = 0
    e1 = 2
    while e1 &lt; limit:
        e0, e1 = e1, 4 * e1 + e0

    return (e1 + e0 - 2) // 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-and-the-golden-ratio"><a class="header" href="#fibonacci-and-the-golden-ratio">Fibonacci and the golden ratio</a></h1>
<p>Although the number of iterations of the second solution is lower than that of
the first solution, it is possible to do better:</p>
<p>\[ \begin{align} \frac{1}{4}(E_{n+1} + E_{n} - 2) &amp;= \frac{1}{4}(F_{3(n+1)} + F_{3n} - 2)\\ &amp;= \frac{1}{4}(F_{3n+2} + F_{3n+1} + F_{3n} - 2)\\ &amp;= \frac{1}{4}(2F_{3n+2} - 2)\\ &amp;= \frac{1}{2}(F_{3n+2} - 1)\\ \end{align} \]</p>
<p>This does not really change the problem, since we still need to iterate until
\( F_{3n} \) reach the limit and then compute \(\frac{1}{2}(F_
{3n+2} - 1)\).</p>
<p>Actually, the Fibonacci numbers can be approximated with the following
<a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression">equation</a>:</p>
<p>\[ F_{n} = \frac{\varphi^{n} - (-\varphi)^{-n}}{\sqrt{5}} \]</p>
<p>where \( \varphi = \frac{1+\sqrt{5}}{2} \) is the
<a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a>.</p>
<p>\( -(-\varphi)^{-n} \) can be ignored for large numbers which gives the
equation:</p>
<p>\[ F_{n} = \frac{\varphi^{n}}{\sqrt{5}} \]</p>
<p>The limit is the n-th Fibonacci number such that:</p>
<p>\[ \begin{align} F_{n} &amp;\leqslant M\\ \frac{\varphi ^{n}}{\sqrt{5}} &amp;\leqslant M\\ \varphi ^{n} &amp;\leqslant \sqrt{5} M\\ n\log( \varphi ) &amp;\leqslant \log\left(\sqrt{5} M\right)\\ n &amp;\leqslant \left\lfloor \frac{\log\left(\sqrt{5} M\right)}{\log( \varphi )} \right\rfloor \end{align} \]</p>
<p>The result can be computed with \(\frac{1}{2}(F_{n+2} - 1) \) where \( n =
\left\lfloor \frac{\log\left(\sqrt{5} M\right)}{\log( \varphi )} \right\rfloor
\):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    golden_ratio = (1 + sqrt(5)) / 2
    n = floor(log(sqrt(5) * limit) / log(golden_ratio))
    fn = round((golden_ratio ** (n + 2)) / sqrt(5))

    return (fn - 1) // 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-1"><a class="header" href="#solution-1">Solution</a></h1>
<hr />
<blockquote>
<p>4613732</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-prime-factor"><a class="header" href="#largest-prime-factor"><a href="https://projecteuler.net/problem=3">Largest prime factor</a></a></h1>
<blockquote>
<p>The prime factors of \( 13195 \) are \( 5 \), \( 7 \), \( 13 \) and \( 29 \).</p>
<p>What is the largest prime factor of the number \( 600851475143 \) ?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-2"><a class="header" href="#brute-force-2">Brute force</a></h1>
<p>\( i \) is a factor of \( n \) if \( n\ \equiv\ 0\ [i] \), in our case it
is enough to iterate over each number. When a factor is found, we simply divide
\( n \) by that factor and continue as long as \( n \) is greater than one.
When \( n \) is equal to one, we simply return the current factor which is
also the largest.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0003/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_prime_factor(n=600851475143):
    res = 2
    while n != 1:
        if n % res == 0:
            n //= res
        else:
            res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-by-two"><a class="header" href="#two-by-two">Two by Two</a></h1>
<p>Since all primes except 2 are odd and in our case 2 is not a factor of
600851475143, we can start with 3 and iterate two by two, which is not a great
improvement, but this problem has no interesting solution anyway.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0003/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_prime_factor(n=600851475143):
    res = 3
    while n != 1:
        if n % res == 0:
            n //= res
        else:
            res += 2

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-2"><a class="header" href="#solution-2">Solution</a></h1>
<hr />
<blockquote>
<p>6857</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-palindrome-product"><a class="header" href="#largest-palindrome-product"><a href="https://projecteuler.net/problem=4">Largest palindrome product</a></a></h1>
<blockquote>
<p>A palindromic number reads the same both ways. The largest palindrome made from the product of two \( 2 \)-digit numbers is \( 9009=91×99 \).</p>
<p>Find the largest palindrome made from the product of two \( 3 \)-digit numbers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-3"><a class="header" href="#brute-force-3">Brute force</a></h1>
<p>We are searching the largest palindrome made from the product of two 3-digit
numbers. Firstly, it is necessary to know when a number is a palindrome. This
can be done easily using python iteration.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_palindrome(n):
    return str(n) == str(n)[::-1]
</code></pre>
<p>A better solution exists using modulus and division, but performance is not the
goal here.</p>
<p>The range of 3-digit numbers is \( [100; 999] \), the naive solution will
consist in simply iterate over each number and check which product is the
largest palindrome. A little trick: if \( 100 * 200 \) does not work, \(
200 * 100 \) won't work either, so the second loop starts from the current
number of the first one.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_palindrome_product():
    res = 0
    for x in range(100, 1000):
        for y in range(x, 1000):
            if x * y &gt; res and is_palindrome(x * y):
                res = x * y

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorisation-is-the-key"><a class="header" href="#factorisation-is-the-key">Factorisation is the key</a></h1>
<p>We know that the researched number is larger than \( 100*100 = 10000 \)
and smaller than \( 999*999 = 998001 \). So it must be of the form \(
abcba \) or \( abccba \). Let's assume it is of the form \( abccba \), if
it does not work, we'll try with \( abcba \).</p>
<p>\( abccba = 10001a + 10010b + 1100c = 11(9091a + 910b + 100c) \) which means
that the palindrome must be divisible by 11. Since 11 is prime, either \(
100001a \), \( 10010b \) or \( 1100c \) is a multiple of 11, which is why
the iteration can be done 11 by 11.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_palindrome_product():
    res = 0
    for x in range(110, 1000, 11):
        for y in range(x, 1000):
            if x * y &gt; res and is_palindrome(x * y):
                res = x * y

    return res
</code></pre>
<p>We went from 405450 iterations with the <a href="problems/problem_0004/solution1.html">Brute force</a> to 36450
iterations !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-pen-and-paper"><a class="header" href="#with-pen-and-paper">With pen and paper</a></h1>
<p>In <a href="problems/problem_0004/solution2.html">Factorisation is the key</a>, we assume that the number was of
the form \( abccba \). Since it is the factor of two 3-digit number, we have :</p>
<p>\[ \begin{align} abccba &amp;= (100a + 10b + c)(100d + 10e + f)\\ &amp;= 10000ad + 1000(bd + ae) + 100(cd + be + af) + 10(ce + bf) + cf \end{align} \]</p>
<p>Assuming the first digit is 9, then \( cf \) must be equal to 9 as well.</p>
<p>The only ways to make the last digit nine are:</p>
<p>\[ 1 * 9\\ 3 * 3\\ 7 * 7 \]</p>
<p>Thus, both number must start with 9 and end with either 1, 3, 7 or 9. We also
know that \( 100a + 10b + c \) or \( 100d + 10e + f \) is divisible by 11.
The only numbers divisible by 11 and ending with 1, 3, 7 or 9 in the
\( [900; 999]
\) are :</p>
<p>\[ 913\\ 957\\ 979 \]</p>
<p>This give us:</p>
<p>\[ \text{a = 9}\\ \text{b = 1, 5 or 7}\\ \text{c = 3, 7 or 9}\\ \]</p>
<p>Resulting in the numbers:</p>
<p>\[
(900 + 10 + 3)(900 + 10e + 3) = 824439 + 9130x\\
(900 + 50 + 7)(900 + 10e + 7) = 867999 + 9570x\\
(900 + 70 + 9)(900 + 10e + 1) = 882079 + 9790x \]</p>
<p>The first number implies that \( e \) is equal to 9 because if \( e \) was
equal to 8, then \(824439 * 9130 * 8 = 897479 \) would not start with 9.
With \( e = 9 \) we have \( 913 * 993 \) which is the correct answer. Both
\( (900 + 50 + 7)(900 + 10e + 7) \) and \( (900 + 70 + 9)(900 + 10e + 1) \)
give smaller palindrome.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-3"><a class="header" href="#solution-3">Solution</a></h1>
<hr />
<blockquote>
<p>906609</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="smallest-multiple"><a class="header" href="#smallest-multiple"><a href="https://projecteuler.net/problem=5">Smallest multiple</a></a></h1>
<blockquote>
<p>\( 2520 \) is the smallest number that can be divided by each of the numbers from \( 1 \) to \( 10 \) without any remainder.</p>
<p>What is the smallest positive number that is <em>evenly divisible</em> by all of the numbers from \( 1 \) to \( 20 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-4"><a class="header" href="#brute-force-4">Brute force</a></h1>
<p>As always, the brute force solution is quite simple, first determine if a number
is evenly divisible by all numbers from 1 to 20.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_evenly_divisible(n):
    for i in range(1, 21):
        if n % i != 0:
            return False

    return True
</code></pre>
<p>Then iterate until you find a solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def smallest_multiple():
    i = 1
    while not is_evenly_divisible(i):
        i += 1

    return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-factorization"><a class="header" href="#prime-factorization">Prime factorization</a></h1>
<p>The <a href="problems/problem_0005/solution2.html">Brute force</a> is actually very slow. A better solution can be
found using prime factorization. The key is to understand that when \( x \)
divides \( y \) evenly, it is because the prime factors of \( x\) are
contained in \( y \). For example, \( 20 = 2^2 * 5 \) which means that a
number divisible by 20 is also divisible by 2, 4 and 5.</p>
<p>Calculating the prime factorization of each number from 1 to 20 give us:</p>
<p>\[\begin{align} 20 &amp;= 2^2 * 5\\ 19 &amp;= 19\\ 18 &amp;= 2 * 3^2\\ 17 &amp;= 17\\ 16 &amp;= 2^4\\ 15 &amp;= 3 * 5\\ 14 &amp;= 2 * 7\\ 13 &amp;= 13\\ 12 &amp;= 2^2 * 3\\ 11 &amp;= 11\\ \end{align} \]</p>
<p>We can stop here, because 10 is included in 20, 9 in 18, 8 in 16, 7 in 14, 6 in
12, 5 in 20, 4 in 20, 3 in 18, 2 in 20 and 1 in 20.</p>
<p>It gives us the answer: \( 2^4 * 3^2 * 5 * 7 * 11 * 13 * 17 * 19 =
232792560 \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="least-common-multiple"><a class="header" href="#least-common-multiple">Least common multiple</a></h1>
<p>Actually, the problem is to find
the <a href="https://en.wikipedia.org/wiki/Least_common_multiple#Reduction_by_the_greatest_common_divisor">least common multiple</a>
which is:</p>
<p>\[ LCT(1, 2, ..., N) \]</p>
<p>To find the \( LCT \) of \( 1 \) through \( N \), we need all the primes
\( \leqslant N \). For each prime, we need its maximum power that won't exceed
\( N \). Which can be done easily using logarithms:</p>
<p>\[ \begin{align} p^{k} &amp;\leqslant N\\ k\log( p) &amp;\leqslant \log( N)\\ k&amp;=\left\lfloor \frac{\log( N)}{\log( p)}\right\rfloor\\ \end{align} \]</p>
<p>So the \( LCT \) of \( 1 \) through \( N \) is:</p>
<p>\[ \prod p^{\left\lfloor \frac{\log(N)}{\log(p)} \right\rfloor } \]</p>
<p>We also know that it's pointless to search the maximum power of primes greater
than \( \sqrt{n} \) because it will always be 1.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def smallest_multiple(n=20):
    # Returns a list of all primes &lt;= n
    primes = sieve.primerange(n + 1)
    sqrt_n, log_n = sqrt(n), log(n)
    res = 1
    for p in primes:
        if p &lt; sqrt_n:
            res *= p ** (floor(log_n / log(p)))
        else:
            res *= p

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-4"><a class="header" href="#solution-4">Solution</a></h1>
<hr />
<blockquote>
<p>232792560</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="sum-square-difference"><a class="header" href="#sum-square-difference"><a href="https://projecteuler.net/problem=6">Sum square difference</a></a></h1>
<blockquote>
<p>The sum of the squares of the first ten natural numbers is,</p>
<p>\[
1^2 + 2^2 + ... + 10^2 = 385
\]</p>
<p>The square of the sum of the first ten natural numbers is,</p>
<p>\[
(1 + 2 + ... + 10)^2 = 55^2 = 3025
\]</p>
<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is \( 3025-385=2640 \).</p>
<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-5"><a class="header" href="#brute-force-5">Brute force</a></h1>
<p>Finding the difference between the sum of the squares and the square of the sum
required two steps:</p>
<p>Find the sum of the squares:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_squares(n):
    return sum(i**2 for i in range(1, n + 1))
</code></pre>
<p>And the square of the sum:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def square_of_sum(n):
    return sum(i for i in range(1, n + 1)) ** 2
</code></pre>
<p>Finally, just subtract the square of the sum by the sum of the squares:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_square_difference(n=100):
    return square_of_sum(n) - sum_of_squares(n)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-formula"><a class="header" href="#summation-formula">Summation formula</a></h1>
<p>We learned in <a href="problems/problem_0006/../problem_0001/problem.html">Problem 1: Multiples of 3 and 5</a>
that:</p>
<p>\[ \sum{k} = \frac{n(n+1)}{2} \]</p>
<p>This gives the following formula for the square of the sum:</p>
<p>\[ (1+2+...+10)^2 = \left(\sum{k}\right)^2 = \left(\frac{n(n+1)}{2}\right)^2 = \frac{n^2 (n+1)^2}{4} \]</p>
<p>The sum of the squares can be found using the formula:</p>
<p>\[ \sum{k^2} = \frac{n(n+1)(2n+1)}{6} \]</p>
<p>There are many demonstrations to prove this equation, let's just look at one of
them:</p>
<p>\[ \begin{align} ( k-1)^{3} &amp;=k^{3} -3k^{2} +3k-1\\ k^{3} -( k-1)^{3} &amp;=3k^{2} -3k+1\\ \sum _{k=1}^{n}\left( k^{3} -( k-1)^{3}\right) &amp;=\sum _{k=1}^{n} 3k^{2} -3k+1 \\ \sum _{k=1}^{n} k^{3} -\sum _{k=1}^{n}( k-1)^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\sum _{k=1}^{n} k+\sum _{k=1}^{n} 1\\ \sum _{k=1}^{n} k^{3} -\sum _{k=0}^{n-1} k^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\frac{n( n+1)}{2} +n\\ n^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\frac{n( n+1)}{2} +n\\ \sum _{k=1}^{n} k^{2} &amp;=\frac{1}{3} n^{3} +\frac{n( n+1)}{2} -\frac{1}{3} n\\ \sum _{k=1}^{n} k^{2} &amp;=\frac{n( n+1)( 2n+1)}{6} \end{align} \]</p>
<p>The solution can be found in constant time with these two equations:</p>
<p>\[ \frac{n^2(n+1)^2}{4} - \frac{n(n+1)(2n+1)}{6} = \frac{3n^4+2n^3-3n^2-2n}{12} \]</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_square_difference(n=100):
    return (3 * n**4 + 2 * n**3 - 3 * n**2 - 2 * n) // 12
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-5"><a class="header" href="#solution-5">Solution</a></h1>
<hr />
<blockquote>
<p>25164150</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="10001st-prime"><a class="header" href="#10001st-prime"><a href="https://projecteuler.net/problem=7">10001st prime</a></a></h1>
<blockquote>
<p>By listing the first six prime numbers: \( 2 \), \( 3 \), \( 5 \), \( 7 \), \( 11 \), and \( 13 \), we can see that the \( 6 \)th prime is \( 13 \).</p>
<p>What is the \( 10001 \)st prime number?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-6"><a class="header" href="#brute-force-6">Brute force</a></h1>
<p>A well known and fast way to generate primes is the
<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>.
The only problem is that we need an upper bound, which is not the case here
since we don't know the size of the 10001st prime.</p>
<p>We will have to test the primality of each number, if it is prime, then we store
it, otherwise we continue with the next number until the list of prime numbers
that we stored contains 10001 elements. The last one being the answer.</p>
<p>To determine the primality of a number, we can check if one of the preceding
primes can divide it, if not, the number is prime.</p>
<p>Since even number can not be prime, we can go two by two just like
the <a href="problems/problem_0007/../problem_0003/solution2.html">Two by Two</a> solution
of <a href="problems/problem_0007/../problem_0003/problem.html">Problem 3: Largest prime factor</a>.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    i = 3
    primes = [2]
    while len(primes) &lt; n:
        if all(i % p != 0 for p in primes):  # No divisor in the previous prime.
            primes.append(i)
        i += 2

    return primes[-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="almost-six-by-six"><a class="header" href="#almost-six-by-six">Almost six by six</a></h1>
<p>Actually, it is possible to speed up a little the previous program knowing that
every prime \( n &gt; 3 \) is of the form :</p>
<p>\[ 6k+1 \text{ or } 6k-1 \]</p>
<p>Let's try to persuade ourselves that this is true. All prime numbers are of the
form:</p>
<p>\[ 6k - 1\\ 6k\\ 6k+1\\ 6k+2\\ 6k+3\\ 6k+4\\ \]</p>
<p>Nothing amazing, but as we are looking for prime number, we can remove some of
them :</p>
<p>\( 6k \), \( 6k + 2 \) and \( 6k + 4 \) are even number, so they cannot be
prime.</p>
<p>\( 6k + 3 = 3(3k + 1) \) which is divisible by 3 and thus not prime
(except 3).</p>
<p>Which let us with: \( 6k + 1 \) and \( 6k - 1 \).</p>
<p>Thus, we can rewrite the old program to check only those numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    i = 1
    primes = [2, 3]
    while len(primes) &lt; n:
        if all((6 * i - 1) % p != 0 for p in primes):
            primes.append(6 * i - 1)
        if all((6 * i + 1) % p != 0 for p in primes):
            primes.append(6 * i + 1)
        i += 1

    return primes[n - 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-number-theorem"><a class="header" href="#prime-number-theorem">Prime number theorem</a></h1>
<p>As I said in the <a href="problems/problem_0007/solution1.html">Brute force</a> solution, the fasted way to
generate primes is the sieve of eratosthenes, but it requires an upper bound. We
can not find the exact upper bound, but we can have a good approximation using
the <a href="https://en.wikipedia.org/wiki/Prime_number_theorem">Prime number theorem</a>:</p>
<p>\[  \pi(N) \sim \frac{N}{\log(N)} \]</p>
<p>Where \( \pi(N) \) is the
<a href="https://en.wikipedia.org/wiki/Prime-counting_function">prime-counting function</a>
.</p>
<p>This function give the number of primes \( M \) less than or equal to \( N
\), in our case we want to determine \( N \) knowing \( M \). Which give us
another formula:</p>
<p>\[ \begin{align} \frac{N}{\log(N)} &amp;\leqslant M\\ \frac{\log(N)}{N} &amp;\leqslant \frac{1}{M}\\ -\frac{\log(N)}{N} &amp;\leqslant -\frac{1}{M}\\ -\frac{\log(N)}{e^{\log(N)}} &amp;\leqslant -\frac{1}{M}\\ -\log(N)e^{-\log(N)} &amp;\leqslant -\frac{1}{M} \end{align} \]</p>
<p>The <a href="https://en.wikipedia.org/wiki/Lambert_W_function">Lambert \( W \) function</a>
says that \( we^w = z \Leftrightarrow w = \mathit{W}_{k}(z) \). This give us:</p>
<p>\[ \begin{align} -\log( N) e^{-\log( N)} &amp;\leqslant -\frac{1}{M}\\ -\log( N) &amp;\leqslant W_{k}\left( -\frac{1}{M}\right)\\ N &amp;\leqslant e^{-W_{k}\left( -\frac{1}{M}\right)} \end{align} \]</p>
<p>The solutions of Lambert's \( W \) function with real number can be found with
ony two branches: \( W_0 \) and \( W_{-1} \) suffice.</p>
<p>For real number \( z \) and \( w \) the equation \( we^w = z \) can be
solved for \( w \) only if \( w \geqslant -\frac{1}{e} \). if \( z
\geqslant 0 \) we get \( w = W_0(z) \) and the two values \( w = W_0(z) \)
and \( w = W_{-1}(z) \) if \( -\frac{1}{e} \leqslant w &lt; 0 \).</p>
<p>We have \( w = -\log(N) \) so we are in the second case. We need to determine
which of \(W_0(z) \) and \( W_{-1}(z) \) is the right formula.</p>
<p>The branch 0 converge to 1 when \( z \) converge to 0. Actually, for \( M &gt;
3 \) we have \( \lceil W_k(-\frac{1}{M}) \rceil = 1\). It implies that the
good branch is -1.</p>
<p>We can actually build the sieve of eratosthenes with the upper bound \( e^ {-W_
{-1}(-\frac{1}{M})} \). Lambert's \( W \) function cannot be expressed in
terms of
<a href="https://en.wikipedia.org/wiki/Elementary_function">elementary functions</a>, so
the formula cannot be simplified. The value of Lambert's \( W \) function
requires an iterative method to be found, as this is quite a difficult problem
we will use the
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lambertw.html">lambertw</a>
from <a href="https://docs.scipy.org/doc/scipy/index.html">scipy</a> to determine our upper
bound.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    if n &lt; 3:
        return [2, 3][n - 1]

    limit_pi_1 = ceil(exp(-lambertw(-1 / n, -1).real))
    primes = sieve.primerange(limit_pi_1 + 1)

    return next(islice(primes, n - 1, n))
</code></pre>
<p>Note that <code>sieve.primerange</code> returns a <code>generator</code>, so we use slice to get the
n-th element.</p>
<p>When \( N &lt; 3 \), we have \( -\log(N) \geqslant -\frac{1}{e} \) which means
the Lambert's W function has no solution. We can simply hard-code the case of 1
and 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-6"><a class="header" href="#solution-6">Solution</a></h1>
<hr />
<blockquote>
<p>104743</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-series"><a class="header" href="#largest-product-in-a-series"><a href="https://projecteuler.net/problem=8">Largest product in a series</a></a></h1>
<blockquote>
<p>The four adjacent digits in the \( 1000 \)-digit number that have the greatest product are \( 9×9×8×9=5832 \).</p>
<p>\[
73167176531330624919225119674426574742355349194934\\
96983520312774506326239578318016984801869478851843\\
85861560789112949495459501737958331952853208805511\\
12540698747158523863050715693290963295227443043557\\
66896648950445244523161731856403098711121722383113\\
62229893423380308135336276614282806444486645238749\\
30358907296290491560440772390713810515859307960866\\
70172427121883998797908792274921901699720888093776\\
65727333001053367881220235421809751254540594752243\\
52584907711670556013604839586446706324415722155397\\
53697817977846174064955149290862569321978468622482\\
83972241375657056057490261407972968652414535100474\\
82166370484403199890008895243450658541227588666881\\
16427171479924442928230863465674813919123162824586\\
17866458359124566529476545682848912883142607690042\\
24219022671055626321111109370544217506941658960408\\
07198403850962455444362981230987879927244284909188\\
84580156166097919133875499200524063689912560717606\\
05886116467109405077541002256983155200055935729725\\
71636269561882670428252483600823257530420752963450
\]</p>
<p>Find the thirteen adjacent digits in the \( 1000 \)-digit number that have the greatest product. What is the value of this product?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-7"><a class="header" href="#brute-force-7">Brute force</a></h1>
<p>We are searching for the largest product of 13 adjacent digits in a 1000-digit
number. We want to calculate the product of each 13 adjacent digits and find the
largest one.</p>
<p>The 1000-digit number will be stored in a file, so the first step is to get this
number as a string and remove each trailing newline (\n):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return file.read().replace(&quot;\n&quot;, &quot;&quot;)
</code></pre>
<p>Given this string, we need to calculate the product of 13 adjacent digits, which
can be done easily
using <a href="https://docs.python.org/3/library/math.html#math.prod">math.prod()</a>.
Then, simply repeat this step for all 13 adjacent digits contained in the
1000-digit number and save the maximum of these products.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_product_in_series(n, adj=13):
    res = 0
    for i in range(len(n) - adj):
        res = max(prod(int(digit) for digit in n[i : i + adj]), res)

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0-are-useless"><a class="header" href="#0-are-useless">0 are useless</a></h1>
<p>The problem requires calculating a product, a product of something and 0 will
always give a result of 0. Which means that every 13 adjacent digits containing
0 are useless since the result will never be the largest product.</p>
<p>The 1000-digit number can actually be split around each 0, of course if a number
has less than 13 digits it can be deleted.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def split_series(n):
    return [sub_n for sub_n in n.split(&quot;0&quot;) if len(sub_n) &gt;= 13]
</code></pre>
<p>Another improvement reside in not calculating every product from the start, for
example if we search the product of 3 adjacent digits in 12345, the 3 solutions
are:</p>
<pre><code class="language-python">1*2*3     = 6
  2*3*4   = (6 / 1) * 4 = 24
    3*4*5 = (24 / 3) * 5 = 60
</code></pre>
<p>The second product is the same as the first, just divide the digit that is not
present and multiply the one that is. We have to be careful with the digit 0
because division by 0 is an error, but we have already solved the problem just
before, so we can assume our number will never contain the digit 0.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_product_in_series(n, adj=13):
    res = 0
    current = prod(int(digit) for digit in n[0:adj])
    for i in range(len(n) - adj):
        current = (current // int(n[i])) * int(n[i + adj])
        res = max(res, current)

    return res
</code></pre>
<p>We simply repeat this step for each sub-number of the 1000-digit split around 0.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_product_in_multiples_series(sub_n, adj=13):
    res = 0
    for n in sub_n:
        res = max(largest_product_in_series(n, adj), res)
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-7"><a class="header" href="#solution-7">Solution</a></h1>
<hr />
<blockquote>
<p>23514624000</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-pythagorean-triplet"><a class="header" href="#special-pythagorean-triplet"><a href="https://projecteuler.net/problem=9">Special Pythagorean triplet</a></a></h1>
<blockquote>
<p>A Pythagorean triplet is a set of three natural numbers, \( a&lt;b&lt;c \), for which,</p>
<p>\[
a^{2} + b^{2} = c^{2}
\]</p>
<p>For example, \( 3^{2}+4^{2}=9+16=25=5^{2} \).</p>
<p>There exists exactly one Pythagorean triplet for which \( a+b+c=1000 \).
Find the product \( abc \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-8"><a class="header" href="#brute-force-8">Brute force</a></h1>
<p>We are searching for \( a \), \( b \) and \( c \) such that \( a &lt; b
&lt; c \), \( a + b + c = 1000 \) and \( a^2 + b^2 = c^2 \). The brute force
solution will simply iterate to 1000 for \( a \), \( b \)
and \( c \) and stop when the above equations are true.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for a in range(1001):
        for b in range(a + 1, 1001):
            for c in range(b + 1, 1001):
                if a + b + c == 1000 and a**2 + b**2 == c**2:
                    return a * b * c

    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-a-little-thought"><a class="header" href="#with-a-little-thought">With a little thought</a></h1>
<p>The <a href="problems/problem_0009/solution1.html">Brute force solution</a> can be simplified a bit knowing that
\( a + b + c = 1000 \) implies \( c = 1000 - a - b \). This removes a for
loop and an equation, since \( a + b + c = 1000 \) will always be true.</p>
<p>Another simplification can be made by knowing that \( a &lt; b &lt; c \). This
implies that \( a \), \( b \) and \( c \) are lower than 500, otherwise
\( a + b + c \) will be greater than 1000.</p>
<p>This gives us the following :</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for a in range(501):
        for b in range(a + 1, 501):
            c = 1000 - a - b
            if a**2 + b**2 == c**2:
                return a * b * c

    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-pythagorean-triples"><a class="header" href="#prime-pythagorean-triples">Prime Pythagorean triples</a></h1>
<p>Given an arbitrary pair of integers m and n with m &gt; n &gt; 0. Euclid's formula
states that the integers :</p>
<p>\[ a = m^2 - n^2,\ b=2mn,\ c=m^2+n^2 \]</p>
<p>form a Pythagorean triple: \( a^2 + b^2 = c^2 \)</p>
<p>If we calculate \( a^2 + b ^2 \):</p>
<p>\[ a^2 + b^2 = (m^2-n^2)^2 + (2mn)^2 = m^2 + 4m^2n^2 - 2m^2n^2 + n^2 = (m^2 + n^2)^2 = c^2 \]</p>
<p>Which is coherent, the problem changes from finding \( a \), \( b \) and \(
c \) to finding \( m \) and \( n \), we have:</p>
<p>\[ \begin{align} a+b+c &amp;= 1000\\ 2mn + 2m^2 &amp;= 1000\\ n &amp;= \frac{500}{m} - m\\ \end{align} \]</p>
<p>We have \( m &gt; n \) since b must be positive, solving \( n = m \) gives:</p>
<p>\[ \begin{align} m &amp;= \frac{500}{m} - m\\ 0 &amp;= \frac{500 - 2m^2}{m}\\ 0 &amp;= 500 - 2m^2\\ m &amp;= \sqrt(250)\\ \end{align} \]</p>
<p>Resulting in:</p>
<p>\[ m &gt; 16 &gt; \sqrt(250) \]</p>
<p>We also have \( n &gt; 0 \), solving \( n = 0 \) gives:</p>
<p>\[ \begin{align} 0 &amp;= \frac{500}{m} - m\\ 0 &amp;= 500 - m^2\\ m &amp;= \sqrt(500)\\ \end{align} \]</p>
<p>Resulting in:</p>
<p>\[ m &lt; \sqrt(500) &lt; 23 \]</p>
<p>We also know that \( \frac{500}{m} \) is an integer, so m must divide \(
500 \). The only multiple of that divides \( 500 \) with the constraint \(
16 &gt; m &gt; 23 \) is 20. Having \( m = 20 \) result in \( n = 5 \). It gives
\( a = 200 \), \( b = 375 \) and \( c \) = 425.</p>
<p>The solution can also be found by using a for loop to find \( m \) and \(
n \) with the above constraints.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for m in range(16, 24):
        for n in range(1, m):
            if m * (n + m) == 500:
                return 2 * m * n * (m**4 - n**4)

    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-8"><a class="header" href="#solution-8">Solution</a></h1>
<hr />
<blockquote>
<p>31875000</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-of-primes"><a class="header" href="#summation-of-primes"><a href="https://projecteuler.net/problem=10">Summation of primes</a></a></h1>
<blockquote>
<p>The sum of the primes below \( 10 \) is \( 2+3+5+7=17 \).</p>
<p>Find the sum of all the primes below two million.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-9"><a class="header" href="#brute-force-9">Brute force</a></h1>
<p>We already know, thanks to te previous problems that when one search for all
prime numbers below a certain limit, the sieve of eratosthenes is a good
solution.</p>
<p>It is enough to sum the list of the primes found with the sieve.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def summation_of_primes(limit=2000000):
    return sum(sieve.primerange(limit))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-minus-summation"><a class="header" href="#summation-minus-summation">Summation minus summation</a></h1>
<p>The sieve of eratosthenes is actually quite slow, it's possible to find a better
solution if we consider that we don't need to know all the primes to find their
sum. For example, the sum of the primes less than \( 10 \) is \( 2 + 3 + 5 +
7 = 17 \).</p>
<p>The sum of the primes less than \( 10 \) is the sum of the numbers less than
10 minus the sum of the multiples of the primes less than \( \sqrt{10} \)
plus the primes themselves minus \( 1 \). In this example, the sum of the
multiples of \( 2 \) and \( 3 \):</p>
<p>\[ \begin{alignat}{1} P &amp;&amp;= &amp;&amp;+1&amp;&amp;+2&amp;&amp;+3&amp;&amp;+4&amp;&amp;+5&amp;&amp;+6+7&amp;&amp;+8&amp;&amp;+9&amp;&amp;+10\\ &amp;&amp;&amp;&amp;&amp;&amp;-2&amp;&amp;&amp;&amp;-4&amp;&amp;&amp;&amp;-6&amp;&amp;-8&amp;&amp;&amp;&amp;-10\\ &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;-3&amp;&amp;&amp;&amp;&amp;&amp;-6&amp;&amp;&amp;&amp;-9\\ &amp;&amp;&amp;&amp;-1&amp;&amp;+2&amp;&amp;+3\\ P &amp;&amp;= &amp;&amp;&amp;&amp;+2&amp;&amp;+3&amp;&amp;&amp;&amp;+5&amp;&amp;-6+7\\ \end{alignat} \]</p>
<p>There is just one problem, the number \( 6 \) is both a multiple of \( 2 \)
and \( 3 \). This means we have to remove the multiple of \( 3 \) but not
the multiple of \( 6 \). For numbers larger than 10, if we continue with \( 5
\) we have to remove the multiple of \( 5 \) but not the multiple of \(
2*5=10 \), \( 3*5=15 \) and \( 5*6=30 \).</p>
<p>Let \( \phi(n) \) be the sum of the numbers less than \( n \).</p>
<p>We have the following sequence:</p>
<p>\[ \begin{align} T_0(n) &amp;= \phi(\left\lfloor n \right\rfloor) &amp;&amp;= 1+2+3+\dots\\ T_1(n) &amp;= 2\left(T_0\left(\frac{n}{2}\right)\right) = 2\phi\left (\left\lfloor \frac{n} {2} \right\rfloor \right) &amp;&amp;= 2+4+6+\dots\\ T_2(n) &amp;= 3\left(T_0\left(\frac{n}{3}\right) - T_1\left(\frac{n}{3}\right) \right) = 3\phi \left(\left\lfloor \frac{n}{3} \right\rfloor\right) - 6\phi\left(\left\lfloor \frac{n}{6} \right\rfloor\right) &amp;&amp;= 3+9+15+\dots\\ T_3(n) &amp;= 5\left(T_0\left(\frac{n}{5}\right) - T_1\left(\frac{n}{5}\right) - T_2\left(\frac{n}{5}\right) \right) = 5\phi\left(\left\lfloor\frac{n}{5}\right\rfloor\right) - 10\phi\left(\left\lfloor\frac{n}{10}\right\rfloor\right) - 15\phi\left(\left\lfloor\frac{n}{15} \right\rfloor\right) + 30\phi\left(\left\lfloor\frac{n}{30} \right\rfloor\right) &amp;&amp;= 5+25+35+\dots\\ \end{align} \]</p>
<p>So the k-th term is:</p>
<p>\[ T_k(n) = p_k\left(T_0\left(\frac{n}{p_k}\right) - \dots - T_{k-1}\left (\frac{n} {p_k}\right)\right) \]</p>
<p>Where \( p_k \) is the k-th prime.</p>
<p>We can create a function to find \( T_k \) if we have \( p_k \):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def tk(n, k, primes):
    pk = primes[k - 1]
    t0 = phi(floor(n / pk))
    tn = sum(tk(n / pk, i, primes) for i in range(1, k))
    return pk * (t0 - tn)
</code></pre>
<p>The sum of the primes less than \( n \) is the sum of the numbers less than
\( n \) minus the sum of all the multiples of the primes less than \( \sqrt
{n} \) plus the primes themselves minus \( 1 \):</p>
<p>\[ \left(T_0(n) - T_1(n) - \dots - T_k(n)\right) + \left(p_1 + p_2 + \dots + p_k\right) - 1 \]</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def summation_of_primes(limit=2000):
    primes = list(sieve.primerange(floor(sqrt(limit)) + 1))

    return phi(limit) - sum(tk(limit, i + 1, primes) for i in range(len(primes))) + sum(primes) - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0010/solution2.html">Summation minus summation</a> solution gives an interesting
solution because we found the sum of the primes less than \( n \) with only
the primes less than \( \sqrt{n} \). Unfortunately, this solution is not
efficient because it requires too much recursion for larger n.</p>
<p>The main problem with the previous solution was to remove the numbers that were
multiples of previous primes. For example with the multiples of \( 3 \), the
number \( 6 \) was already removed by the multiples of \( 2 \).</p>
<p>What we really want is to remove the multiples of \( 3 \) that have not
already been removed by the multiples of \( 2 \) such as \( 6 \), \( 12 \)
... For \( 5 \) that would be the number that are neither multiples of \( 2
\) nor \( 3 \).</p>
<p>Instead of the sum of the multiples of a prime, we will search for the sum of
integer that remain after sieving with all primes smaller than the current one.</p>
<p>This solution is well explained by <strong>Lucy_Hedgehog</strong> in this
<a href="https://projecteuler.net/thread=10;page=5#111677">thread</a> (only available if
you solve the problem):</p>
<blockquote>
<p>The main idea is as follows: Let \( S(v,m) \) be the sum of integers in the
range \( 2 \dots v \) that remain after sieving with all primes smaller or
equal than \( m \). That is \( S(v,m) \) is the sum of integers up to
\( v \) that are either prime or the product of primes larger than \( m
\).</p>
<p>\( S(v, p) \) is equal to \(S(v, p-1) \) if \( p \) is not prime or
\( v \) is smaller than \( p*p \). Otherwise (\( p \) prime, \(
p*p\leqslant v \)) \( S(v,p) \) can be computed from \(S(v, p-1)\)
by finding the sum of integers that are removed while sieving with \( p
\). An integer is removed in this step if it is the product of \(p \)
with another integer that has no divisor smaller than \(p \). This can
be expressed as</p>
<p>\[ S\left(v, p \right) = S\left(v, p - 1\right) - p\left(S\left(\frac{v}{p},
p - 1\right) -S\left(p-1, p-1\right)\right) \]</p>
<p>Dynamic programming can be used to implement this. It is sufficient to
compute \( S(v,p) \) for all positive integers \( v \) that are
representable as \( \left\lfloor\frac{n}{k}\right\rfloor \) for some
integer \( k \) and all.</p>
</blockquote>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def partial_prime_sum(n=2000000):
    r = ceil(sqrt(n))
    V = [n // i for i in range(1, r + 1)]
    V += list(range(V[-1] - 1, 0, -1))
    S = {i: i * (i + 1) // 2 - 1 for i in V}
    for p in range(2, r + 1):
        if S[p] &gt; S[p - 1]:  # p is prime
            sp = S[p - 1]  # sum of primes smaller than p
            p2 = p * p
            for v in V:
                if v &lt; p2:
                    break
                S[v] -= p * (S[v // p] - sp)
    return S[n]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-9"><a class="header" href="#solution-9">Solution</a></h1>
<hr />
<blockquote>
<p>142913828922</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-grid"><a class="header" href="#largest-product-in-a-grid"><a href="https://projecteuler.net/problem=11">Largest product in a grid</a></a></h1>
<blockquote>
<p>In the \( 20×20 \) grid below, four numbers along a diagonal line have been marked in red.</p>
<p>\[
08\ 02\ 22\ 97\ 38\ 15\ 00\ 40\ 00\ 75\ 04\ 05\ 07\ 78\ 52\ 12\ 50\ 77\ 91\ 08\\
49\ 49\ 99\ 40\ 17\ 81\ 18\ 57\ 60\ 87\ 17\ 40\ 98\ 43\ 69\ 48\ 04\ 56\ 62\ 00\\
81\ 49\ 31\ 73\ 55\ 79\ 14\ 29\ 93\ 71\ 40\ 67\ 53\ 88\ 30\ 03\ 49\ 13\ 36\ 65\\
52\ 70\ 95\ 23\ 04\ 60\ 11\ 42\ 69\ 24\ 68\ 56\ 01\ 32\ 56\ 71\ 37\ 02\ 36\ 91\\
22\ 31\ 16\ 71\ 51\ 67\ 63\ 89\ 41\ 92\ 36\ 54\ 22\ 40\ 40\ 28\ 66\ 33\ 13\ 80\\
24\ 47\ 32\ 60\ 99\ 03\ 45\ 02\ 44\ 75\ 33\ 53\ 78\ 36\ 84\ 20\ 35\ 17\ 12\ 50\\
32\ 98\ 81\ 28\ 64\ 23\ 67\ 10\ \color{red}{26}\ 38\ 40\ 67\ 59\ 54\ 70\ 66\ 18\ 38\ 64\ 70\\
67\ 26\ 20\ 68\ 02\ 62\ 12\ 20\ 95\ \color{red}{63}\ 94\ 39\ 63\ 08\ 40\ 91\ 66\ 49\ 94\ 21\\
24\ 55\ 58\ 05\ 66\ 73\ 99\ 26\ 97\ 17\ \color{red}{78}\ 78\ 96\ 83\ 14\ 88\ 34\ 89\ 63\ 72\\
21\ 36\ 23\ 09\ 75\ 00\ 76\ 44\ 20\ 45\ 35\ \color{red}{14}\ 00\ 61\ 33\ 97\ 34\ 31\ 33\ 95\\
78\ 17\ 53\ 28\ 22\ 75\ 31\ 67\ 15\ 94\ 03\ 80\ 04\ 62\ 16\ 14\ 09\ 53\ 56\ 92\\
16\ 39\ 05\ 42\ 96\ 35\ 31\ 47\ 55\ 58\ 88\ 24\ 00\ 17\ 54\ 24\ 36\ 29\ 85\ 57\\
86\ 56\ 00\ 48\ 35\ 71\ 89\ 07\ 05\ 44\ 44\ 37\ 44\ 60\ 21\ 58\ 51\ 54\ 17\ 58\\
19\ 80\ 81\ 68\ 05\ 94\ 47\ 69\ 28\ 73\ 92\ 13\ 86\ 52\ 17\ 77\ 04\ 89\ 55\ 40\\
04\ 52\ 08\ 83\ 97\ 35\ 99\ 16\ 07\ 97\ 57\ 32\ 16\ 26\ 26\ 79\ 33\ 27\ 98\ 66\\
88\ 36\ 68\ 87\ 57\ 62\ 20\ 72\ 03\ 46\ 33\ 67\ 46\ 55\ 12\ 32\ 63\ 93\ 53\ 69\\
04\ 42\ 16\ 73\ 38\ 25\ 39\ 11\ 24\ 94\ 72\ 18\ 08\ 46\ 29\ 32\ 40\ 62\ 76\ 36\\
20\ 69\ 36\ 41\ 72\ 30\ 23\ 88\ 34\ 62\ 99\ 69\ 82\ 67\ 59\ 85\ 74\ 04\ 36\ 16\\
20\ 73\ 35\ 29\ 78\ 31\ 90\ 01\ 74\ 31\ 49\ 71\ 48\ 86\ 81\ 16\ 23\ 57\ 05\ 54\\
01\ 70\ 54\ 71\ 83\ 51\ 54\ 69\ 16\ 92\ 33\ 48\ 61\ 43\ 52\ 01\ 89\ 19\ 67\ 48
\]</p>
<p>The product of these numbers is \( 26×63×78×14=1788696 \).</p>
<p>What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the \( 20×20 \) grid?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-10"><a class="header" href="#brute-force-10">Brute force</a></h1>
<p>This problem is not interesting, the solution is simply to iterate on each 
row, column and on the two diagonal.</p>
<p>As with <a href="problems/problem_0011/../problem_0008/problem.html">Largest product in a series</a>, the 
input grid will be stored in a file, so the first step is to obtain this
grid as int matrix.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0011/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return [
            [int(x) for x in line.split(&quot; &quot;)] for line in file.read().split(&quot;\n&quot;)[:-1]
        ]
</code></pre>
<p>And then just iterate on this matrix:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0011/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_product_in_grid(filename):
    g = read_file(filename)

    for y in range(0, 20):
        for x in range(0, 17):
            yield g[x][y] * g[x + 1][y] * g[x + 2][y] * g[x + 3][y]
    for x in range(0, 20):
        for y in range(0, 17):
            yield g[x][y] * g[x][y + 1] * g[x][y + 2] * g[x][y + 3]
    for y in range(0, 17):
        for x in range(0, 17):
            yield g[x][y] * g[x + 1][y + 1] * g[x + 2][y + 2] * g[x + 3][y + 3]
    for x in range(3, 20):
        for y in range(0, 17):
            yield g[x][y] * g[x - 1][y + 1] * g[x - 2][y + 2] * g[x - 3][y + 3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-10"><a class="header" href="#solution-10">Solution</a></h1>
<hr />
<blockquote>
<p>70600674</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="highly-divisible-triangular-number"><a class="header" href="#highly-divisible-triangular-number"><a href="https://projecteuler.net/problem=12">Highly divisible triangular number</a></a></h1>
<blockquote>
<p>The sequence of triangle numbers is generated by adding the natural numbers. So the \( 7^{th} \) triangle number would be \( 1+2+3+4+5+6+7=28 \). The first ten terms would be:</p>
<p>\[
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
\]</p>
<p>Let us list the factors of the first seven triangle numbers:</p>
<p>\[
\begin{align}
1&amp;: 1\\
3&amp;: 1,3\\
6&amp;: 1,2,3,6\\
10&amp;: 1,2,5,10\\
15&amp;: 1,3,5,15\\
21&amp;: 1,3,7,21\\
28&amp;: 1,2,4,7,14,28\end{align}
\]</p>
<p>We can see that \( 28 \) is the first triangle number to have over five divisors.</p>
<p>What is the value of the first triangle number to have over five hundred divisors?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-11"><a class="header" href="#brute-force-11">Brute force</a></h1>
<p>Finding the number of factors of \( n \) can be done by iterating from 1 to
\( n \) and checking each number that can divide \( n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def number_of_factors(n):
    res = 1
    for i in range(2, n):
        if n % i == 0:
            res += 1
    return res
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Triangular_number">Triangular number</a> can be
computed quite easily with a loop, we can generate them as long as their number
of divisor is less than \( 500 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def highly_div_triangular_number(n=500):
    i = 1
    res = 1
    while number_of_factors(res) &lt; n:
        i += 1
        res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-factor"><a class="header" href="#common-factor">Common factor</a></h1>
<p>The <a href="problems/problem_0012/solution1.html">Brute Force</a> solution is really slow, way to slow to be
honest.</p>
<p>First, we can improve the way we find the number of factors. If \( i \)
divides \( n \), then obviously \( \frac{n}{i} \) divides \( n \) too. We
do not need to iterate from 2 to \( n \) but only to \( \sqrt{n} \) and add
the factors two by two. The only exception is that if \( \sqrt{n} \) divides
\( n \) we only need to count it once.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def number_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root):
        if n % i == 0:
            res += 1
    return 2 * res + (root**2 == n)
</code></pre>
<p>This makes the solution much faster, but there is still room for improvement in
the way the triangular numbers are calculated. We already know from the previous
problems that the sum of integer from \( 1 \) to \( n \) is \(\frac{n(n+1)
}{2} \). Since \( n \) and \( n + 1 \) have no factors in common except \(
1 \), we can multiply the number of factor in \( \frac{n}{2} \) and \( n + 1
\) or \( n \) and \( \frac{n+1}{2} \) depending on the parity of \( n \).
This allows us to calculate the number of factors of smaller numbers, which
makes the solution quite fast compared to the <a href="problems/problem_0012/solution1.html">Brute force</a>
solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def highly_div_triangular_number(n=500):
    i = 0
    factors = 0
    while factors &lt; n:
        i += 1
        if i % 2 == 0:
            factors = number_of_factors(i // 2) * number_of_factors(i + 1)
        else:
            factors = number_of_factors(i) * number_of_factors((i + 1) // 2)

    return i * (i + 1) // 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-11"><a class="header" href="#solution-11">Solution</a></h1>
<hr />
<blockquote>
<p>76576500</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="large-sum"><a class="header" href="#large-sum"><a href="https://projecteuler.net/problem=13">Large sum</a></a></h1>
<blockquote>
<p>Work out the first ten digits of the sum of the following one-hundred \( 50 \)-digit numbers.</p>
<p>\[
37107287533902102798797998220837590246510135740250\\\\
46376937677490009712648124896970078050417018260538\\\\
74324986199524741059474233309513058123726617309629\\\\
91942213363574161572522430563301811072406154908250\\\\
23067588207539346171171980310421047513778063246676\\\\
89261670696623633820136378418383684178734361726757\\\\
28112879812849979408065481931592621691275889832738\\\\
44274228917432520321923589422876796487670272189318\\\\
47451445736001306439091167216856844588711603153276\\\\
70386486105843025439939619828917593665686757934951\\\\
62176457141856560629502157223196586755079324193331\\\\
64906352462741904929101432445813822663347944758178\\\\
92575867718337217661963751590579239728245598838407\\\\
58203565325359399008402633568948830189458628227828\\\\
80181199384826282014278194139940567587151170094390\\\\
35398664372827112653829987240784473053190104293586\\\\
86515506006295864861532075273371959191420517255829\\\\
71693888707715466499115593487603532921714970056938\\\\
54370070576826684624621495650076471787294438377604\\\\
53282654108756828443191190634694037855217779295145\\\\
36123272525000296071075082563815656710885258350721\\\\
45876576172410976447339110607218265236877223636045\\\\
17423706905851860660448207621209813287860733969412\\\\
81142660418086830619328460811191061556940512689692\\\\
51934325451728388641918047049293215058642563049483\\\\
62467221648435076201727918039944693004732956340691\\\\
15732444386908125794514089057706229429197107928209\\\\
55037687525678773091862540744969844508330393682126\\\\
18336384825330154686196124348767681297534375946515\\\\
80386287592878490201521685554828717201219257766954\\\\
78182833757993103614740356856449095527097864797581\\\\
16726320100436897842553539920931837441497806860984\\\\
48403098129077791799088218795327364475675590848030\\\\
87086987551392711854517078544161852424320693150332\\\\
59959406895756536782107074926966537676326235447210\\\\
69793950679652694742597709739166693763042633987085\\\\
41052684708299085211399427365734116182760315001271\\\\
65378607361501080857009149939512557028198746004375\\\\
35829035317434717326932123578154982629742552737307\\\\
94953759765105305946966067683156574377167401875275\\\\
88902802571733229619176668713819931811048770190271\\\\
25267680276078003013678680992525463401061632866526\\\\
36270218540497705585629946580636237993140746255962\\\\
24074486908231174977792365466257246923322810917141\\\\
91430288197103288597806669760892938638285025333403\\\\
34413065578016127815921815005561868836468420090470\\\\
23053081172816430487623791969842487255036638784583\\\\
11487696932154902810424020138335124462181441773470\\\\
63783299490636259666498587618221225225512486764533\\\\
67720186971698544312419572409913959008952310058822\\\\
95548255300263520781532296796249481641953868218774\\\\
76085327132285723110424803456124867697064507995236\\\\
37774242535411291684276865538926205024910326572967\\\\
23701913275725675285653248258265463092207058596522\\\\
29798860272258331913126375147341994889534765745501\\\\
18495701454879288984856827726077713721403798879715\\\\
38298203783031473527721580348144513491373226651381\\\\
34829543829199918180278916522431027392251122869539\\\\
40957953066405232632538044100059654939159879593635\\\\
29746152185502371307642255121183693803580388584903\\\\
41698116222072977186158236678424689157993532961922\\\\
62467957194401269043877107275048102390895523597457\\\\
23189706772547915061505504953922979530901129967519\\\\
86188088225875314529584099251203829009407770775672\\\\
11306739708304724483816533873502340845647058077308\\\\
82959174767140363198008187129011875491310547126581\\\\
97623331044818386269515456334926366572897563400500\\\\
42846280183517070527831839425882145521227251250327\\\\
55121603546981200581762165212827652751691296897789\\\\
32238195734329339946437501907836945765883352399886\\\\
75506164965184775180738168837861091527357929701337\\\\
62177842752192623401942399639168044983993173312731\\\\
32924185707147349566916674687634660915035914677504\\\\
99518671430235219628894890102423325116913619626622\\\\
73267460800591547471830798392868535206946944540724\\\\
76841822524674417161514036427982273348055556214818\\\\
97142617910342598647204516893989422179826088076852\\\\
87783646182799346313767754307809363333018982642090\\\\
10848802521674670883215120185883543223812876952786\\\\
71329612474782464538636993009049310363619763878039\\\\
62184073572399794223406235393808339651327408011116\\\\
66627891981488087797941876876144230030984490851411\\\\
60661826293682836764744779239180335110989069790714\\\\
85786944089552990653640447425576083659976645795096\\\\
66024396409905389607120198219976047599490197230297\\\\
64913982680032973156037120041377903785566085089252\\\\
16730939319872750275468906903707539413042652315011\\\\
94809377245048795150954100921645863754710598436791\\\\
78639167021187492431995700641917969777599028300699\\\\
15368713711936614952811305876380278410754449733078\\\\
40789923115535562561142322423255033685442488917353\\\\
44889911501440648020369068063960672322193204149535\\\\
41503128880339536053299340368006977710650566631954\\\\
81234880673210146739058568557934581403627822703280\\\\
82616570773948327592232845941706525094512325230608\\\\
22918802058777319719839450180888072429661980811197\\\\
77158542502016545090413245809786882778948721859617\\\\
72107838435069186155435662884062257473692284509516\\\\
20849603980134001723930671666823555245252804609722\\\\
53503534226472524250874054075591789781264330331690
\]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-12"><a class="header" href="#brute-force-12">Brute force</a></h1>
<p>The main problem is to find a way to add large numbers, because computers can
not store large numbers so easily. That's the point of the problem, to find a
way to add those numbers. We could use an array to store each digit of each
number and add them, but thanks to python and
the <a href="https://www.python.org/dev/peps/pep-0237/">unifying long integers and integers</a>
we can just add these numbers without worrying about memory.</p>
<p>We just need to get the first 10 digits of the additions, which can be done
quite easily by converting the number to a string ang get the first 10
characters.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0013/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def large_sum(filename):
    return str(sum(read_file(filename)))[:10]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-12"><a class="header" href="#solution-12">Solution</a></h1>
<hr />
<blockquote>
<p>5537376230</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-collatz-sequence"><a class="header" href="#longest-collatz-sequence"><a href="https://projecteuler.net/problem=14">Longest Collatz sequence</a></a></h1>
<blockquote>
<p>The following iterative sequence is defined for the set of positive integers:</p>
<p>\[
\begin{align}
&amp; n \rightarrow \frac{n}{2}\ (n\ is\ even)\\
&amp; n \rightarrow 3n + 1\ (n\ is\ odd)
\end{align}
\]</p>
<p>Using the rule above and starting with \( 13 \), we generate the following sequence:</p>
<p>\[
13 \rightarrow 40 \rightarrow 20 \rightarrow 10 \rightarrow 5 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1
\]</p>
<p>It can be seen that this sequence (starting at \( 13 \) and finishing at \( 1 \)) contains \( 10 \) terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at \( 1 \).</p>
<p>Which starting number, under one million, produces the longest chain?</p>
<p><strong>NOTE:</strong> Once the chain starts the terms are allowed to go above one million.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-13"><a class="header" href="#brute-force-13">Brute force</a></h1>
<p>Calculating the number of iterations of the Collatz sequence is easy, just
follow the sequence until it reaches one, and count the number of iterations
to get there:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0014/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def collatz(n):
    iteration = 0
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        iteration += 1

    return iteration
</code></pre>
<p>Then, just check the iteration for each starting number from 1 to 1000000 and
return the largest.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0014/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def longest_collatz_sequence(n=1000000):
    res, max_it = 0, 0
    for i in range(1, n):
        current_it = collatz(i)
        if current_it &gt; max_it:
            res, max_it = i, current_it

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching"><a class="header" href="#caching">Caching</a></h1>
<p>The Collatz sequence of starting numbers \( 4 \) and \( 8 \) are actually
quite similar :
\[
\begin{align} &amp;Collatz(4) = 4 \rightarrow 2 \rightarrow 1\\ &amp;Collatz(8) = 8 \rightarrow 4 \rightarrow 2 \rightarrow 1\\ \end{align} \]</p>
<p>By calculating \( Collatz(8) \) we ended up recalculating \( Collatz(4)
\), if we keep in memory the number of iterations of \( Collatz(4) \), we
could reuse it to find the number of iterations of \( Collatz(8) \).</p>
<p>That is what <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a> is,
storing data so that future requests for that data can be served faster.</p>
<p>In our case, when calculating the number of iteration of \( n \), we first
look if the value has already been computed, if not, we update the cache 
using the formula.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0014/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def longest_collatz_sequence(n=1000000):
    cache = {1: 1}

    def collatz(i):
        if i not in cache:
            cache[i] = collatz(i // 2 if i % 2 == 0 else 3 * i + 1) + 1

        return cache[i]

    return max(range(1, n), key=collatz)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-13"><a class="header" href="#solution-13">Solution</a></h1>
<hr />
<blockquote>
<p>837799</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lattice-paths"><a class="header" href="#lattice-paths"><a href="https://projecteuler.net/problem=15">Lattice paths</a></a></h1>
<blockquote>
<p>Starting in the top left corner of a \( 2×2 \) grid, and only being able to move to the right and down, there are exactly \( 6 \) routes to the bottom right corner.</p>
<p style="text-align: center;"><img alt="" class="dark_img" src="https://projecteuler.net/project/images/p015.png"/></p>
<p>How many such routes are there through a \( 20×20 \) grid?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-14"><a class="header" href="#brute-force-14">Brute force</a></h1>
<p>We are searching for the number of different paths starting from the top left
corner and going to the bottom right corner of a \( 20 \times 20 \)
square. The only possible moves are down and right. This is the same as
searching for the <a href="https://en.wikipedia.org/wiki/Lattice_path">Lattice path</a>.</p>
<p>Since the square is \( 20 \times 20 \) we have 20 moves down and 20 moves to
the right. If we move to the right, then we have 20 moves down and 19 moves to
the right, we can continue as long as we have moves available.</p>
<p>The solution can be done recursively, starting with 20 moves down and right, the
result being the combination of paths down and to the right. Each times we move
down we call the function recursively with the same number of moves to the
right, but one less move down. When the number of move down is 1, the result is
obviously 1: the only remaining path is the one to the right. The same can be
done for the move to the right.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0015/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def lattice_paths(up=20, down=20):
    moves_down = lattice_paths(up, down - 1) if down &gt; 1 else 1
    moves_up = lattice_paths(up - 1, down) if up &gt; 1 else 1

    return moves_up + moves_down
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-1"><a class="header" href="#dynamic-programming-1">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0015/solution1.html">Brute force</a> solution is not efficient at all, for example,
if we go down and then right or right and then down, we end up in the same
place. The <a href="problems/problem_0015/solution1.html">Brute force</a> solution will compute the answer twice.</p>
<p>We could use a cache, but let's do this solution iteratively rather than 
recursively.</p>
<p>We can represent the solution using a matrix, for example, for a \( 3 \times 3
\) square, we have the number of paths from the green point to the red point
for each sub parallelogram.</p>
<p align="center"> <img src="problems/problem_0015/../../images/p0015/p0015-s2-grid.png" style="width: 40%"> </p>
<p>Looking at the \( 2 \times 2 \) sub square, we can see that the number of
different paths is indeed 6.</p>
<p>For each red point, the number of different paths to it is the sum of the path
above and paths on the left.</p>
<p>For the first row and column, the number of different paths is one: either only
downs or only rights. Then, we can simply compute the path to the other red
points using the old ones, we simply return the value at the last cell.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0015/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def lattice_paths(n=20):
    n += 1
    paths = np.zeros((n, n), dtype=int)

    for i in range(1, n):
        paths[i, 0] = 1
        paths[0, i] = 1

    for i in range(1, n):
        for j in range(1, n):
            paths[i, j] = paths[i - 1, j] + paths[i, j - 1]

    return paths[n - 1, n - 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combination"><a class="header" href="#combination">Combination</a></h1>
<p>For a square of dimension \( n \), we know that whatever path we take, there
will be exactly \( n \) movements to the right and \( n \) movements down.
We can represent the path as a string of 'D' for down and 'R' for right.</p>
<p>For example, with a \( 3 \times 3 \) square, a path could be : 'RRRDDD',
'DDDRRR' or 'RDDRDR'. The question now is, 'In how many ways can we place the '
R' and the 'D' in the string ?'</p>
<p>Since there must be as many 'D' as 'R', we can only place the 'R' and leave the
rest as 'D'. That means we are searching for the number of ways we can place \(
n \) 'R' in a string of \( 2n \) characters. This is called
a <a href="https://en.wikipedia.org/wiki/Combination">combination</a>, in our case, it's:</p>
<p>\[ \begin{pmatrix} 2n\\ n \end{pmatrix} = \frac{\left(2n\right)!}{n!\left(2n - n\right)!} = \frac{\left (2n\right)!}{\left(n!\right)^2} \]</p>
<p>This can be calculated using factorial:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0015/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def lattice_paths(n=20):
    return factorial(2 * n) // (factorial(n) ** 2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-14"><a class="header" href="#solution-14">Solution</a></h1>
<hr />
<blockquote>
<p>137846528820</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="power-digit-sum"><a class="header" href="#power-digit-sum"><a href="https://projecteuler.net/problem=16">Power digit sum</a></a></h1>
<blockquote>
<p>\( 2^{15}=32768 \) and the sum of its digits is \( 3+2+7+6+8=26 \).</p>
<p>What is the sum of the digits of the number \( 2^{1000} \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-15"><a class="header" href="#brute-force-15">Brute force</a></h1>
<p>Thanks to python, the solution is trivial, we just need to sum the digits of a
number, which can be done by casting it into a string and iterating on it.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0016/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def power_digit_sum(n=1000):
    return sum((int(d) for d in str(2**n)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-15"><a class="header" href="#solution-15">Solution</a></h1>
<hr />
<blockquote>
<p>1366</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-letter-counts"><a class="header" href="#number-letter-counts"><a href="https://projecteuler.net/problem=17">Number letter counts</a></a></h1>
<blockquote>
<p>If the numbers \( 1 \) to \( 5 \) are written out in words: one, two, three, four, five, then there are \( 3+3+5+4+4=19 \) letters used in total.</p>
<p>If all the numbers from \( 1 \) to \( 1000 \) (one thousand) inclusive were written out in words, how many letters would be used?</p>
<p><strong>NOTE:</strong> Do not count spaces or hyphens. For example, \( 342 \) (three hundred and forty-two) contains \( 23 \) letters and \( 115 \) (one hundred and fifteen) contains \( 20 \) letters. The use of &quot;and&quot; when writing out numbers is in compliance with British usage.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-16"><a class="header" href="#brute-force-16">Brute force</a></h1>
<p>This problem is boring, there is nothing interesting to do, we can only count
some word several times. For example, the word &quot;hundred&quot; is used 900 times from
100 to 999, this allows some factoring. We can do the same for the number from 1
to 9, for &quot;and&quot;, for 10, 20, 30, ...</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0017/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def number_letter_counts():
    unit = len(&quot;onetwothreefourfivesixseveneightnine&quot;)
    ten = len(&quot;teneleventwelvethirfourfifsixseveneighnine&quot;) + len(&quot;ten&quot;) * 7
    and_l = len(&quot;and&quot;)
    twenty = len(&quot;twentythirtyfortyfiftysixtyseventyeightyninety&quot;)
    hun = len(&quot;hundred&quot;)
    thou = len(&quot;onethousand&quot;)
    return thou + 900 * hun + 190 * unit + 100 * twenty + 891 * and_l + 10 * ten
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-16"><a class="header" href="#solution-16">Solution</a></h1>
<hr />
<blockquote>
<p>21124</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-path-sum-i"><a class="header" href="#maximum-path-sum-i"><a href="https://projecteuler.net/problem=18">Maximum path sum I</a></a></h1>
<blockquote>
<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is \( 23 \).</p>
<p>\[
\color{red}{3}\\\\
2\ \color{red}{4}\ 6\\\\
8\ 5\ \color{red}{9}\ 3
\]</p>
<p>That is, \( 3+7+4+9=23 \).</p>
<p>Find the maximum total from top to bottom of the triangle below:</p>
<p>\[
75\\\\
95\ 64\\\\
17\ 47\ 82\\\\
18\ 35\ 87\ 10\\\\
20\ 04\ 82\ 47\ 65\\\\
19\ 01\ 23\ 75\ 03\ 34\\\\
88\ 02\ 77\ 73\ 07\ 63\ 67\\\\
99\ 65\ 04\ 28\ 06\ 16\ 70\ 92\\\\
41\ 41\ 26\ 56\ 83\ 40\ 80\ 70\ 33\\\\
41\ 48\ 72\ 33\ 47\ 32\ 37\ 16\ 94\ 29\\\\
53\ 71\ 44\ 65\ 25\ 43\ 91\ 52\ 97\ 51\ 14\\\\
70\ 11\ 33\ 28\ 77\ 73\ 17\ 78\ 39\ 68\ 17\ 57\\\\
91\ 71\ 52\ 38\ 17\ 14\ 91\ 43\ 58\ 50\ 27\ 29\ 48\\\\
63\ 66\ 04\ 68\ 89\ 53\ 67\ 30\ 73\ 16\ 69\ 87\ 40\ 31\\\\
04\ 62\ 98\ 27\ 23\ 09\ 70\ 98\ 73\ 93\ 38\ 53\ 60\ 04\ 23
\]</p>
<p><strong>NOTE:</strong> As there are only \( 16384 \) routes, it is possible to solve this problem by trying every route. However, <a href="https://projecteuler.net/problem=67">Problem 67</a>, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-17"><a class="header" href="#brute-force-17">Brute force</a></h1>
<p>Even if the problem tells us not to use brute force, we will still do it. Not
because we want to do things easily, but because it will be much easier to find
a better solution later after solving the problem the first time.</p>
<p>First, we need to transform the triangle into something easier to manipulate,
for example a two-dimensional array.</p>
<p>The problem can be solved quite easily after that, with a simple recursion: The
maximum score is the current number plus the highest score by choosing the left
or the right.</p>
<p>It is enough to stop when we are outside the triangle, since the lower number is
0, we can consider that leaving the triangle is like adding 0.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0018/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def maximum_path_sum_I(filename):
    triangle = read_file(filename)

    def path(i, j):
        if i &gt;= len(triangle) or j &gt;= len(triangle[i]):
            return 0

        return triangle[i][j] + max(path(i + 1, j), path(i + 1, j + 1))

    return path(0, 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-2"><a class="header" href="#dynamic-programming-2">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0018/solution1.html">Brute force</a> solution has some issue, for example with the
following triangle:</p>
<p>\[ \begin{gather} 01\\ 02\quad 03\\ 04\quad \color{red}{05}\quad 06\\ 07\quad \color{green}{08}\quad \color{green}{09}\quad 10\\ \end{gather} \]</p>
<p>The path \( 1 \rightarrow 2 \rightarrow 5 \) and the path \( 1 \rightarrow 3
\rightarrow 5 \) both end on 5 and then try to find the best solution between 8
and 9. Obviously, the best choice is 9, because it is the largest number between
8 and 9 and there is no path left to take. It doesn't depend on where we come
from, which means that we can replace the number 5 with \( 5 + 9 = 14 \). We
can do the same with 4 and 6, which then gives the following triangle:</p>
<p>\[ \begin{gather} 01\\ 02\quad 03\\ \color{red}{12}\quad \color{red}{14}\quad \color{red}{16}\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>And we can go all the way to the end by reducing the last line each time:</p>
<p>\[ \begin{gather} 01\\ \color{red}{16}\quad \color{red}{19}\\ 12\quad 14\quad 16\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>And finally:</p>
<p>\[ \begin{gather} \color{red}{20}\\ 16\quad 19\\ 12\quad 14\quad 16\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>This solution is much faster because it doesn't recalculate anything twice, it
just chooses the best path from the end, since we don't need to know where we
came from to find the best incoming path.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0018/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def maximum_path_sum_I(filename):
    triangle = read_file(filename)

    for i in range(len(triangle) - 2, -1, -1):
        for j in range(len(triangle[i])):
            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])

    return triangle[0][0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-17"><a class="header" href="#solution-17">Solution</a></h1>
<hr />
<blockquote>
<p>1074</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting-sundays"><a class="header" href="#counting-sundays"><a href="https://projecteuler.net/problem=19">Counting Sundays</a></a></h1>
<blockquote>
<p>You are given the following information, but you may prefer to do some research for yourself.</p>
<ul>
<li>1 Jan 1900 was a Monday.</li>
<li>Thirty days has September,<br />
April, June and November.<br />
All the rest have thirty-one,<br />
Saving February alone,<br />
Which has twenty-eight, rain or shine.<br />
And on leap years, twenty-nine.</li>
<li>A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.</li>
</ul>
<p>How many Sundays fell on the first of the month during the twentieth century (\( 1 \) Jan \( 1901 \) to \( 31 \) Dec \( 2000 \))?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-18"><a class="header" href="#brute-force-18">Brute force</a></h1>
<p>This problem is not fascinating, we could start from the first of January 1901
as a Tuesday, and iterate on each month, for example the first day of February
1901 is Tuesday + \( 31\ \%\ 7 \), which is Friday. We could continue by
taking leap year into account. But thanks to Python, we can solve this problem
with a simpler solution:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0019/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def counting_sundays():
    res = 0
    for year in range(1901, 2001):
        for month in range(1, 13):
            if datetime.datetime(year, month, 1).weekday() == 6:
                res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-18"><a class="header" href="#solution-18">Solution</a></h1>
<hr />
<blockquote>
<p>171 </p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorial-digit-sum"><a class="header" href="#factorial-digit-sum"><a href="https://projecteuler.net/problem=20">Factorial digit sum</a></a></h1>
<blockquote>
<p>\( n! \) means \( n × (n  −1) ×...×3×2×1 \)</p>
<p>For example, \( 10!=10×9×...×3×2×1=3628800 \),
and the sum of the digits in the number \( 10! \) is \( 3+6+2+8+8+0+0=27 \).</p>
<p>Find the sum of the digits in the number \( 100! \)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-19"><a class="header" href="#brute-force-19">Brute force</a></h1>
<p>As always, problems involving large numbers are easy to solve in Python, just
compute the number and iterate on it as a string:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0020/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def factorial_digit_sum(n=100):
    return sum(int(x) for x in str(factorial(n)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-19"><a class="header" href="#solution-19">Solution</a></h1>
<hr />
<blockquote>
<p>648</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="amicable-numbers"><a class="header" href="#amicable-numbers"><a href="https://projecteuler.net/problem=21">Amicable numbers</a></a></h1>
<blockquote>
<p>Let \( d(n) \) be defined as the sum of proper divisors of \( n \) (numbers less than \( n \) which divide evenly into \( n \)).</p>
<p>If \( d(a) =  b \) and \( d(b) = a \), where \( a ≠ b \), then \( a \) and \( b \) are an amicable pair and each of \( a \) and \( b \) are called amicable numbers.</p>
<p>For example, the proper divisors of \( 220 \) are \( 1 \), \( 2 \), \( 4 \), \( 5 \), \( 10 \), \( 11 \), \( 20 \), \( 22 \), \( 44 \), \( 55 \) and \( 110 \); therefore \( d(220)=284 \). The proper divisors of \( 284 \) are \( 1 \), \( 2 \), \( 4 \), \( 71 \) and \( 142 \); so \( d(284)=220 \).</p>
<p>Evaluate the sum of all the amicable numbers under \( 10000 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-20"><a class="header" href="#brute-force-20">Brute force</a></h1>
<p>The problem first requires to find the sum of proper divisors of a number, if
recall, in the
<a href="problems/problem_0021/../problem_0012/problem.html">Problem 12: Highly divisible triangular number</a>, we
found the number of proper divisors, we can reuse this function by adding the
divisors rather than counting them.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0021/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root + 1):
        if n % i == 0:
            res += i + n // i

    return res
</code></pre>
<p>We can simply iterate from 1 to 10000 and sum the amicable numbers found to find
the solution, we just to be aware that even if \( d(6) = 6 \) and so \( d(6)
= 6 \), 6 is not an amicable number because amicable numbers are in pairs.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0021/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def amicable_numbers(n=10000):
    res = 0
    for i in range(2, n):
        current = sum_of_factors(i)
        if i != current and i == sum_of_factors(current):
            res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-20"><a class="header" href="#solution-20">Solution</a></h1>
<hr />
<blockquote>
<p>31626</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="names-scores"><a class="header" href="#names-scores"><a href="https://projecteuler.net/problem=22">Names scores</a></a></h1>
<blockquote>
<p>Using <a href="https://projecteuler.net/project/resources/p022_names.txt">names.txt</a> (right click and 'Save Link/Target As...'), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.</p>
<p>For example, when the list is sorted into alphabetical order, COLIN, which is worth \( 3+15+12+9+14=53 \), is the \( 938 \)th name in the list. So, COLIN would obtain a score of \( 938×53=49714 \).</p>
<p>What is the total of all the name scores in the file?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-21"><a class="header" href="#brute-force-21">Brute force</a></h1>
<p>We first get the huge list of names in python, we just need to remove the <code>&quot;&quot;</code>
around them.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0022/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return [name[1:-1] for name in file.read().split(&quot;,&quot;)]
</code></pre>
<p>Then we just need to sum the letters of the names by their position in the
alphabet. Since all the names are capitalized, we can remove <code>ord('A') + 1</code> to
get their position in the alphabet. The last step is to sum the position of the
names in the list by its value.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0022/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def names_scores(filename):
    names = read_file(filename).sort()
    return sum((i + 1) * sum(ord(c) - ord(&quot;A&quot;) + 1 for c in name) for (i, name) in enumerate(names))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-21"><a class="header" href="#solution-21">Solution</a></h1>
<hr />
<blockquote>
<p>871198282</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-abundant-sums"><a class="header" href="#non-abundant-sums"><a href="https://projecteuler.net/problem=23">Non-abundant sums</a></a></h1>
<blockquote>
<p>A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of \( 28 \) would be \( 1+2+4+7+14=28 \), which means that \( 28 \) is a perfect number.</p>
<p>A number \( n \) is called deficient if the sum of its proper divisors is less than \( n \) and it is called abundant if this sum exceeds \( n \).</p>
<p>As \( 12 \) is the smallest abundant number, \( 1+2+3+4+6=16 \), the smallest number that can be written as the sum of two abundant numbers is \( 24 \). By mathematical analysis, it can be shown that all integers greater than \( 28123 \) can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.</p>
<p>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-22"><a class="header" href="#brute-force-22">Brute force</a></h1>
<p>We are searching for all numbers that are <strong>not</strong> the sum of two abundant
numbers. Since every integer larger than 28123 can be written as the sum of two
abundant numbers, our upper limit is therefore 28123.</p>
<p>First, we need to find all the abundant number below 28123, going higher is
pointless because we are searching for positive numbers only. An abundant number
is a number that have a larger sum of divisors than itself. We already have a
function to compute the sum of divisors, we just need to be aware that if \(
\sqrt{n} \) divide \( n \), it only has to count once.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root + 1):
        if n % i == 0:
            res += i + n // i

    if root**2 == n:
        res -= root

    return res
</code></pre>
<p>We just need to check if a number is the sum of two of the abundant numbers
calculated earlier. The naive way to do this is to try every combination of two
abundant numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_sum(i, abundant):
    return any(a1 + a2 == i for a1 in abundant for a2 in abundant)
</code></pre>
<p>Finally, we just have to sum each number less than 28124 that is not the sum 
of two abundant numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def non_abundant_sums():
    abundant = [i for i in range(1, 28124) if sum_of_factors(i) &gt; i]

    return sum(i for i in range(28124) if not is_sum(i, abundant))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set"><a class="header" href="#set">Set</a></h1>
<p>The <a href="problems/problem_0023/solution1.html">Brute Force</a> solution is extremely slow, the biggest issue is
how we determine if a number is the sum of two abundant numbers.</p>
<p>We are searching for any abundant numbers \( a_1 \) and \( a_2 \) such that
\( a_1 + a_2 = n \), which implies that \(a_2 = n - a_2 \). If \( n - a_2
\) is an abundant number, then \( n \) is the sum of two abundant numbers.</p>
<p>Finding a value in a list is slow because we need to go through the whole list,
that's why using a <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">set</a>
to store our abundant is more efficient in our this case. We just need to
iterate over all abundant once and check if \( n \) minus this abundant is
also in the set.</p>
<p>We can also improve the way we build this set of abundant numbers. Since we have
an upper bound, we can construct the sum of divisors of all these numbers at
once. For every \( i \) and \( j \) such that \( i \times j &lt; limit \),
the number \( i \times j \) has both \( i \) and \( j \) as divisors. We
just need to be aware that if \( i = j \) we need to add the divisor only
once.</p>
<p>We start with a list of 1 because 1 divides all numbers. Then we iterate with
\( i \) from 2 to \( \left\lfloor\sqrt{limit}\right\rfloor \) and \( j \)
from \( i + 1 \) (to avoid the case where \( i = j \)) to \( i \times j &gt;
limit \Leftrightarrow j &gt; \left\lfloor \frac{limit}{i} \right\rfloor \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def get_sum_of_factors(n):
    sum_of_factors = [1] * (n + 1)
    for i in range(2, floor(sqrt(n)) + 1):
        sum_of_factors[i * i] += i
        for j in range(i + 1, (n // i) + 1):
            sum_of_factors[i * j] += i + j

    return sum_of_factors
</code></pre>
<p>In the previous solution, we first built the list of abundant numbers and then
searched for the number that was not a sum of two of them, since we always have
\( a_1 &lt;= a_2 \) we can actually do both at the same time.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def non_abundant_sums(n=28123):
    sum_of_factors = get_sum_of_factors(n)
    abundant = set()
    res = 0

    for i in range(1, n + 1):
        if sum_of_factors[i] &gt; i:
            abundant.add(i)
        if all((i - a1 not in abundant) for a1 in abundant):
            res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-22"><a class="header" href="#solution-22">Solution</a></h1>
<hr />
<blockquote>
<p>4179871</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexicographic-permutations"><a class="header" href="#lexicographic-permutations"><a href="https://projecteuler.net/problem=24">Lexicographic permutations</a></a></h1>
<blockquote>
<p>A permutation is an ordered arrangement of objects. For example, \( 3124 \) is one possible permutation of the digits \( 1 \), \( 2 \), \( 3 \) and \( 4 \). If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of \( 0 \), \( 1 \) and \( 2 \) are:</p>
<p>\[
012\ \ 021\ \ 102\ \ 120\ \ 201\ \ 210
\]</p>
<p>What is the millionth lexicographic permutation of the digits \( 0 \), \( 1 \), \( 2 \), \( 3 \), \( 4 \), \( 5 \), \( 6 \), \( 7 \), \( 8 \) and \( 9 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-23"><a class="header" href="#brute-force-23">Brute force</a></h1>
<p>First of all, we need to understand how the lexicographic permutations are
computed. If we enumerate all the permutations of '0123' starting with '0':</p>
<p>\[ 0123\\ 0132\\ 0213\\ 0231\\ 0312\\ 0321\\ \]</p>
<p>By removing the '0' we get:</p>
<p>\[ 123\\ 132\\ 213\\ 231\\ 312\\ 321\\ \]</p>
<p>It's the lexicographic permutations of '123' !</p>
<p>We can continue:</p>
<p>\[\begin{align} &amp;123\ &amp;&amp;213\ &amp;&amp;321\\ &amp;132\ &amp;&amp;231\ &amp;&amp;321 \end{align} \]</p>
<p>By removing the first character each time, it gives:</p>
<p>\[\begin{align} &amp;23\ &amp;&amp;13\ &amp;&amp;21\\ &amp;32\ &amp;&amp;31\ &amp;&amp;21 \end{align} \]</p>
<p>That is, the lexicographic permutations of '23', '13', and '21',</p>
<p>Now, enumerating all permutations of '0123' starting with '1':</p>
<p>\[ 1023\\ 1032\\ 1203\\ 1230\\ 1302\\ 1230 \]</p>
<p>By removing the '1' we get:</p>
<p>\[ 023\\ 032\\ 203\\ 230\\ 302\\ 230 \]</p>
<p>It's the lexicographic permutations of '023' !</p>
<p>This means that we can compute all the lexicographic permutations of a string by
taking each character, placing it at the beginning of the new permutations and
then adding the lexicographic permutations of the rest of the string
recursively.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0024/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def lexicographic_permutations(s):
    if len(s) &lt;= 1:
        yield s
    else:
        for i in range(len(s)):
            for p in lexicographic_permutations(s[:i] + s[i + 1 :]):
                yield s[i] + p
</code></pre>
<p>By using <code>yield</code>, we create a generator, it's better than storing 1 million
elements and then returning the last one, just take the 1000000th element
generated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maths-permutations"><a class="header" href="#maths-permutations">Maths permutations</a></h1>
<p>If you have understood how lexicographic permutation are constructed, you should
have noticed that permutations are made from right to left. Before updating the
number on the left, all permutations on the right must have been made. That is
why with the string '0123', the first 6 permutations begin with '0', then the 6
following permutations with '1', and so on.</p>
<p>The string in our examples contains 4 characters, it implies that every \( ( 4
- 1 )! \) permutations the first digit will change. We can even tell which
one will be placed first by knowing the multipliers of that factorial. If it is
the \( 3 * 3! \)th permutations, the first digit will be the third one in the
string, '3' in this example.</p>
<p>Since this process is recursive, we can find the first digit each time by
reducing the n-th permutations we are looking for.</p>
<p>For example, if we researched the 15th lexicographic permutations, we know that
the first character will be '2' because the \( 3! \) first permutations will
start with '0', the next \( 3! \) with '1'.</p>
<p>The 12th lexicographic permutations is obviously '2013'. It's just '0123', but
the '2' is place at the first position. Now that we have our first digit, we can
remove those 12 permutations from the 15th, which gives us 3 permutations.</p>
<p>Now, we are searching for the third lexicographic permutations of '013', with
the same reasoning, we can find that the first digit will be '1' after \( 1 *
2! \) permutations. It leaves use with 1 permutation and the string '03'.</p>
<p>After \( 1 * 1! \) permutations the first digit will be '3'. It leaves us with
'0' which is the last digit. The 15 lexicographic permutations is '2130' !</p>
<p>We just have to find the quotient and remainder of our nth permutations, the
divisor being the length of the string minus one. We can continue as long as our
string contains more than one character.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0024/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def lexicographic_permutations(s, n):
    if len(s) &lt;= 1:
        return s
    q, r = divmod(n, factorial(len(s) - 1))
    return s[q] + lexicographic_permutations(s[:q] + s[q + 1 :], r)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-23"><a class="header" href="#solution-23">Solution</a></h1>
<hr />
<blockquote>
<p>2783915460</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="1000-digit-fibonacci-number"><a class="header" href="#1000-digit-fibonacci-number"><a href="https://projecteuler.net/problem=25">1000-digit Fibonacci number</a></a></h1>
<blockquote>
<p>The Fibonacci sequence is defined by the recurrence relation:</p>
<p>\[
F_n = F_{n−1} + F_{n−2},\ where\ F_1 = 1\ and\ F_2 = 1.
\]</p>
<p>Hence the first \( 12 \) terms will be:</p>
<p>\[
\begin{align}
F1 &amp;= 1\\
F2 &amp;= 1\\
F3 &amp;= 2\\
F4 &amp;= 3\\
F5 &amp;= 5\\
F6 &amp;= 8\\
F7 &amp;= 13\\
F8 &amp;= 21\\
F9 &amp;= 34\\
F10 &amp;= 55\\
F11 &amp;= 89\\
F12 &amp;= 144
\end{align}
\]</p>
<p>The \( 12 \)th term, \(F_{12} \), is the first term to contain three digits.</p>
<p>What is the index of the first term in the Fibonacci sequence to contain \( 1000 \) digits?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-24"><a class="header" href="#brute-force-24">Brute force</a></h1>
<p>The brute force solution is simple, just iterate until the number of digits 
is at least 1000. We can count the number of digits in a number by turning 
it into a string and counting its length.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0025/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def thousandth_digit_fibonacci_number(n=1000):
    f1 = 1
    f2 = 1
    res = 1
    while len(str(f1)) &lt; n:
        f1, f2 = f2, f1 + f2
        res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-convergence"><a class="header" href="#fibonacci-convergence">Fibonacci convergence</a></h1>
<p>We know from <a href="problems/problem_0025/../problem_0002/solution3.html">Fibonacci and the golden ratio</a>
that the n-th term of Fibonacci can be expressed as :</p>
<p>\[ F_{n} = \frac{\varphi^{n}}{\sqrt{5}} = \frac{\left(\frac{1+\sqrt{5}}{2}
\right)^n}{\sqrt{5}} \]</p>
<p>Searching for a number with at least 1000 digit is the same as searching a
for number that is greater than or equal to \( 10^{999} \)</p>
<p>\[ \begin{align} \frac{\varphi^{n}}{\sqrt{5}} &amp; &gt;= 10^{999}\\
n * \log(\varphi) - \frac{\log(5)}{2} &amp; &gt;= 999 * log(10)\\
n &amp; &gt;= \frac{\frac{\log(5)}{2} + 999}{\log(\varphi)}\\ 
n &amp; = \left\lceil\frac{\frac{\log(5)}{2} + 999}{\log(\varphi)} \right\rceil\\ \end{align} \]</p>
<p>Since n must be an integer, it is sufficient to take the ceiling from the
previous equation.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0025/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def thousandth_digit_fibonacci_number(n=1000):
    return ceil((n - 1 + log10(sqrt(5)) / 2) / log10((1 + sqrt(5)) / 2))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-24"><a class="header" href="#solution-24">Solution</a></h1>
<hr />
<blockquote>
<p>4782</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="reciprocal-cycles"><a class="header" href="#reciprocal-cycles"><a href="https://projecteuler.net/problem=26">Reciprocal cycles</a></a></h1>
<blockquote>
<p>A unit fraction contains \( 1 \) in the numerator. The decimal representation of the unit fractions with denominators \( 2 \) to \( 10 \) are given:</p>
<p>\[
\begin{align}
\frac{1}{2}\ &amp;=0.5\\
\frac{1}{3}\ &amp;=0.(3)\\
\frac{1}{4}\ &amp;=0.25\\
\frac{1}{5}\ &amp;=0.2\\
\frac{1}{6}\ &amp;=0.1(6)\\
\frac{1}{7}\ &amp;=0.(142857)\\
\frac{1}{8}\ &amp;=0.125\\
\frac{1}{9}\ &amp;=0.(1)\\
\frac{1}{10}&amp;=0.1
\end{align}
\]</p>
<p>Where \( 0 \).\( 1 \)(\( 6 \)) means \( 0 \).\( 166666... \), and has a \( 1 \)-digit recurring cycle. It can be seen that \( \frac{1}{7} \) has a \( 6 \)-digit recurring cycle.</p>
<p>Find the value of \( d \) \( &lt;1000 \) for which \( \frac{1}{d} \) contains the longest recurring cycle in its decimal fraction part.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-25"><a class="header" href="#brute-force-25">Brute force</a></h1>
<p>How do you find the decimals of a fraction?</p>
<p>In elementary school, we learned a method to convert fractions to decimals.
Repeat the process of multiplying the numerator by 10:</p>
<ul>
<li>The next numerator is the rest of the Euclidean division by the denominator.</li>
<li>The quotient is the next decimal.</li>
</ul>
<p>For example with \( \frac{1}{7} \):</p>
<p>\[ \begin{align} \frac{1}{7} &amp;= 7 * \mathbf{0} + 1\\ \frac{10}{7} &amp;= 7 * \mathbf{1} + 3\\ \frac{30}{7} &amp;= 7 * \mathbf{4} + 2\\ \frac{20}{7} &amp;= 7 * \mathbf{2} + 6\\ \frac{60}{7} &amp;= 7 * \mathbf{8} + 4\\ \frac{40}{7} &amp;= 7 * \mathbf{5} + 5\\ \frac{50}{7} &amp;= 7 * \mathbf{7} + 1\\ \frac{10}{7} &amp;= \dots\\ \end {align} \]</p>
<p>That give us \( \frac{1}{7} = 0,142857... \).</p>
<p>We just have to pay attention to some special cases:</p>
<ul>
<li>When the rest is 0, the division is finite and there is no cycle. We can
assume that the length of the cycle is 0.</li>
<li>The length of the cycle is not the number of time we repeat the process of
finding the decimals of a fraction. For example with \( \frac{1}{6} = 0,
166... \) the cycle is 1. But there is some leading number before it.</li>
</ul>
<p>Detecting the cycle is possible using a set. But we will have no way of knowing
when it started, which is required to find its length. We need to store both the
numbers and their positions for every decimal. When a duplicate is found, it is
enough to calculate the length between the old and the newly found duplicate.
Rather than a set, using a dictionary whose key is the rest and value its
position in the decimal form of the fraction will solve both problem.</p>
<pre><code class="language-python">def find_cycle(n):
    rest = 1
    seen = {}
    for i in itertools.count(0):
        if rest == 0:
            return 0
        if rest in seen:
            return i - seen[rest]

        seen[rest] = i
        rest = (rest * 10) % n
</code></pre>
<p>The last step is to test all numbers below 1000 and find the one with the
greatest cycle.</p>
<pre><code class="language-python">def reciprocal_cycles(n=1000):
    return max(((find_cycle(i), i) for i in range(2, n)))[1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carmichael-function"><a class="header" href="#carmichael-function">Carmichael function</a></h1>
<p>The <a href="problems/problem_0026/solution1.html">Brute force</a> solution works and is not that slow. Yet, with a
few observations, we can improve it.</p>
<ol>
<li>If you played a bit with the previous snippet of code, you might have notice
that most of the duplicate digits are 1. That's not a coincidence, the first
rest is also 1. In fact, what we are searching for is more known as the
result of
the <a href="https://en.wikipedia.org/wiki/Carmichael_function">Carmichael function</a>:</li>
</ol>
<blockquote>
<p>The Carmichael function associates to every positive interger \( n \) a
positive integer \lambda{n}, defined as the smallest positive integer \(
m \) such that
\[ a^m \equiv 1\ [ n ] \]</p>
</blockquote>
<p>In our case, \( a \) is always 10 and \( m \) is the length of the cycle we
are searching for the number \( n \).</p>
<p>Knowing that, we can try to make some observations:</p>
<ol start="2">
<li>
<p>Let \( f=\frac{1}{2^{a} 5^{b}} \), where \( a,b\in\mathbb{Z}_{\geqslant 0}
\). f has a finite and non-recurring decimal
representation. <a href="https://en.wikipedia.org/wiki/Decimal_representation#Finite_decimal_representations">Proof on Wikipedia</a>
.</p>
</li>
<li>
<p>If \( \frac{1}{m} \) is a repeating decimal and \( \frac{1}{n} \) is a
terminating decimal, them \( \frac{1}{mn} \) has a nonperiodic part whose
length is that of \( \frac{1}{n} \) and a repeating part whose length is
that of \( \frac {1}{m} \).
From <a href="https://mathworld.wolfram.com/RepeatingDecimal.html">Wolfram MathWorld</a></p>
</li>
<li>
<p>The recurring part of \( \frac{1}{d} \) cannot have more than \( d - 1 \)
digits. <a href="https://en.wikipedia.org/wiki/Carmichael_function#Order_of_elements_modulo_n">Proof on Wikipedia</a></p>
</li>
</ol>
<p>Let's try to use this information in our program:</p>
<p>We can reduce \( n \) by dividing it with \( 2 \) or \( 5 \) until it
become coprime with \( 10 \) (3). If after this reduction \( n = 1 \), \(
\frac{1}{n} \) has no recurring part (2).</p>
<p>We do not need to use a dictionary to find our cycle. Since \( n \) will be
coprime with 10, there will not be any leading number before the recurring
part (4). We know that if the rest is 1, we found our cycle (1).</p>
<pre><code class="language-python">def find_cycle(n):
    while n % 2 == 0:
        n /= 2
    while n % 5 == 0:
        n /= 5

    if n == 1:
        return 0

    i = 1
    r = 10
    while r != 1:
        r = (r * 10) % n
        i += 1

    return i
</code></pre>
<p>We can start from 1000 and iterate until \( \frac{n}{2} \) (2). If we find \(
n \) such that \( \lambda{n} == n - 1 \), there will be no point to go any
further (4).</p>
<pre><code class="language-python">def reciprocal_cycles(n=1000):
    max_cycle = 0
    res = 0
    for i in range(n, n // 2, -1):
        current_cycle = find_cycle(i)

        if current_cycle == i - 1:
            return i

        if current_cycle &gt; max_cycle:
            max_cycle = current_cycle
            res = i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-25"><a class="header" href="#solution-25">Solution</a></h1>
<hr />
<blockquote>
<p>983</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="quadratic-primes"><a class="header" href="#quadratic-primes"><a href="https://projecteuler.net/problem=27">Quadratic primes</a></a></h1>
<blockquote>
<p>Euler discovered the remarkable quadratic formula:</p>
<p>\[
n^2 + n + 41
\]</p>
<p>It turns out that the formula will produce \( 40 \) primes for the consecutive integer values \( 0  \leq n \leq 39 \). However, when \( n=40 \), \( 40^2+40+41=40(40+1)+41 \) is divisible by \( 41 \), and certainly when \( n=41 \), \( 41^2+41+41 \) is clearly divisible by \( 41 \).</p>
<p>The incredible formula \( n^2-79n+1601 \) was discovered, which produces \( 80 \) primes for the consecutive values \( 0 \leq n \leq 79 \). The product of the coefficients, \( −79 \) and \( 1601 \), is \( −126479 \).</p>
<p>Considering quadratics of the form:</p>
<p>\[
\begin{align}
&amp; n^2 + an + b,\ where\ |a|&lt; 1000\ and\ |b|\ \leq 1000\\
\\
&amp; where\ |n|\ is\ the\ modulus/absolute value\ of\ n\\
&amp; e.g.\ |11|=11\ and\ |-4|=4
\end{align}
\]</p>
<p>Find the product of the coefficients, \( a \) and \( b \), for the quadratic expression that produces the maximum number of primes for consecutive values of \( n \), starting with \( n=0 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-26"><a class="header" href="#brute-force-26">Brute force</a></h1>
<p>The problem is to find the best combination of \( a \) and \( b \) such that
the formula:</p>
<p>\[ n^2 + an + b \]</p>
<p>produces the largest number of primes for consecutive values of \( n \). The
absolute value of \( a \) and \( b \) must be less than \( 1000 \).</p>
<p>The brute force solution is to iterate from \( -1000 \) to \( 1000 \)
for \( a \) and \( b \) and count the number of consecutive primes each
time.</p>
<pre><code class="language-python">def quadratic_primes(limit=1000):
    res = 0
    max_primes = 0
    for a in range(-limit, limit):
        for b in range(-limit, limit):
            n = 0
            while isprime(n ** 2 + a * n + b):
                n += 1
            if n &gt; max_primes:
                max_primes = n
                res = a * b

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shorten-the-intervals"><a class="header" href="#shorten-the-intervals">Shorten the intervals</a></h1>
<p>If with take a closer look at the equation, we should find useful information.
For example, with some peculiar values of \( n \), we can narrow down the
ranges of \( a \) and \( b \).</p>
<p>We are searching \( p \) prime such that:</p>
<p>\[ p = n^2 + an + b \]</p>
<p>For \( n = 0\), the equation is \( p = b \). That means that \( b \)
must be a prime.</p>
<p>For \( n = b \), the equation is \( p = b^2 + ab + b = b(b + a + 1) \)
which is divisible by \( b \). \( b \) is in fact the limit of consecutive
primes that can be found using this equation.</p>
<p>Rearranging the equation we have:</p>
<p>\[ p = n^2 + an + b \Leftrightarrow p - b = n(n + a) \]</p>
<p>Since both \( p \) and \( b \) are prime, \( p - b \) is an even number.</p>
<p>If \( n \) is even then \( n(n + a) \) will also be even.<br />
If \( n \) is odd, then \( n(n + a) \) will be odd only if \( a \) is odd.</p>
<p>For \( n = 1 \), \( n^2 + an + b \) will never be a prime if \( a \) is
even.</p>
<p>All this information can help quite a bit:</p>
<ul>
<li>\( a \) must be an odd number between.</li>
<li>b must be a prime.</li>
<li>b is the upper limit of consecutive primes.</li>
</ul>
<pre><code class="language-python">def quadratic_primes():
    primes_b = list((primerange(0, 1000)))[::-1]  # b is prime.
    res = 0
    max_primes = 0
    for a in range(-999, 1000, 2):  # a is odd.
        for b in primes_b:
            if b &lt; max_primes:  # b is the limit for consecutive prime.
                continue

            n = 0
            while isprime(n ** 2 + a * n + b):
                n += 1

            if n &gt; max_primes:
                max_primes = n
                res = a * b

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lucky-numbers-of-euler"><a class="header" href="#lucky-numbers-of-euler">Lucky numbers of Euler</a></h1>
<p>Thanks
to <a href="https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">mathworld</a>
, we know that if \( p(n) = n^2 + n + 41 \) is prime-generating for \(
0 \leq n \leq L \), then so is \( p(L - n) \).</p>
<p>\[ \begin{align} &amp;p(n) = n^2 + n + 41\\ &amp;p(L - n) = (L - n)^2 + L - n + 41\\ &amp;p(L - n) = L^2 - 2Ln + n^2 + L - n + 41\\ &amp;p(L - n) = n^2 - (2L + 1)n + L^2 + L + 41\\ &amp;p(L - n) = n^2 - (2L + 1)n + p(L)\\ &amp;p(L - n) = n^2 + an + b\\ &amp;where\ a = -(2L + 1)\ and\ b = L^2 + L + 41\\ \end{align} \]</p>
<p>We also know from the <a href="problems/problem_0027/solution2.html">Shorten the intervals</a> solution that when
\( n = 0 \), \( b = L^2 + L + 41 \) is prime. Since \( |b| &lt; 1000 \) we
have:</p>
<p>\[ b = L^2 + L + 41 &lt; 1000 \Rightarrow -31 \leq L \leq 31 \]</p>
<p>We also know that \( b \) is the upper limit of consecutive primes, it means
that \( b \) must be the largest number possible. It corresponds to \( L = 30
\) and \( b = 30^2 + 30 + 41 = 971 \) and \( a = -(2 \times 30 + 1)
= -61 \).</p>
<p>We can find a general solution based on the limit by searching the value of \(
L \) and then computing \( a \times b = (L^2 + L + 41) \times (-2(L + 1))
\).</p>
<p>The value of \( L \) is the largest solution for \( L^2 + L + 41 &lt; limit \)
.<br />
We have \( \Delta = 1 - 4(41 - limit) \), thus the solution is L = 
\( \left\lfloor \frac{-1 + \sqrt{4(41 - limit)}}{2} \right\rfloor \)</p>
<pre><code class="language-python">def quadratic_primes(limit=1000):
    l = floor((-1 + sqrt(1 - 4 * (41 - limit))) / 2)
    return (l ** 2 + l + 41) * (-(2 * l + 1))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-26"><a class="header" href="#solution-26">Solution</a></h1>
<hr />
<blockquote>
<p>-59231</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-spiral-diagonals"><a class="header" href="#number-spiral-diagonals"><a href="https://projecteuler.net/problem=28">Number spiral diagonals</a></a></h1>
<blockquote>
<p>Starting with the number \( 1 \) and moving to the right in a clockwise direction a \( 5 \) by \( 5 \) spiral is formed as follows:</p>
<p>\[
\begin{gather}
\color{red}{21}\ 22\ 23\ 24\ \color{red}{25}\\
20\ \ \ \color{red}{7}\ \ \ 8\ \ \ \color{red}{9}\ 10\\
19\ \ \ 6\ \ \ \color{red}{1}\ \ \ 2\ 11\\
18\ \ \ \color{red}{5}\ \ \ 4\ \ \ \color{red}{3}\ 12\\
\color{red}{17}\ 16\ 15\ 14\ \color{red}{13}\\
\end{gather}
\]</p>
<p>It can be verified that the sum of the numbers on the diagonals is \( 101 \).</p>
<p>What is the sum of the numbers on the diagonals in a \( 1001 \) by \( 1001 \) spiral formed in the same way?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-27"><a class="header" href="#brute-force-27">Brute force</a></h1>
<p>This problem actually contains two problem. The first is the spiral creation
problem and the second is the diagonal sum problem.</p>
<p>The direction of the spiral is a cycle of 'EAST', 'SOUTH', 'WEST' and 'NORTH'
but the main question is to know when it changes.</p>
<p>There is many ways of creating a spiral matrix, but the idea I had was to insert
number in every cell in the same direction until the cell in the next direction
is empty.</p>
<p>Once the spiral matrix is created, we can compute the diagonal using the
<code>trace</code> function of numpy. We also need to remove the cell in the middle because
it will be counted twice.</p>
<pre><code class="language-python">def number_spiral_diagonals(n=1001):
    dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # EAST, SOUTH, WEST, NORTH
    cur_dir = 0
    (x, y) = (n // 2, n // 2)  # Center of the matrix
    spiral = np.zeros(n * n, dtype=int).reshape(n, n)
    spiral[x, y] = 1

    for i in range(2, n * n + 1):
        # Move along the current direction and update the new cell
        dx, dy = dir[cur_dir]
        x, y = x + dx, y + dy
        spiral[x, y] = i

        # If the cell in the next direction is empty: change direction
        dx, dy = dir[(cur_dir + 1) % 4]
        if spiral[x + dx, y + dy] == 0:
            cur_dir = (cur_dir + 1) % 4

    return np.trace(spiral) + np.trace(np.fliplr(spiral)) - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation"><a class="header" href="#summation">Summation</a></h1>
<p>The sum of the diagonals is actually the sum of the 4 corners of each subcube of
the spiral matrix.</p>
<p>With:</p>
<p>\[
\begin{gather} \color{red}{21}\ 22\ 23\ 24\ \color{red}{25}\\ 20\ \ \ \color{red}{7}\ \ \ 8\ \ \ \color{red}{9}\ 10\\ 19\ \ \ 6\ \ \ \color{red}{1}\ \ \ 2\ 11\\ 18\ \ \ \color{red}{5}\ \ \ 4\ \ \ \color{red}{3}\ 12\\ \color{red}{17}\ 16\ 15\ 14\ \color{red}{13}\\ \end{gather} \]</p>
<p>The sum is \( (1) + (3 + 5 + 7 + 9) + (13 + 17 + 21 + 25) \)</p>
<p>For an \( n \times n \) grid, with n being odd, the top right corner is \( n^
2 \), the top left corner is \( n^2 -n + 1 \), the bottom left corner is \(
n^2 -2n + 2 \) and the bottom right corner is \( n^2 -3n + 3 \). The sum of
these corners is \( 4n^2 -6n + 6 \).</p>
<p>We need to sum these corners for all odd \( n \) between 3 and \( l \). Odd
numbers can be written in the form \( 2k + 1 \). By replacing \( n \)
with \( 2k + 1 \) we have:</p>
<p>\[ 4n^2 -6n + 6 = 4(2k+1)^2 -6(2k+1) + 6 = 16k^2 + 4k + 4 \]</p>
<p>The sum become:</p>
<p>\[ \begin{align} S &amp;= \sum _{k=1}^{m} 16k^{2} + 4k + 4\\ S &amp;= 16\sum _{k=1}^ {m} k^{2} + 4\sum _{k=1}^{m} k + 4\sum _{k=1}^{m} 1\\ S &amp;= \frac{16m(m+1) (2m+1)}{6} + \frac{4m(m + 1)}{2} + 4m\\ S &amp;= \frac{16m^3}{3} + 10m^2 + \frac{26m}{3}\\ \end{align} \]</p>
<p>where \( m = \frac{l - 1}{2} \)</p>
<p>This sum plus \( 1 \) (the center of the spiral matrix) is the solution we are
searching for:</p>
<pre><code class="language-python">def number_spiral_diagonals(n=1001):
    m = (n - 1) // 2
    return int(1 + (16 / 3) * m ** 3 + 10 * m ** 2 + (26 / 3) * m)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-27"><a class="header" href="#solution-27">Solution</a></h1>
<hr />
<blockquote>
<p>669171001</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="distinct-powers"><a class="header" href="#distinct-powers"><a href="https://projecteuler.net/problem=29">Distinct powers</a></a></h1>
<blockquote>
<p>Consider all integer combinations of \( a^b \) for \( 2 ≤ a ≤ 5 \) and \( 2 ≤ b ≤ 5 \):</p>
<p>\[
\begin{align}
&amp;2^2=4, 2^3=8, 2^4=16, 2^5=32\\
&amp;3^2=9, 3^3=27, 3^4=81, 3^5=243\\
&amp;4^2=16, 4^3=64, 4^4=256, 4^5=1024\\
&amp;5^2=25, 5^3=125, 5^4=625, 5^5=3125\\
\end{align}
\]</p>
<p>If they are then placed in numerical order, with any repeats removed, we get the following sequence of \( 15 \) distinct terms:</p>
<p>\[
4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
\]</p>
<p>How many distinct terms are in the sequence generated by \( a^b \) for \( 2 ≤ a ≤ 100 \) and \( 2 ≤ b ≤ 100 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-28"><a class="header" href="#brute-force-28">Brute force</a></h1>
<p>Using
python's <a href="https://python-reference.readthedocs.io/en/latest/docs/comprehensions/set_comprehension.html">{} set comprehension</a>
we can create a set with all the terms generated by the sequence: \( a^b \).
Since a set discards duplicate elements, the solution is the length of that set.</p>
<pre><code class="language-python">def distinct_powers(n=100):
    return len({a ** b for a in range(2, n + 1) for b in range(2, n + 1)})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discarding-duplicate"><a class="header" href="#discarding-duplicate">Discarding duplicate</a></h1>
<p>We can actually solve this problem with pen and paper.</p>
<p>I won't explain the solution since <code>jorgbrown</code> has already done a great job in
his <a href="https://projecteuler.net/thread=29;page=3#6162">post</a>:</p>
<blockquote>
<p>Suppose \( a \) is a perfect square of the smaller \( a \), but not a
square of a square. Then we have a duplicate when \( b \) is \( 2, 3,
4\dots \) up to \( 50 \). That is, \( 49 \) duplicates.</p>
<p>Suppose \( a \) is a perfect cube of a smaller \( a \). When \( b \)
is \( 2 \) through \( 33 \), we have duplicates of smaller \( a \)
raised to the power \( b\times3 \). When \( b \) is \( 34, 36, 38, 40,
42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66 \), we have duplicates
of a smaller \( a \) raised to the power \( (\frac{b}{2})\times3 \).
Total is \( 32 + 17 \), or again, \( 49 \) duplicates.</p>
<p>Suppose \( a \) is the square of the square of a smaller \( a \). When
\( b \) is \( 2 \) through \( 49 \), we have duplicates of the square
root of a raised to the power \( (b\times2) \).<br />
When \( b \) is \( 51, 54, 57, 60, 63, 66, 69, 72, \) or \( 75, \) we
have dupes of \( a^{(\frac{3}{4})} \) raised to the power \( \frac
{b\times4} {3} \). Total is \( 49 + 9 \), or \( 58 \).</p>
<p>Suppose \( a \) is the fifth power of a smaller \( a \). We have dupes of
fifth root of a raised to the power \( (b\times5) \), which covers \( b \)
from \( 2 \) to \( 20 \). Then we have dupes of \( a^{(\frac{2}{5})} \)
raised to the power \( \frac{b\times5}{2} \), which covers \( b \) of
\( 22, 24, 26, 28, 30, 32, 34, 36, 38, 40 \). Then we have dupes of \(
a^{(\frac{3}{5})} \) raised to the power \( \frac{b\times5}{3} \), which
covers \( b \) of \( 21, 27, 33, 39, 42, 45, 48, 51, 54, 57, 60 \).
Last, we have dupes of \( a^\frac{4}{5} \) raised to the power \(
\frac{b\times5}{4} \), which covers \( b \) of \( 44, 52, 56, 64, 68, 72,
76\), and \( 80 \). Total dupes: \( 48 \).</p>
<p>And the last power we have to worry about is \( 6 \). We have dupes of the
square root of a raised to power \( (b\times2) \), which covers \( b \)
from \( 2 \) to \( 50 \). Then we have dupes of the sixth root to the power
\( \frac{b\times6}{4} \), which covers \( b \) of \( 52 \),
\( 54, 56, 58, 60, 62, 64, 66 \). And last we have dupes of the sixth
root to the power \( \frac{b\times6}{5} \), which covers \( b \) of \(
55,
65, 70, 75 \), and \( 80 \). Total dupes: \( 62 \).</p>
<p>Now let's put it all together:</p>
<p>squares: \( 4, 9, 25, 36, 49, 100 \): These \( 6 \) squares have \(
49 \) dupes each, \( 6 \times 49 \) = \( 294 \)</p>
<p>cubes: \( 8, 27 \): These \( 3 \) cubes have \( 49 \) duplicates
each: \( 2 \times 49 = 98 \)</p>
<p>4th power: \( 16, 81 \). These \( 2 \) have \( 58 \) dupes each: \( 2
\times 58 = 116 \)</p>
<p>5th power: \( 32 \). This has \( 48 \) dupes.</p>
<p>6th power: \( 64 \): this has \( 62 \) dupes.</p>
<p>Total # dupes: \( 618 \). \( 9801-618 \) is \( 9183 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-28"><a class="header" href="#solution-28">Solution</a></h1>
<hr />
<blockquote>
<p>9183</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="digit-fifth-powers"><a class="header" href="#digit-fifth-powers"><a href="https://projecteuler.net/problem=30">Digit fifth powers</a></a></h1>
<blockquote>
<p>Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:</p>
<p>\[
\begin{align}
1634 = 1^4 + 6^4 + 3^4 + 4^4\\
8208 = 8^4 + 2^4 + 0^4 + 8^4\\
9474 = 9^4 + 4^4 + 7^4 + 4^4
\end{align}
\]</p>
<p>As \( 1=1^{4} \) is not a sum it is not included.</p>
<p>The sum of these numbers is \( 1634+8208+9474=19316 \).</p>
<p>Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-29"><a class="header" href="#brute-force-29">Brute force</a></h1>
<p>Finding number that can be written as the sum of fifth powers of theirs digits
is easy. The main difficulty of this problem is to find an upper bound and thus
to know when to stop the iteration.</p>
<p>The sum of the fifth powers of a \( n \)-digits number will always be less
than or equal to \( n * 9^5 \). We need to find \( n \) such that \( n *
9^5 &lt; 10^n - 1 \) for all \( n \). The solution is actually very complex, but
with \( n = 5 \) we have \( 5 * 9^5 = 295245 &gt; 10^5 - 1 \) and with \( n =
6 \) we have \( 6 * 9^5 = 354294 &lt; 10^6 - 1 \). Which implies that it is
pointless to try any number with more than 6 digits.</p>
<pre><code class="language-python">def digit_fifth_powers():
    return sum((n for n in range(2, 999999)
                if sum(int(i) ** 5 for i in str(n)) == n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-unique-combination"><a class="header" href="#search-unique-combination">Search unique combination</a></h1>
<p>There is no need to try all numbers with at most 6 digits. What is really
important is to try all combinations of numbers with at most 6 digits. For
example, the sum of the fourth powers of digits of \( 1346 \) is the same as
the sum of \( 1634, 1436\dots \) But even if the sum is the same for \(
1356 \) and \( 1634 \), only \( 1634 \) has a sum equal to itself. So how
can we avoid calculating duplicate combinations but still find the solution ?</p>
<p>We need to build a list of these combinations, which is easily done with a
recursive function. The idea is to create the string so that the digits are
sorted. The stopping condition is the number of digits. Recursive functions are
a pain to understand, but if you print the result and the string after each
iteration, you should understand the function without too much trouble.</p>
<p>I used <code>yield</code> instead of building an entire list, but you can consider that
it's the same thing.</p>
<pre><code class="language-python">def build_combination(d, n=0, s=''):
    if d == 0:
        yield s
    else:
        for i in range(n, 10):
            for v in build_combination(d - 1, i, s + str(i)):
                yield v

</code></pre>
<p>The trick is to compute the sum a first time, for example, taking \( 1346 \)
which sum is equal to \( 1^5 + 3^5 + 4^5 + 6^5 = 1634 \). Then, repeat the
operation a second time \( 1^5 + 6^5 + 3^5 + 4^5 = 1634 \). If the total is
the same for both computations, then you have found one combination that works.</p>
<p>Instead of computing the fifth power of each digit, we can compute them once and
store them in a cache. The rest is just trying all the previously found
combinations. We need to remove <code>1</code> from the final result as the problem
indicates.</p>
<pre><code class="language-python">def digit_fifth_powers():
    cache = [i ** 5 for i in range(0, 10)]
    res = 0
    for n in build_combination(6):
        total = sum(cache[int(c)] for c in n)
        if sum(cache[int(c)] for c in str(total)) == total:
            res += total

    return res - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-29"><a class="header" href="#solution-29">Solution</a></h1>
<hr />
<blockquote>
<p>443839</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="coin-sums"><a class="header" href="#coin-sums"><a href="https://projecteuler.net/problem=31">Coin sums</a></a></h1>
<blockquote>
<p>In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:</p>
<p>\[
\begin{align}
1p,\ 2p,\ 5p,\ 10p,\ 20p,\ 50p,\ £1\ (100p),\ and £2\ (200p).
\end{align}
\]</p>
<p>It is possible to make £\( 2 \) in the following way:</p>
<p>\[
\begin{align}
1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p\end{align}
\]</p>
<p>How many different ways can £\( 2 \) be made using any number of coins?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-30"><a class="header" href="#brute-force-30">Brute force</a></h1>
<p>We are searching for all the combination to make 2 pounds using the eights
following coins in pence:</p>
<blockquote>
<p>1, 2, 5, 10, 20, 50, 100, 200.</p>
</blockquote>
<p>Combination implies that making 2 pounds with <code>100 + 50 + 50</code> pences is the same
as <code>50 + 100 + 50</code> pences. To avoid this, we will try every piece one by one in
increasing order.</p>
<p>The algorithm will use an accumulator that will increase with each iteration of
the function:</p>
<ol>
<li>If the accumulator reaches 200, a combination has been found.</li>
<li>If the accumulator is greater than 200 the current combination will not work.</li>
<li>If the accumulator is less than 200, add a new piece. To avoid duplicate
combinations, always add piece larger than or equal to the last one.</li>
</ol>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]

    def coin_sums_rec(accumulator, minimum_piece):
        if accumulator == n:
            return 1
        if accumulator &gt; n:
            return 0

        return sum(
            coin_sums_rec(accumulator + coins[new_piece], new_piece) for new_piece in range(minimum_piece, len(coins))
        )

    return coin_sums_rec(0, 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-3"><a class="header" href="#dynamic-programming-3">Dynamic programming</a></h1>
<p>The last solution does not scale to the number of parts or the target. We can do
better using dynamic programming, but first, we must divide the problem into
subproblems.</p>
<p>Let's start with the ways to do 1p using all the pieces we have. The table is a
cumulative sum, so the value of each cell is the number of ways to have the
target using the pieces up to the current one. We consider that there is only
one way to do 0p, so the first column is always 1.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
</tbody></table>
</div>
<p>This table means that there is only one way to express 1p, no matter what coins
we are using.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">2p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
</tbody></table>
</div>
<p>2p can be expressed using 1p: 1p + 1p, but also using 2p. With the other coins
the result remain the same.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">2p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center">3p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center">4p</td><td style="text-align: center">1</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center">5p</td><td style="text-align: center">1</td><td style="text-align: center">3</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td></tr>
</tbody></table>
</div>
<p>You might start to understand how this table was computed:</p>
<ul>
<li>The first column is always 1, there is only one way to express any target
with 1p.</li>
<li>The first row is always 1, there is only one way to express 0p.</li>
<li>For the rest we construct the table lines by lines, the current cells is the
sum of two possibilities:
<ul>
<li>The new coin is not used,</li>
<li>The new coin is not used: the number of ways to make \( n \) is the
number of way to make \(n - 1 \) using the same coins, which is the
value in the left cell.</li>
<li>If possible, the new coin is used: the number of ways to make \( n \) is
the number of ways to make \( n - c \) using the same coins, which is
the value in the cell on the same column but on the line \( n - c \).</li>
</ul>
</li>
</ul>
<p>For example with the last line, the first column is obviously 1
and the second is: 1 (left cell) + 2 (the number of ways to make \( 5p -
2p = 3p \), above cell).</p>
<p>So, using a cache table, we can drop the time complexity from \( O(m^n) \) to
\( O(nm) \), where \( n \) is the target and \( m \) the number of
coins. But we now have an \( O(nm) \) space complexity.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    cache = [[1] + [0] * (len(coins) - 1) for _ in range(n + 1)]

    for i in range(n + 1):
        for j in range(1, len(coins)):
            cache[i][j] = cache[i][j - 1]
            if coins[j] &lt;= i:
                cache[i][j] += cache[i - coins[j]][j]

    return cache[-1][-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="better-dynamic-programming"><a class="header" href="#better-dynamic-programming">Better dynamic programming</a></h1>
<p>Dynamic programming can be a bit improved by using a single array instead of a
table. The array will contain the number of ways to make \( n \) using the
coins we have. The array will be initialized with 1, and we will update it by
adding the number of ways to make \( n - c \) to the current value. This way
we will only need \( O(n) \) space. The time complexity will be the same
as the previous solution, but the space complexity will be better.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    cache = [1] + [0] * n

    for coin in coins:
        for i in range(coin, n + 1):
            cache[i] += cache[i - coin]

    return cache[-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-30"><a class="header" href="#solution-30">Solution</a></h1>
<hr />
<blockquote>
<p>73682</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pandigital-products"><a class="header" href="#pandigital-products"><a href="https://projecteuler.net/problem=32">Pandigital products</a></a></h1>
<blockquote>
<p>We shall say that an \( n \)-digit number is pandigital if it makes use of all the digits \( 1 \) to \( n \) exactly once; for example, the \( 5 \)-digit number, \( 15234 \), is \( 1 \) through \( 5 \) pandigital.</p>
<p>The product \( 7254 \) is unusual, as the identity, \( 39×186=7254 \), containing multiplicand, multiplier, and product is \( 1 \) through \( 9 \) pandigital.</p>
<p>Find the sum of all products whose multiplicand/multiplier/product identity can be written as a \( 1 \) through \( 9 \) pandigital.</p>
<p>HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-31"><a class="header" href="#brute-force-31">Brute force</a></h1>
<p>First, we need to know when the multiplicand/multiplier/product triplet is
pandigital. There are several ways to do this, probably the most obvious
being to convert the triplet to a single sorted string and compare it to
&quot;123456789&quot;.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0032/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_pandigital(multiplicand, multiplier, product):
    return sorted(str(multiplicand) + str(multiplier) + str(product)) == list(&quot;123456789&quot;)
</code></pre>
<p>One solution I really like uses a binary number to keep track of the digits.
This is faster than converting the triplet to a string and uses less memory
than a set or list. This method uses the bits as flags to check if a digit
is present. If one of the digits is used twice, the triplet is not
pandigital. If the final binary number is 0b1111111110, the triplet is
pandigital.</p>
<pre><code class="language-python">def is_pandigital3(multiplicand, multiplier, product):
    digits = 0
    for n in (multiplicand, multiplier, product):
        while n:
            if digits &amp; (1 &lt;&lt; (n % 10)):
                return False
            digits |= 1 &lt;&lt; (n % 10)
            n //= 10

    return digits == 0b1111111110
</code></pre>
<p>Next, we need to find all the possible multiplicand/multiplier/product
combinations. We can do this by brute force, trying all the possible
values for the multiplicand and multiplier from 1 to 987654321. But the
calculation will take too long.</p>
<p>We know that if the multiplier is 5 digits, then the result will be at least
5 digits, so the total number of digits will be at least 11 and therefore
not pandigital.</p>
<p>On the contrary, if the multiplier is 1 digit and the multiplicand 3 digits, the
result will be 4 digits and the total number of digits will be 8.</p>
<p>Trying different combinations of multiplicand and multiplier, we find that
only the following one result in a 9-digit triplet.</p>
<ul>
<li>2 digits * 3 digits = product of 4 or 5 digits</li>
<li>1 digit * 4 digits = product of 4 or 5 digits</li>
</ul>
<p>We can limit the search to these combinations. To avoid duplicates, we can
store the current pandigital products in a set and compute the sum at the end.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0032/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pandigital_products():
    products = set()
    for i in range(1, 100):
        for j in range(100 if i &gt; 9 else 1000, 10000 // i + 1):
            if is_pandigital3(i, j, i * j):
                products.add(i * j)

    return sum(products)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-31"><a class="header" href="#solution-31">Solution</a></h1>
<hr />
<blockquote>
<p>45228</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="digit-cancelling-fractions"><a class="header" href="#digit-cancelling-fractions"><a href="https://projecteuler.net/problem=33">Digit cancelling fractions</a></a></h1>
<blockquote>
<p>The fraction \( \frac{49}{98} \) is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that \( \frac{49}{98}=\frac{4}{8} \), which is correct, is obtained by cancelling the\(  9s \).</p>
<p>We shall consider fractions like, \( \frac{30}{50}=\frac{3}{5} \), to be trivial examples.</p>
<p>There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.</p>
<p>If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-32"><a class="header" href="#brute-force-32">Brute force</a></h1>
<p>The first step is to identify curious faction, such as \( \frac{49}{98} \).
A Curious faction can take one of four forms, which can be expressed as follows:</p>
<p>\[
\frac{ax}{bx} = \frac{a}{b} \Rightarrow \frac{10a + x}{10b + x} = \frac{a}{b} \Rightarrow 10ab + bx = 10ab + ax \Rightarrow x(a - b) = 0
\]</p>
<p>This implies that either \( x = 0 \) or \( a = b \). Both solutions are trivial.</p>
<p>\[
\frac{xa}{xb} = \frac{a}{b} \Rightarrow \frac{10x + a}{10x + b} = \frac{a}{b} \Rightarrow 10bc + ba = 10ax + ab \Rightarrow x(a - b) = 0
\]</p>
<p>This yields the same trivial solutions as the first case.</p>
<p>The only non-trivial solutions are of the form \( \frac{ax}{xb} \) or \( \frac{xa}{bx} \).
We simply need to determine whether we are dealing with the first or second case and verify whether the fractions are the same with and without \( x \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0033/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_curious_fraction(numerator, denominator):
    if numerator % 10 == denominator // 10:
        return abs((numerator / denominator) - (numerator // 10 / (denominator % 10))) &lt; 0.0000001
    elif numerator // 10 == denominator % 10:
        return abs((numerator / denominator) - (numerator % 10 / (denominator // 10))) &lt; 0.0000001
    return False
</code></pre>
<p>To ensure accuracy in the presence of floating-point values, the returned value must be compared to a small value to ensure it is close enough to zero.</p>
<p>The second step is to iterate over every fraction, with the numerator being smaller than the denominator, as all fractions must be smaller than 1.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0033/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def digit_cancelling_fractions():
    final_numerator, final_denominator = 1, 1
    for numerator in range(10, 100):
        for denominator in range(numerator + 1, 100):
            if numerator % 10 == 0 or denominator % 10 == 0:
                continue
            if is_curious_fraction(numerator, denominator):
                final_numerator *= numerator
                final_denominator *= denominator

    return final_denominator // gcd(final_numerator, final_denominator)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-32"><a class="header" href="#solution-32">Solution</a></h1>
<hr />
<blockquote>
<p>100</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="digit-factorials"><a class="header" href="#digit-factorials"><a href="https://projecteuler.net/problem=34">Digit factorials</a></a></h1>
<blockquote>
<p>\( 145 \) is a curious number, as \( 1!+4!+5!=1+24+120=145 \).</p>
<p>Find the sum of all numbers which are equal to the sum of the factorial of their digits.</p>
<p>Note: As \( 1!=1 \) and \( 2!=2 \) are not sums they are not included.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-33"><a class="header" href="#brute-force-33">Brute force</a></h1>
<p>To identify curious numbers, we first need to iterate over each digit of the number and calculate the factorial of each digit.
Then, we need to sum all the factorials and compare the result with the original number.
If the sum is equal to the original number, then we have found a curious number.</p>
<p>To speed up the process, we can precompute the factorials and iterate over all digits using Python's string.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0034/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_criterion(x):
    facts = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
    return x == sum(facts[int(i)] for i in str(x))
</code></pre>
<p>The next step is to iterate over all numbers and find curious numbers, but we need to find an upper bound.
If we take a number \( x \) with \( d \) digits, we have \( 10^{d-1} \leq x &lt; 10^d \).
If \( x \) is the equal to the sum of factorials of its digits, then with \( x_i \) being the ith digit of \( x \), we have \( x = \sum_{i=1}^d x_i! &lt; d * 9! \).</p>
<p>Thus, we have \( 10^{d-1} \leq x &lt; d * 9! \). With d=8, the equation is wrong. Therefore, our upper bound is \( 7 * 9!\).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0034/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def digit_factorials():
    return sum(i for i in range(3, 7 * 362880) if is_criterion(i))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-33"><a class="header" href="#solution-33">Solution</a></h1>
<hr />
<blockquote>
<p>40730</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="circular-primes"><a class="header" href="#circular-primes"><a href="https://projecteuler.net/problem=35">Circular primes</a></a></h1>
<blockquote>
<p>The number, \( 197 \), is called a circular prime because all rotations of the digits: \( 197 \), \( 971 \), and \( 719 \), are themselves prime.</p>
<p>There are thirteen such primes below \( 100 \): \( 2 \), \( 3 \), \( 5 \), \( 7 \), \( 11 \), \( 13 \), \( 17 \), \( 31 \), \( 37 \), \( 71 \), \( 73 \), \( 79 \), and \( 97 \).</p>
<p>How many circular primes are there below one million?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-34"><a class="header" href="#brute-force-34">Brute force</a></h1>
<p>Determining whether a number is a circular prime can be achieved by rotating the digits of the number with Python's string slicing functionality, followed by a check for primality.
Instead of a loop, we used the built-in function <a href="https://docs.python.org/fr/3/library/functions.html?highlight=all#all">all</a> to check whether all rotations of the number are prime.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0035/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_circular_prime(n):
    return all(isprime(int(n[i:] + n[:i])) for i in range(len(n)))
</code></pre>
<p>The solution is then a simple sum of all numbers below one million that are circular primes.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0035/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def circular_primes():
    return sum(is_circular_prime(str(i)) for i in range(2, 1000000))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-3-7-9"><a class="header" href="#1-3-7-9">1, 3, 7, 9</a></h1>
<p>It is possible to reduce the number of candidate numbers that need to be checked for circular primality by taking into account that prime numbers cannot end with the digits 0, 2, 4, 5, 6 or 8.
Therefore, numbers containing these digits can be skipped from consideration.</p>
<p>By using the <a href="https://docs.python.org/3/library/itertools.html#itertools.product">itertools.product</a>,
it is possible to generate all possible combinations of the digits 1, 3, 7 and 9.
This approach reduces the number of potential circular prime to less than 6,000,
rather than the previous 1,000,000.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0035/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def circular_primes():
    res = 4
    for number_digits in range(2, 7):
        for n in itertools.product(&quot;1379&quot;, repeat=number_digits):
            if is_circular_prime(&quot;&quot;.join(n)):
                res += 1
    return res
</code></pre>
<p>Although the current solution is effective, it's possible to further optimize the solution.
For instance, since we check all circular permutations of a given number, we may be checking the same number multiple times.
Additionally, we know that all prime numbers can be expressed as either \( 6n+1 \) or \( 6n-1 \).
However, implementing these optimizations may not be worthwhile.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-34"><a class="header" href="#solution-34">Solution</a></h1>
<hr />
<blockquote>
<p>55</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="double-base-palindromes"><a class="header" href="#double-base-palindromes"><a href="https://projecteuler.net/problem=36">Double-base palindromes</a></a></h1>
<blockquote>
<p>The decimal number, \( 585=10010010012 \) (binary), is palindromic in both bases.</p>
<p>Find the sum of all numbers, less than one million, which are palindromic in base \( 10 \) and base \( 2 \).</p>
<p>(Please note that the palindromic number, in either base, may not include leading zeros.)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-35"><a class="header" href="#brute-force-35">Brute force</a></h1>
<p>Detecting palindromes with Python's string slicing is easy.
We can use the same approach to detect palindromes in binary form.
Python's <a href="https://docs.python.org/3/library/functions.html#bin">bin</a> function returns the binary representation of an integer with a <code>0b</code> prefix.
If you remove this prefix, we can use the same function to check if the number is a palindrome in binary form.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0036/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_double_palindrome(n):
    is_palindrome = lambda s: s == s[::-1]
    return is_palindrome(str(n)) and is_palindrome(bin(n)[2:])
</code></pre>
<p>To find the solution, we can sum all the number below 1 million that are palindromes in both decimal and binary form. </p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0036/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def double_base_palindromes():
    return sum(n for n in range(1000000) if is_double_palindrome(n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-palindromes"><a class="header" href="#generating-palindromes">Generating palindromes</a></h1>
<p>The <a href="problems/problem_0036/./solution1.html">Brute force</a> solution iterates over all numbers and check if they are palindromes.
We can directly generate palindromes in decimal form and then check if they are palindromic in binary form.</p>
<p>Palindrome are of the form:</p>
<ul>
<li><code>abccba</code></li>
<li><code>abcba</code></li>
<li><code>abba</code></li>
<li><code>aba</code></li>
<li><code>aa</code></li>
<li><code>a</code></li>
</ul>
<p>To generate these, we can create the left half of the palindrome and then mirror it to get the full palindrome.
We just have to be careful with the even and odd cases, like <code>abba</code> and <code>aba</code>.</p>
<p>Because the palindromes limit is 1 million, the left part must be smaller than 1000.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0036/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def make_palindrome():
    left = 1
    while left &lt; 1000:
        yield int(str(left) + str(left)[::-1][1:])  # Odd length palindromes
        yield int(str(left) + str(left)[::-1])  # Even length palindromes
        left += 1
</code></pre>
<p>The final solution just need to check palindromes in their binary form.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0036/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def double_base_palindromes():
    return sum(n for n in make_palindrome() if is_bin_palindrome(n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-35"><a class="header" href="#solution-35">Solution</a></h1>
<hr />
<blockquote>
<p>872187</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="truncatable-primes"><a class="header" href="#truncatable-primes"><a href="https://projecteuler.net/problem=37">Truncatable primes</a></a></h1>
<blockquote>
<p>The number \( 3797 \) has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: \( 3797 \), \( 797 \), \( 97 \), and \( 7 \). Similarly we can work from right to left: \( 3797 \), \( 379 \), \( 37 \), and \( 3 \).</p>
<p>Find the sum of the only eleven primes that are both truncatable from left to right and right to left.</p>
<p>NOTE: \( 2 \), \( 3 \), \( 5 \), and \( 7 \) are not considered to be truncatable primes.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-36"><a class="header" href="#brute-force-36">Brute force</a></h1>
<p>To solve the problem of finding truncatable primes, we will use Python's slicing again to check whether the left and right slices of a number are prime.
Using the <a href="https://docs.python.org/3/library/functions.html#all">all</a> function, we can check both slices at once efficiently.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0037/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_truncatable_prime(n):
    return all(isprime(int(n[i:])) and isprime(int(n[:i])) for i in range(1, len(n)))
</code></pre>
<p>Since the problem states that there are only eleven primes, we don't need to set an upper bound for our iteration.
We can use <a href="https://docs.python.org/3/library/itertools.html#itertools.count">itertools.count</a> to make the code more concise.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0037/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def truncatable_primes():
    res = []
    for i in itertools.count(10):
        if isprime(i) and is_truncatable_prime(str(i)):
            res.append(i)
            if len(res) == 11:
                return sum(res)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="construct-them-all"><a class="header" href="#construct-them-all">Construct them all</a></h1>
<p>The <a href="problems/problem_0037/./solution1.html">Brute force</a> solution stops when the eleven primes are found.
This is not a very efficient solution. Instead, we can construct all the truncatable primes.</p>
<p>The first digit must be 2, 3, 5 or 7 because the left slice will leave that digit at the end.
For the same reason, the last digit must be 2, 3, 5 or 7.
Since our solution must have at least 2 digits, the last digit cannot end with 2 or 5, as the right slice will leave a multiple of 2 or 5 at the end.</p>
<p>So the first digit is either 2, 3, 5 or 7 and the last digit is either 3 or 7.</p>
<p>The process is recursive. We will append numbers to the right.
It is only possible to add 1, 3, 7 or 9 to the right. In this case we can use 1 or 9 because if it ends in the middle of a number, it won't be a single digit with left or right truncating.
Obviously, the number will not be a truncatable prime, but the next iterations might be.</p>
<p>If the number is not a prime, there is no point to continue the recursion.
Indeed, if we continue, the right-truncating will end on this number, which is not prime and thus not truncatable.
On the contrary, the recursion can be continued until the number is not prime.</p>
<p>By construction, the number is prime and right-truncatable.
As explained before, we need to check if it is left-truncatable only if the number ends with 3 or 7.
If so, we can add it to the list of truncatable primes.</p>
<p>We will use the keyword <a href="https://docs.python.org/3/reference/simple_stmts.html#yield">yield</a> and <a href="https://docs.python.org/3/reference/simple_stmts.html#yield">yield from</a> to return the results as we find them.
The <code>yield from</code> statement is similar to the <code>yield</code> statement, but it is used to return the results of a generator function.
In a nutshell, we just have to use the <a href="https://docs.python.org/3/library/functions.html#sum">sum</a> builtin on the returned values.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0037/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def construct_truncatable_primes(num):
    if isprime(num):
        if num &gt; 10 and num % 10 in (3, 7) and is_left_truncatable(str(num)):
            yield num
        for new_digit in (1, 3, 7, 9):
            yield from construct_truncatable_primes(num * 10 + new_digit)
</code></pre>
<p>The final solution is just the sum of all the constructed truncatable primes starting with 2, 3, 5 and 7.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0037/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def truncatable_primes():
    return sum(sum(construct_truncatable_primes(d)) for d in (2, 3, 5, 7))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-36"><a class="header" href="#solution-36">Solution</a></h1>
<hr />
<blockquote>
<p>748317</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pandigital-multiples"><a class="header" href="#pandigital-multiples"><a href="https://projecteuler.net/problem=38">Pandigital multiples</a></a></h1>
<blockquote>
<p>Take the number \( 192 \) and multiply it by each of \( 1 \), \( 2 \), and \( 3 \):</p>
<p>\[
\begin{align}
192 × 1 = 192\\
192 × 2 = 384\\
192 × 3 = 576\end{align}
\]</p>
<p>By concatenating each product we get the \( 1 \) to \( 9 \) pandigital, \( 192384576 \). We will call \( 192384576 \) the concatenated product of \( 192 \) and \(( 1 \),\( 2 \),\( 3 )\)</p>
<p>The same can be achieved by starting with \( 9 \) and multiplying by \( 1 \), \( 2 \), \( 3 \), \( 4 \), and \( 5 \), giving the pandigital, \( 918273645 \), which is the concatenated product of \( 9 \) and \(( 1 \),\( 2 \),\( 3 \),\( 4 \),\( 5 )\).</p>
<p>What is the largest \( 1 \) to \( 9 \) pandigital \( 9 \)-digit number that can be formed as the concatenated product of an integer with \(( 1 \),\( 2 \), \( ... \) , \( n )\) where \( n&gt;1 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-37"><a class="header" href="#brute-force-37">Brute force</a></h1>
<p>I choose to take one number as a seed, and detect if the product of this seed can form a pandigital number.
To do this, you multiply the seed number by increasing numbers until the resulting number is either greater than 9 digits or a pandigital number.
Python's string functions make it easy to concatenate numbers, and a set is used to check if a number is pandigital.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0038/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_pandigital_multiples(seed):
    digits = str(seed)
    for j in itertools.count(2):
        digits += str(seed * j)
        if len(digits) &gt; 9:
            return -1
        if len(digits) == 9 and set(digits) == set(&quot;123456789&quot;):
            return int(digits)
</code></pre>
<p>The maximum value for the seed is 10000 because if we multiply 10000 by 1 and 2 and concatenate the results, we get a 10-digit number, which cannot be pandigital.
The solution is then given by iterating over every seed and returning the maximum pandigital number found.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0038/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pandigital_multiples():
    return max(is_pandigital_multiples(seed) for seed in range(1, 10000))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="good-old-pen-and-paper"><a class="header" href="#good-old-pen-and-paper">Good old pen and paper</a></h1>
<p>As is often the case with Project Euler problems, the problem can be solved with pen and paper.</p>
<p>Before anything, know that \( [0-9] \) means any digit between \( 0 \) and \( 9 \).</p>
<p>We know that the number to beat is \( 918273645 \), so any solution we find must be greater than that number.
We also know that the first multiplier is \( 1 \), so the first digit of our seed must start with \( 9 \).
We can discard any number in the form \( 9[0-9], 9[0-9][0-9] \) or any number greater than \( 100000 \), because none of them will result in a 9-digit number when multiplied by (1, 2, 3) or (1, 2, 3, 4).</p>
<p>Therefore, the solution must be of the form \( 9[0-9][0-9][0-9] \).</p>
<p>The solution must contain different digits and no zeros, because of the *1 multiplier.
It can not contain any 1 at all because it will be present twice.
One with the *1 multiplier and another because the *2 multiplier will result with the number of the form \( 18[0-9][0-9] \).</p>
<p>Therefore, the solution must be of the form \( 9[2-9][2-9][2-9] \).</p>
<p>We can continue these eliminations rules:</p>
<p>\[
\begin{align}
&amp;9[5-9][2-9][2-9] * 2 = 19[0-9][0-9][0-9] \text{, the *1 multiplier already contains a 9.}\\
&amp;94[5-9][2-9] * 2 = 189[0-9][0-9] \text{, the *1 multiplier already contains a 9.}\\
&amp;94[2-4][2-9] * 2 = 188[0-9][0-9] \text{, the double 8 is obviously wrong.}\\
&amp;937[2-7] * 2 = 187[0-9][0-9] \text{, the *1 multiplier already contains a 7.}\\
&amp;936[2-7] * 2 = 18724, 18726, 18728, 18730, 18732 \text{ or } 18734 \text{. They always lack the number 5 except for 18730 which have the number 4.}\\
&amp;935[2-7] * 2 = 187[0-1][0-9] \text{, contains either a 0 or a double 1.}\\
&amp;934[2-7] * 2 = 186[8-9][0-9] \text{, contains either a 9 or a double 8.}\\
&amp;933[2-7]  \text{ is obviously wrong because of the double 3.}\\
&amp;932[2-6] * 2 = 1864, 1866, 1868, 1870 \text{ or } 1872 \text{. They always lack the number 5 except for 1870 which lack the number 4.}\\
\end{align}
\]</p>
<p>Thus, the number must be \( 9327 \). Indeed, \( 9327 + 18654 \) is the number we are looking for.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-37"><a class="header" href="#solution-37">Solution</a></h1>
<hr />
<blockquote>
<p>932718654</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-right-triangles"><a class="header" href="#integer-right-triangles"><a href="https://projecteuler.net/problem=39">Integer right triangles</a></a></h1>
<blockquote>
<p>If \( p \) is the perimeter of a right angle triangle with integral length sides, \( \{a,b,c\} \), there are exactly three solutions for \( p=120 \).</p>
<p>\( \{20,48,52\}, \{24,45,51\}, \{30,40,50\} \)</p>
<p>For which value of \( p \leq 1000 \), is the number of solutions maximised?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-38"><a class="header" href="#brute-force-38">Brute force</a></h1>
<p>The problem actually requires us to find <a href="https://en.wikipedia.org/wiki/Pythagorean_triple">Pythagorean triples</a> with a perimeter of \( p \) less than \( 1000 \).
To find the solution for this problem, we can try every possible combination of values for \( \{a,b,c\} \) for every \( p \) and check if \( p = a + b + c \) and \( a^2 + b^2 = c^2 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def count_pythagorean_triple(p):
    count = 0
    for a in range(1, p):
        for b in range(1, p):
            for c in range(1, p):
                if a + b + c == p and a * a + b * b == c * c:
                    count += 1
    return count
</code></pre>
<p>We want to find the maximum value returned by <code>count_right_triangles</code> but return the \( p \) that corresponds to that value.
We can use the Python <a href="https://docs.python.org/3/library/functions.html#max">max</a> builtin with key equal to our function to get the \( p \) that corresponds to the maximum value returned by <code>count_right_triangles</code>.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def integer_right_triangles():
    return max(range(1, 1001), key=count_pythagorean_triple)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fewer-loops-is-better"><a class="header" href="#fewer-loops-is-better">Fewer loops is better</a></h1>
<p>The <a href="problems/problem_0039/./solution1.html">Brute force</a> solution is too slow because it tries too many combinations.
We should try to reduce the number of possible combinations using the following observations:</p>
<ul>
<li>\( 0 &lt; a \leq b &lt; c \) because \( a \) and \( b \) are the shorter sides of the triangle. (1)</li>
<li>\( c = p - a - b \) because \( a + b + c \) is the perimeter of the triangle. (2)</li>
</ul>
<p>We can remove one loop thanks to (2), and reduces the number of possible combinations by half thanks to (1).
Furthermore, we do not need to check the condition \( p = a + b + c \) because we defined \( c \) using this equation.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def count_pythagorean_triple(p):
    count = 0
    for a in range(1, p):
        for b in range(1, a):
            c = p - a - b
            if a * a + b * b == c * c:
                count += 1
    return count
</code></pre>
<p>Using the equations \( a^2 + b^2 = c^2 \) and \( p = a + b + c \) we can deduct the following:</p>
<ul>
<li>If both \( a \) and \( b \) are even, \( c \) will be even, thus \( p \) will be even.</li>
<li>If both \( a \) and \( b \) are odd, \( c \) will be even, thus \( p \) will be even.</li>
<li>If one is even and the other is odd, \( c \) will be odd, thus \( p \) will be even.</li>
</ul>
<p>Therefore, we can reduce the number of possible combinations by only considering \( p \) that are even.
The solution to the problem is the maximum number of solutions for \( p \) below \( 1000 \).</p>
<p>The function will be the same as the last one, except that we will only iterate over even values of \( p \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def integer_right_triangles():
    return max(range(2, 1001, 2), key=count_pythagorean_triple)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-fewer-loops"><a class="header" href="#even-fewer-loops">Even fewer loops</a></h1>
<p>The <a href="problems/problem_0039/./solution2.html">Fewer loops is better</a> solution is still very slow.
However, we can make the solution faster by using the equations \( c = p - a - b \) and \( a^2 + b^2 = c^2 \) together.</p>
<p>We can rewrite \( a^2 + b^2 = c^2 \) as \( a^2 + b^2 = (p - a - b)^2 \) and simplify it to \( 2b(p - a) = p(p - 2a) \).</p>
<p>Using this equation, we have \( b = \frac{p(p - 2a)}{2(p - a)} \).
We can use this information to remove the loop for \( b \).</p>
<p>Furthermore, \( b \) must be a positive integer and since \( 2(p - a) \) is always positive, \( p - 2a \) must be positive as well.
It implies that \( a &lt; 500 \).</p>
<p>Finally, we can iterate over all values of \( a \) less than \( 500 \), and check whether \( p(p - 2a) \) is divisible by \( 2(p - a) \).
Summing the number of solutions will give us the number of pythagorean triples for a given \( p \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def count_pythagorean_triple(p):
    return sum(p * (p - 2 * a) % (2 * (p - a)) == 0 for a in range(1, p // 2))
</code></pre>
<p>The rest is the same as the previous solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def integer_right_triangles():
    return max(range(2, 1001, 2), key=count_pythagorean_triple)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-of-primitive-pythagorean-triples"><a class="header" href="#tree-of-primitive-pythagorean-triples">Tree of primitive Pythagorean triples</a></h1>
<p>The <a href="problems/problem_0039/./solution3.html">Even fewer loops</a> solution is already fast, but we can continue to improve it.
Indeed, Pythagorean triples are a generalization of a special case called <a href="https://en.wikipedia.org/wiki/Pythagorean_triple#Primitive_Pythagorean_triple">primitive Pythagorean triples</a>, where \( a \), \( b \) and \( c \) are coprime.
There exists multiple ways to generate them, such as the <a href="https://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple">Euclid's formula</a>.</p>
<p>I prefer the <a href="https://en.wikipedia.org/wiki/Tree_of_primitive_Pythagorean_triples">Tree of primitive Pythagorean triples</a> method.
This method is based on the fact that all primitive Pythagorean triples has the structure of a tree.
We start with the root \( (3, 4, 5) \), which is the first primitive pythagorean triples, and then recursively generate the children of each node by multiplying it by a matrix \( A \), \( B \) or \( C \).</p>
<p>\( A \), \( B \) and \( C \) that are defined as:
\[
A = \begin{bmatrix}
1 &amp; -2 &amp; 2 \\
2 &amp; -1 &amp; 2 \\
2 &amp; -2 &amp; 3 \\
\end{bmatrix},
B = \begin{bmatrix}
1 &amp; 2 &amp; 2 \\
2 &amp; 1 &amp; 2 \\
2 &amp; 2 &amp; 3 \\
\end{bmatrix},
C = \begin{bmatrix}
-1 &amp; 2 &amp; 2 \\
-2 &amp; 1 &amp; 2 \\
-2 &amp; 2 &amp; 3 \\
\end{bmatrix}
\]</p>
<p>In our case we are also interested in the non-primitive Pythagorean triples.
To generate these triples, we can start with a primitive Pythagorean triple like \( a,b,c \) and multiply each value by a positive integer.
This will create a new triplet \( (k \times a, k \times b, k \times c) \) with perimeter \( p = k \times (a + b + c) \).
The limit of this multiplication factor \( k \) is restricted by \( p \) being less than \( 1000 \).</p>
<p>To put it all together, we can write a recursive function that will generate all the primitive Pythagorean triples with perimeter less than \( 1000 \).
From there, we can generate all the Pythagorean triples with perimeter less than \( 1000 \).
We will use <a href="https://numpy.org/">numpy</a> to represent the matrices and perform the multiplication.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution4.py">solution4.py</a>:</p>
<pre><code class="language-python">def compute_all_pythagorean_triples(results, max_p, abc):
    curr_p = sum(abc)
    if curr_p &lt; max_p:
        for perimeter in range(curr_p, max_p, curr_p):
            results[perimeter] += 1
        compute_all_pythagorean_triples(results, max_p, A @ abc)
        compute_all_pythagorean_triples(results, max_p, B @ abc)
        compute_all_pythagorean_triples(results, max_p, C @ abc)
</code></pre>
<p>Finally, we can count the number of solutions for each perimeter and return the one with the maximum number of solutions.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0039/solution4.py">solution4.py</a>:</p>
<pre><code class="language-python">def integer_right_triangles():
    results = defaultdict(int)
    compute_all_pythagorean_triples(results, 1001, np.array([3, 4, 5]))
    return max(results, key=results.get)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-38"><a class="header" href="#solution-38">Solution</a></h1>
<hr />
<blockquote>
<p>840</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="champernownes-constant"><a class="header" href="#champernownes-constant"><a href="https://projecteuler.net/problem=40">Champernowne's constant</a></a></h1>
<blockquote>
<p>An irrational decimal fraction is created by concatenating the positive integers:</p>
<p>\[
0.12345678910\color{red}{1}112131415161718192021...
\]</p>
<p>It can be seen that the \( 12 \)th digit of the fractional part is \( 1 \).</p>
<p>If \( d_n \) represents the nth digit of the fractional part, find the value of the following expression.</p>
<p>\[
d_{1} × d_{10} × d_{100} × d_{1000} × d_{10000} × d_{100000} × d_{1000000}
\]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-39"><a class="header" href="#brute-force-39">Brute force</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Champernowne_constant">Champernowne constant</a> is a number obtained by concatenating positive integers in decimal form.
The simplest way to solve this problem is to create a string with the required 1000000 digits and then extract the ones we need.</p>
<p>In Python, we can use the built-in <a href="https://docs.python.org/3/library/stdtypes.html#str.join">join</a> method to construct this string easily.
This function creates a string which is the concatenation of an iterable ; a range of integers in our case.</p>
<p>The final result is the product of the digits we need.
Combining the <a href="https://docs.python.org/3/library/functools.html#functools.reduce">reduce</a> function from the <a href="https://docs.python.org/3/library/functools.html">functools</a> module and the <a href="https://docs.python.org/3/library/functions.html#int">int</a> function with <a href="https://docs.python.org/3/library/operator.html#operator.mul">operator.mul</a>, we can get the product of a iterable of integers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0040/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def champernownes_constant():
    s = &quot;&quot;.join(str(i) for i in range(1, 1000000))
    print([int(s[10**i - 1]) for i in range(7)])
    return reduce(operator.mul, (int(s[10**i - 1]) for i in range(7)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreshadowing"><a class="header" href="#foreshadowing">Foreshadowing</a></h1>
<p>Although the <a href="problems/problem_0040/./solution1.html">Brute force</a> solution is fast, it will not scale well for larger values and is not an elegant solution.
To find a better solution, we need to understand how the champernowne constant is constructed.</p>
<p>For instance, a one-digit number (\(0...9\)) represents \( 9 \) digits in the string.
Meanwhile, a two-digit number (\(10...99\)) represents \( 180 \) digits in the string.
This is because there are \( 99 - 9 \) number between \( 10 \) and \( 99 \) with each two digits.
Thus, their concatenation results in \( 180 \) digits.</p>
<p>By examining the construction of the champernowne constant, we can find a pattern with \( d \) digits:</p>
<ul>
<li>\( d = 1 \): \( 1 \times (9 - 0) = 1 \times 9 = 9 \) digits</li>
<li>\( d = 2 \): \( 2 \times (99 - 9) = 2 \times 90 = 180 \) digits</li>
<li>\( d = 3 \): \( 3 \times (999 - 99) = 3 \times 900 = 2700 \) digits</li>
<li>\( d = 4 \): \( 4 \times (9999 - 999) = 4 \times 9000 = 36000 \) digits</li>
</ul>
<p>We can observ a clear pattern.
Specifically, for number with \( d \) digits, the number of digits of the concatenation is \( p(d) = 9d * 10^{d-1} \).</p>
<p>This patten allows us to divide the constant into chunks of digits that correspond to the concatenation of numbers with the same number of digits.
For instance:</p>
<ul>
<li>The first number with one digit starts at the \( 1^{th} \) digit of the champernowne constant.</li>
<li>The first number with two digits starts at the \( 1 + 9 = 10^{th} \) digit of the champernowne constant.</li>
<li>The first number with three digits start at the \( 1 + 9 + 180 = 190^{th} \) digit of the champernowne constant.</li>
</ul>
<p>To find the first number with \( d \) digits, we just need to sum the number of digits of all numbers with fewer digits.
We can define \( s(d) = 1 + \sum_{i=1}^{d-1} p(i) \) as the index of the first number with \( d \) digits in the champernowne constant.</p>
<p>Being able to find the first number with \( d \) digits is very useful.
Let's say we want to find \( d(1000) \), we know that \( s(3) = 190 \) and \( s(4) = 2890 \).
Thus, \( d(1000) \) is among the numbers with three digits.
The first number with three digits is at index \( 190 \), the second at index \( 190 + 3 \), the third at index \( 190 + 6 \) and so on.
To generalize, \( d(190 + 3k) \) is the first digit of the \( (100 + k)^{th} \) number.
We just need to find the greatest \( k \) such that \( 190 + 3k \leq 1001 \), which is \( k = 270 \).
So \( d(190 + 3 \times 270) = d(1000) \) is the first digit of \( 10^{d-1} + k = 100 + 270 = 370 \).
Hence \( d(1001) = 7 \).</p>
<p>In summary, to find \( d(n) \), we need to first search in which chunk of digits it lies.
This is achieved by finding the largest \( d \) such that \( s(d) \leq n \).
Next, we need to find the index of the number that contains \( d(n) \).
This is done by finding the largest \( k \) such that \( s(d) + d \times k \leq n \).
Finally, we can extract the \( (n - (s(d) + k \times d))^{th} \) digit from this number to obtain \( d(n) \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0040/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def d(n):
    s = lambda n: 1 + 9 * sum(i * 10 ** (i - 1) for i in range(1, n))
    digit = 1
    while s(digit) &lt;= n:
        digit += 1
    digit -= 1
    sd = s(digit)
    k = floor((n - sd) / digit)
    number = str(10 ** (digit - 1) + k)
    return int(number[n - (sd + k * digit)])
</code></pre>
<p>The final solution is obtained by multiplying the digit with the index of the problem.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0040/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def champernownes_constant():
    return reduce(operator.mul, (d(10**i) for i in range(7)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-39"><a class="header" href="#solution-39">Solution</a></h1>
<hr />
<blockquote>
<p>210</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pandigital-prime"><a class="header" href="#pandigital-prime"><a href="https://projecteuler.net/problem=41">Pandigital prime</a></a></h1>
<blockquote>
<p>We shall say that an \( n \)-digit number is pandigital if it makes use of all the digits \( 1 \) to \( n \) exactly once. For example, \( 2143 \) is a \( 4 \)-digit pandigital and is also prime.</p>
<p>What is the largest \( n \)-digit pandigital prime that exists?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-40"><a class="header" href="#brute-force-40">Brute force</a></h1>
<p>Based on the definition of a pandigital number, we can deduce that it cannot contain more than 9 digits.
Therefore, we can iterate through every permutation of the digits in decreasing order until we find a prime number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0041/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pandigital_prime():
    initial = &quot;987654321&quot;
    while True:
        for s in itertools.permutations(initial):
            n = int(&quot;&quot;.join(s))
            if isprime(n):
                return n
        initial = initial[1:]
</code></pre>
<p>Moreover, we can optimize the function slightly by taking into account that the sum of the digits in a 9-digit pandigital number is always 45, which makes it divisible by 3 and hence not prime.
The same applies to 8-digit pandigital numbers.
Therefore, we can skip these cases and start directly with 7-digit pandigital numbers.
However, the overall algorithm remains the same.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-40"><a class="header" href="#solution-40">Solution</a></h1>
<hr />
<blockquote>
<p>7652413</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="coded-triangle-numbers"><a class="header" href="#coded-triangle-numbers"><a href="https://projecteuler.net/problem=42">Coded triangle numbers</a></a></h1>
<blockquote>
<p>The n\( ^{th} \) term of the sequence of triangle numbers is given by, \( t_n=\frac{1}{2}n(n+1) \); so the first ten triangle numbers are:</p>
<p>\[
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
\]</p>
<p>By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is \( 19+11+25=55=t_{10} \). If the word value is a triangle number then we shall call the word a triangle word.</p>
<p>Using <a href="https://projecteuler.net/project/resources/p042_words.txt">words.txt</a> (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-41"><a class="header" href="#brute-force-41">Brute force</a></h1>
<p>The problem gave us a file with quoted words separated by commas.
The first step is to read the file and split the words into a list.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0042/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as f:
        return [word.strip('&quot;') for word in f.read().split(&quot;,&quot;)]
</code></pre>
<p>Subsequently, we need to check if the word is a triangle word.
A word is considered a triangle word if the sum of the alphabetical position of its letters is a triangle number.
A triangle number is defined by the formula \( \frac{1}{2}n(n+1) \), but we are interested in finding the \( n \) that satisfies this formula.
To solve it, we can use the equation:</p>
<p>\[
x = \frac{1}{2}n(n+1) \Rightarrow n^2 + n - 2x = 0 \Rightarrow n = \frac{\pm \sqrt{1 + 8x} - 1}{2}
\]</p>
<p>The negative solution \( \frac{- \sqrt{1 + 8x} - 1}{2} \) can be disregarded since we are only interested in positive integers.
We can determine if \( x \) is a triangle number by checking if the value of \( \frac{\sqrt{1 + 8x} - 1}{2} \) is an integer.
Which can be done easily using the <a href="https://docs.python.org/3/library/stdtypes.html#float.is_integer">is_integer</a> python function.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0042/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_triangle_number(x):
    return (((1 + 8 * x) ** 0.5 - 1) / 2).is_integer()
</code></pre>
<p>Finally, we can iterate over each word in the list, calculate its value, and verify if it is a triangle number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0042/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def coded_triangle_numbers():
    words = read_file(&quot;words.txt&quot;)
    return sum(is_triangle_number(sum(ord(c) - ord(&quot;A&quot;) + 1 for c in word)) for word in words)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-41"><a class="header" href="#solution-41">Solution</a></h1>
<hr />
<blockquote>
<p>162</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="sub-string-divisibility"><a class="header" href="#sub-string-divisibility"><a href="https://projecteuler.net/problem=43">Sub-string divisibility</a></a></h1>
<blockquote>
<p>The number, \( 1406357289 \), is a \( 0 \) to \( 9 \) pandigital number because it is made up of each of the digits \( 0 \) to \( 9 \) in some order, but it also has a rather interesting sub-string divisibility property.</p>
<p>Let \( d_1 \) be the \( 1^{st} \) digit, \( d_2 \) be the \( 2^{nd} \) digit, and so on. In this way, we note the following:</p>
<p>\[
\begin{align}
&amp;d_2d_3d_4=406\text{ is divisible by }2\\
&amp;d_3d_4d_5=063\text{ is divisible by }3\\
&amp;d_4d_5d_6=635\text{ is divisible by }5\\
&amp;d_5d_6d_7=357\text{ is divisible by }7\\
&amp;d_6d_7d_8=572\text{ is divisible by }11\\
&amp;d_7d_8d_9=728\text{ is divisible by }13\\
&amp;d_8d_9d_{10}=289\text{ is divisible by }17\\
\end{align}
\]</p>
<p>Find the sum of all \( 0 \) to \( 9 \) pandigital numbers with this property.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-42"><a class="header" href="#brute-force-42">Brute force</a></h1>
<p>The problem can be split into two parts:</p>
<ul>
<li>Check if the permutation satisfies the divisibility property.</li>
<li>Find all the permutations of the digits \( 0 \) to \( 9 \).</li>
</ul>
<p>The first part can be done by checking if a particular section of the number is divisible by the corresponding prime number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0043/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_sub_string_divisible(n):
    divisors = [2, 3, 5, 7, 11, 13, 17]
    return all(int(str(n)[i + 1 : i + 4]) % d == 0 for i, d in enumerate(divisors))
</code></pre>
<p>The second part is done by using the <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations">itertools.permutations</a> function.
With the caveat that any permutation starting with \( 0 \) should be disregarded.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0043/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sub_string_divisibility():
    res = 0
    for i in itertools.permutations(&quot;9876543210&quot;):
        if i[0] == &quot;0&quot;:
            continue
        x = int(&quot;&quot;.join(i))
        if is_sub_string_divisible(x):
            res += x
    return res
</code></pre>
<p>It is worth noting that if we encounter a permutation beginning with \( 0 \), we can immediately return the result without further iterations, as all other permutations will also start with \( 0 \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generation-over-iteration"><a class="header" href="#generation-over-iteration">Generation over iteration</a></h1>
<p>Rather than iterating over all permutations and verifying the divisibility property like the <a href="problems/problem_0043/./solution2.html">Brute force</a> method, a more efficient solution is to recursively generate permutations that satisfy the divisibility property.</p>
<p>The process begins with all pandigital permutations with 3 digits that are divisible by \( 2 \).
Then we can generate all the permutations with 4 digits that are divisible by \( 3 \) by appending the new digits at the end of the previous permutations.
We can continue this process until all permutations with 10 digits are generated.</p>
<p>Since the first digit is not important in the divisibility property, it is simpler to start from the end of the number.
Thus, we begin with the permutations that are divisible by \( 17 \) and continue adding the remaining digits at the beginning of the previous permutations.</p>
<p>Because the final number cannot start with \( 0 \), we can disregard the permutations that start with \( 0 \) in the final concatenation.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0043/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sub_string_divisibility():
    digits = &quot;0123456789&quot;
    items = [x + y for x in digits for y in digits if x != y]  # Permutations of 2 digits

    for d in [17, 13, 11, 7, 5, 3, 2]:
        items = [
            y + x for x in items for y in digits if int((y + x)[:3]) % d == 0 and y not in x
        ]  # Concatenation at the beginning

    items = [int(y + x) for x in items for y in digits[1:] if y not in x]  # Last concatenation

    return sum(items)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-pen-and-paper-1"><a class="header" href="#with-pen-and-paper-1">With pen and paper</a></h1>
<p>As often with these problems, it is possible to find the solution by hand.
The crucial aspect of these solutions is reducing the set of potential solutions.</p>
<p>The \( d_4d_5d_6 \) must be divisible by \( 5 \), thus \( d_6 \) must be \( 0 \) or \( 5 \).
If \( d_6 = 0 \), \( 0d_7d_8 \) must be divisible by \( 11 \), which implies that \( d_7 = d_8 \).
This is a contradiction since the number is pandigital, thus \( d_6 \) must be \( 5 \).</p>
<p>All the number \( 5d_7d_8 \) that can be divided by \( 17 \) are: \( 506, 517, 528, 539, 550, 561, 572, 583 \) and \( 594 \), but \( 550 \) is not pandigital.
Let us now check the number \( d_6d_7d_8 \) that are divisible by \( 13 \), with \( d_6d_7 \) being defined with the above solution:</p>
<ul>
<li>\( 06x \Rightarrow x = 5 \), but \( 5 \) is already used.</li>
<li>\( 17x \) has no solution.</li>
<li>\( 28x \Rightarrow x = 6\), gives \( 286 \) as a possible solution.</li>
<li>\( 39x \Rightarrow x = 0 \), gives \( 390 \) as a possible solution.</li>
<li>\( 61x \Rightarrow x = 1 \), but \( 1 \) is already used.</li>
<li>\( 72x \Rightarrow x = 8 \), gives \( 728 \) as a possible solution.</li>
<li>\( 83x \Rightarrow x = 2 \), gives \( 832 \) as a possible solution.</li>
<li>\( 94x \Rightarrow x = 9 \), but \( 9 \) is already used.</li>
</ul>
<p>The current only possible solution for \( d_6d_7d_8d_9 \) are \( 5286, 5390, 5728\text{ and }5832 \).</p>
<p>We can continue with the same process for the divisibility by \( 17 \):</p>
<ul>
<li>\( 86x \Rightarrow x = 7 \), gives \( 867 \) as a possible solution.</li>
<li>\( 90x \Rightarrow x = 1 \), gives \( 901 \) as a possible solution.</li>
<li>\( 28x \Rightarrow x = 9 \), gives \( 289 \) as a possible solution.</li>
<li>\( 32x \Rightarrow x = 3 \), but \( 3 \) is already used.</li>
</ul>
<p>The current only possible solution for \( d_6d_7d_8d_9d_{10} \) are \( 52867, 53901\text{ and }57289 \).</p>
<p>We can continue with the same process for the divisibility by \( 7 \):</p>
<ul>
<li>\( x52 \Rightarrow x = 2 \) or \( x = 9 \), but \( 2 \) is already used, gives \( 952 \) as a possible solution.</li>
<li>\( x53 \Rightarrow x = 5 \), but \( 5 \) is already used.</li>
<li>\( x57 \Rightarrow x = 3 \), gives \( 357 \) as a possible solution.</li>
</ul>
<p>The current only possible solution for \( d_5d_6d_7d_8d_9d_{10} \) are \( 952867, \text{ and }357289 \).</p>
<p>For \( d_2d_3d_4 \) to be divisible by \( 2 \), \( d_4 \) must be even, with the remaining possible digits being \( 0 \) or \( 4 \) for \( 952867 \) and \( 0, 4 \) or \( 6 \) for \( 357289 \).</p>
<p>Thus, the only possible solutions are for \( d_4d_5d_6d_7d_8d_9d_{10} \) are \( 0952867\), \( 4952867 \), \( 0357289 \), \( 4357289 \), and \( 6357289 \).</p>
<p>The last divisibility property requires \( d_3d_4d_5 \) to be divisible by \( 3 \), which implies that \( d_3 + d_4 + d_5 \) must be divisible by \( 3 \).
With the remaining digits, we can check all the possible solutions:</p>
<ul>
<li>\( x09 \Rightarrow x = 3 \), gives \( 309 \) as a possible solution.</li>
<li>\( x49 \) has no solution with the available digit \( 0 \), \( 1 \), or \( 3 \).</li>
<li>\( x03 \Rightarrow x = 6 \), gives \( 603 \) as a possible solution.</li>
<li>\( x43 \) has no solution with the available digit \( 0 \), \( 1 \), or \( 6 \).</li>
<li>\( x63 \Rightarrow x = 0 \), gives \( 063 \) as a possible solution. </li>
</ul>
<p>The current only possible solution for \( d_3d_4d_5d_6d_7d_8d_9d_{10} \) are \( 30952867 \), \( 60357289 \), and \( 06357289 \).
All permutations of these numbers with the remaining digits give a solution that satisfies the divisibility property.</p>
<p>The sum of all this numbers is the solution to the problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-42"><a class="header" href="#solution-42">Solution</a></h1>
<hr />
<blockquote>
<p>16695334890</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="pentagon-numbers"><a class="header" href="#pentagon-numbers"><a href="https://projecteuler.net/problem=44">Pentagon numbers</a></a></h1>
<blockquote>
<p>Pentagonal numbers are generated by the formula, \( P_n=\frac{n(3n−1)}{2} \). The first ten pentagonal numbers are:</p>
<p>\[ 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ... \]</p>
<p>It can be seen that \( P_4 + P_7 = 22 + 70 = 92 = P_8 \). However, their difference, \( 70 − 22 = 48 \), is not pentagonal.</p>
<p>Find the pair of pentagonal numbers, \( P_j \) and \( P_k \), for which their sum and difference are pentagonal and \( D = |P_k − P_j| \) is minimised; what is the value of \( D \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-43"><a class="header" href="#brute-force-43">Brute force</a></h1>
<p>The problem can be decomposed into two distinct tasks:</p>
<ul>
<li>Verification whether a number is pentagonal or not.</li>
<li>Determination of the lower bound for the iteration through pentagonal pairs.</li>
</ul>
<p>The first task can be approached similarly to <a href="problems/problem_0044/../problem_0042/solution1.html">problem 42</a>, by using the equation \( x = \frac{1}{2}n(3n-1) \) and searching for \( n \).</p>
<p>\[
x = \frac{1}{2}n(3n-1) \Rightarrow 3n^2 - n - 2x = 0 \Rightarrow n = \frac{\pm \sqrt{1 + 24x} + 1}{6}
\]</p>
<p>Since we are only concerned with positive integers, the negative solution \( \frac{- \sqrt{1 + 24x} + 1}{6} \) can be disregarded.
There, a number is pentagonal if \( \frac{\sqrt{1 + 24x} + 1}{6} \) is an integer.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0044/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_pentagonal(n):
    return ((1 + (1 + 24 * n) ** 0.5) / 6).is_integer()
</code></pre>
<p>The second task is a bit more tricky since there is no obvious lower bound to terminates the iteration.
The only constraints is that that solution \( D \) must be minimal.
As the sequence of pentagonal numbers is strictly increasing, at some point, the difference between two successive numbers will exceed the current result.
Consequently, the iteration can be stopped, as all subsequent numbers will also surpass the current solution.</p>
<p>The difference between \( P_n \) and \( P_{n+1} \) is:
\[ P_{n+1} - P_n = \frac{1}{2}(n+1)(3(n+1)-1) - \frac{1}{2}n(3n-1) = 3n + 1 \]</p>
<p>Hence, the iteration should stop when \( 3n + 1 &gt; D \), which is finite assuming there is a solution.</p>
<p>The approach is to iterate through all pairs of pentagonal numbers \( P_i \) and \( P_j \) with \( j &lt; i \) and verify if both \( P_i + P_j \) and \( P_i - P_j \) are pentagonal.
If they are, we have found a solution, and the iteration continues until \( 3 * i + 1 &gt; D \), at which point the current result is the final solution.</p>
<p>To optimize the search, it is more efficient to iterate backwards through \( P_j \) since we are searching for the smallest \( D \) that satisfies the condition.
When \( P_i - P_j &gt; D \), the iteration through \( P_j \) can be stopped.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0044/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pentagon_numbers():
    res = float(&quot;inf&quot;)
    pn = lambda n: n * (3 * n - 1) // 2
    for i in itertools.count(2):
        if 3 * i + 1 &gt; res:
            break
        for j in range(i - 1, 0, -1):
            a = pn(i)
            b = pn(j)
            if a - b &gt; res:
                break
            if is_pentagonal(a + b) and is_pentagonal(a - b) and a - b &lt; res:
                res = a - b
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimal-iteration"><a class="header" href="#optimal-iteration">Optimal iteration</a></h1>
<p>The main reason the <a href="problems/problem_0044/./solution1.html">Brute force</a> approach is slow is that the iteration does not increase \( D \) monotonically.
For example, the previous solution tries the values of \( D \) in the following order: \( 4 \),\( 7 \),\( 11 \),\( 10 \),\( 17 \),\( 21 \),\( 13 \),\( 23 \),\( 30 \),\( 34 \),\( 16 \)...</p>
<p>Starting with the smallest possible value of \( D \) and increasing it until a solution is found is the optimal iteration approach, as it guarantees the solution with the minimal \( D \).
To implement it, we need to iterate through values of \( D \).
By definition \( D = P_d = P_i - P_j \) where \( j &lt; i \), it is necessary to determine a method for computing \( i \) and \( j \) from \( d \).</p>
<p>\[
\begin{aligned}
P_d &amp;= P_i - P_j\\
&amp;= P_{j+x} - P_{j}\\
&amp;= \frac{6jx +3x^2 - x}{2}\\
&amp;= 3jx + P_x\\
&amp;\Rightarrow j = \frac{P_d - P_x}{3x}\\
\end{aligned}
\]</p>
<p>The following can be concluded from the above equation:</p>
<ul>
<li>\( j \) must be an integer, so \( P_d &gt; P_x \), thus \( 0 &lt; x &lt; d \) and \( P_d - P_x \equiv 0 \pmod{3x} \).</li>
<li>\( P_d - P_x = 3(d^2 - x^2) + d - x \Rightarrow x \equiv d \pmod{3} \).</li>
</ul>
<p>Therefore, we can iterate over every \( d \) and \( x \) such that \( 0 &lt; x &lt; d \) and \( x \equiv d \pmod{3} \).
If \( P_d - P_x \equiv 0 \pmod{3x} \), then we can compute \( j \) and \( i = x + j \).
By definition, \( P_d \) is pentagonal, so if \( P_i + P_j \) is also pentagonal, then \( D = P_d \) is the solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0044/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def pentagon_numbers():
    for d in itertools.count(4):
        pd = pn(d)
        for x in range(d - 3, 0, -3):
            px = pn(x)
            if (pd - px) % (3 * x) == 0:
                j = (pd - px) // (3 * x)
                k = x + j
                if is_pentagonal(pn(k) + pn(j)):
                    return pd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-better-iteration"><a class="header" href="#even-better-iteration">Even better iteration</a></h1>
<p>The <a href="problems/problem_0044/./solution2.html">Optimal iteration</a> approach is much faster than the <a href="problems/problem_0044/./solution1.html">Brute force</a> approach.
However, for large value of \( d \) the iteration through all the possible \( x \) is still slow.
Let's try to add more constraints to reduce the numbers of possibility.</p>
<p>The last solution gave the following equation:</p>
<p>\[
\begin{aligned}
P_d &amp; = P_i - P_j\\
\Leftrightarrow d(3d - 1) &amp;= i(3i - 1) - j(3j - 1) \\
&amp;= (i - j)(3(i + j) - 1) \\
\end{aligned}
\]</p>
<p>The following can be concluded from the above equation:</p>
<ul>
<li>\( i - j \equiv 0 \pmod{d(3d + 1)} \).</li>
<li>Since \( i \), \( j \), and \( d \) are positive integers, it follows that \( 0 &lt; i - j &lt; d \) because if \( d &lt; i - j \), then \( 3d - 1 &lt; 3(i - j) - 1 &lt; 3(i + j) - 1 \) which implies that \( d(3d - 1) &lt; (i - j)(3i - 3i - 1) \) because \(d, i, j \), a contradiction.</li>
<li>\( i - j \equiv d \pmod{3} \) because \( 3d - 1 \equiv 3(i + j) - 1 \equiv 2 \pmod{3} \).</li>
</ul>
<p>To summarize, we are searching for all \( i \) and \( j \) that satisfy:
\[
\begin{align}
&amp;i\text{ and }j\text{ are positive integers.} \tag{0}\\
&amp;0 &lt; i - j &lt; d \tag{1}\\
&amp;i - j \equiv d \pmod{3} \tag{2}\\
&amp;3(i + j) - 1 \equiv 2 \pmod{3} \tag{3}\\
&amp;i - j \equiv 0 \pmod{d(3d + 1)} \tag{4}\\
\end{align}
\]</p>
<p>The solution can be found by iterating through all values of \( d \) and find all divisors \( r_1 = i - j \) that satisfy equation \( 3 \) and \( 4 \).</p>
<p>If \( i = \frac{r_1 + \frac{(r_2 + 1)}{3}}{2} \) is an integer (equation 0), then \( j = i - r_1 \).
If both \( P_i \) and \( P_j \) are pentagonal numbers, then the solution is \( P_d \).</p>
<p>It is important to know that this approach is not as efficient as the previous one for small values of \( d \), but it is significantly faster for large values of \( d \), especially if the function for obtaining all the divisors of \( d(3d + 1) \) is optimized.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0044/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def pentagon_numbers():
    pn = lambda n: n * (3 * n - 1) // 2
    for d in itertools.count(4):
        for r1 in get_divisors(d):  # Equation 4
            r2 = d * (3 * d - 1) // r1
            if r2 % 3 == 2:  # Equation 3
                i = (r1 + (r2 + 1) // 3) / 2
                if i.is_integer():  # Equation 0
                    j = i - r1
                    if is_pentagonal(pn(i) + pn(j)):
                        return pn(d)
</code></pre>
<p>It is also worth noting that the pandigital number could be cached, as many of them are computed multiple times.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-43"><a class="header" href="#solution-43">Solution</a></h1>
<hr />
<blockquote>
<p>5482660</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="triangular-pentagonal-and-hexagonal"><a class="header" href="#triangular-pentagonal-and-hexagonal"><a href="https://projecteuler.net/problem=45">Triangular, pentagonal, and hexagonal</a></a></h1>
<blockquote>
<p>Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:</p>
<p>\[
\begin{align*}
&amp;\text{Triangle }&amp;&amp;Tn=\frac{n(n+1)}{2} &amp;&amp;1, 3, 6, 10, 15, ...\\
&amp;\text{Pentagonal }&amp;&amp;Pn=\frac{n(3n−1)}{2} &amp;&amp; 1, 5, 12, 22, 35, ...\\
&amp;\text{Hexagonal }&amp;&amp;Hn=n(2n−1) &amp;&amp;1, 6, 15, 28, 45, ...\\
\end{align*}
\]
It can be verified that \( T_{285} = P_{165} = H_{143} = 40755 \).</p>
<p>Find the next triangle number that is also pentagonal and hexagonal.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-44"><a class="header" href="#brute-force-44">Brute force</a></h1>
<p>The brute force approach for solving this problem is straightforward.
To start, a function is needed to compute \( T_n \), \( P_n \) and \( H_n \) for a given \( n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def tn(n):
    return n * (n + 1) // 2
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def pn(n):
    return n * (3 * n - 1) // 2
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def hn(n):
    return n * (2 * n - 1)
</code></pre>
<p>Then, a while loop can be implemented to iterate until all three numbers are equal.
At each iteration, only update one of the two smallest value among \( T_n \), \( P_n \) and \( H_n \).
This is because \( T_n \), \( P_n \) and \( H_n \) are all increasing functions of \( n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def triangular_pentagonal_and_hexagonal():
    t, p, h = 286, 166, 144
    ti, pi, hi = tn(t), pn(p), hn(h)
    while not ti == pi == hi:
        if ti &lt; pi:
            t += 1
            ti = tn(t)
        elif pi &lt; hi:
            p += 1
            pi = pn(p)
        else:
            h += 1
            hi = hn(h)
    return ti
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="triangular-numbers-are-useless"><a class="header" href="#triangular-numbers-are-useless">Triangular numbers are useless</a></h1>
<p>Let's start by observing the first ten Triangular, pentagonal, and hexagonal numbers:</p>
<ul>
<li>Triangular: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...</li>
<li>Pentagonal: 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...</li>
<li>Hexagonal: 1, 6, 15, 28, 45, 66, 91, 120, 153, 190, ...</li>
</ul>
<p>It appears that every Hexagonal number is also a Triangular number, specifically \( H_n = T_{2n - 1} \).
This relationship is true because \( T_{2n - 1} = \frac{(2n - 1)(2n)}{2} = H_n \).
Since every Hexagonal number is also a Triangular number, it's pointless to compute Triangular numbers.
Therefore, it is sufficient to iterate through every Hexagonal number and verify if it is also a Pentagonal number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def is_pentagonal(n):
    return ((1 + (1 + 24 * n) ** 0.5) / 6).is_integer()
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def triangular_pentagonal_and_hexagonal():
    h = 145
    while not is_pentagonal(hn(h)):
        h += 1
    return hn(h)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diophantine-equations"><a class="header" href="#diophantine-equations">Diophantine equations</a></h1>
<p>The <a href="problems/problem_0045/./solution2.html">Triangular numbers are useless</a> approach exploits the fact that Triangular numbers are useless.
Thus, it is sufficient to find \( H_n = T_n \Leftrightarrow 3n^2 - n + 4m^2 - 4m = 0 \).
This is known as a <a href="https://en.wikipedia.org/wiki/Diophantine_equation">Diophantine equation</a>.
This problem is very hard to solve in general, so we will use this <a href="https://www.alpertron.com.ar/QUAD.HTM">solver</a> to find the solution.</p>
<p>It gives the following recurrence relation:</p>
<p>\[ 
x_{n + 1} = 97x_n + 112y_n - 44\\
y_{n + 1} = 84x_n + 97y_n - 38
\]</p>
<p>Starting with the solution \( (n, m) = (1, 1) \), we can easily find the third solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0045/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def triangular_pentagonal_and_hexagonal():
    x_n = lambda x_i, y_i: 97 * x_i + 112 * y_i - 44
    y_n = lambda x_i, y_i: 84 * x_i + 97 * y_i - 38

    x, y = 1, 1
    x, y = x_n(x, y), y_n(x, y)
    y = y_n(x, y)
    return y * (2 * y - 1)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-44"><a class="header" href="#solution-44">Solution</a></h1>
<hr />
<blockquote>
<p>1533776805</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="goldbachs-other-conjecture"><a class="header" href="#goldbachs-other-conjecture"><a href="https://projecteuler.net/problem=46">Goldbach's other conjecture</a></a></h1>
<blockquote>
<p>It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.</p>
<p>\[
9 = 7 + 2×1^{2}\\\\
15 = 7 + 2×2^{2}\\\\
21 = 3 + 2×3^{2}\\\\
25 = 7 + 2×3^{2}\\\\
27 = 19 + 2×2^{2}\\\\
33 = 31 + 2×1^{2}
\]</p>
<p>It turns out that the conjecture was false.</p>
<p>What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-45"><a class="header" href="#brute-force-45">Brute force</a></h1>
<p>The brute force approach for determining the minimal odd composite number that does not satisfy the Goldbach's other conjecture can be separated into two steps:</p>
<ul>
<li>Verify whether a number satisfies the Goldbach's other conjecture.</li>
<li>Iterate through all odd composite numbers.</li>
</ul>
<p>The first step can be brute force by iterating through every \( i \leq n \) and verify if \( i \) is prime and \( \sqrt{\frac{n-i}{2}} \) is an integer.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0046/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_odd_goldbach(n):
    return any(isprime(i) and (((n - i) / 2) ** 0.5).is_integer() for i in range(1, n + 1))
</code></pre>
<p>Assuming the existence of a solution, the second part is straightforward and can be done by iterating through all odd composite numbers until a solution is found.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0046/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def goldbachs_other_conjecture():
    for i in itertools.count(7, 2):
        if not is_odd_goldbach(i):
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="better-iteration-and-caching"><a class="header" href="#better-iteration-and-caching">Better iteration and caching</a></h1>
<p>The <a href="problems/problem_0046/./solution1.html">Brute force</a> approach is fast enough because the solution is small.
But the function that determines whether a number satisfies the Goldbach's other conjecture can be further optimized.</p>
<p>The key is to iterate through all double squares \( 2i^2 \) with \( i \leq \sqrt{\frac{n}{2}} \) and check whether \(n - 2i^2 \) is prime.
Additionally, a cache of prime numbers can be used and updated when a new prime number is found.
New primes can only be found if \( n \) is prime, because \( n - 2i^2 \) prime implies that a previous composite number was prime.
Thus, the cache is updated if \( n \) is prime, if not, it can be used to determine whether \( n - 2i^2 \) is prime.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0046/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def is_odd_goldbach(n, primes_cache):
    if isprime(n):
        primes_cache.add(n)
        return True

    return any(n - 2 * i**2 in primes_cache for i in range(1, int(n**0.5) + 1))
</code></pre>
<p>The rest stays the same.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0046/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def goldbachs_other_conjecture():
    primes_cache = {2, 3, 5}
    for i in itertools.count(7, 2):
        if not is_odd_goldbach(i, primes_cache):
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-45"><a class="header" href="#solution-45">Solution</a></h1>
<hr />
<blockquote>
<p>5777</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="distinct-primes-factors"><a class="header" href="#distinct-primes-factors"><a href="https://projecteuler.net/problem=47">Distinct primes factors</a></a></h1>
<blockquote>
<p>The first two consecutive numbers to have two distinct prime factors are:</p>
<p>\[
14 = 2 × 7\\\\
15 = 3 × 5
\]</p>
<p>The first three consecutive numbers to have three distinct prime factors are:</p>
<p>\[
\begin{align}
644 &amp;= 2^2 × 7 × 23\\
645 &amp;= 3 × 5 × 43\\
646 &amp;= 2 × 17 × 19.
\end{align}
\]</p>
<p>Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-46"><a class="header" href="#brute-force-46">Brute force</a></h1>
<p>To find the first four consecutive integers that possess four distinct prime factors each using a brute force approach can be separated into two steps:</p>
<ul>
<li>Find the prime decomposition of a number.</li>
<li>Iterate over all numbers and check if the next four numbers have four distinct prime factors each.</li>
</ul>
<p>The prime decomposition has previously been implemented in other problems and, therefore, is not an important component for this approach.
To solve this part, the <a href="https://docs.sympy.org/latest/modules/ntheory.html#sympy.ntheory.factor_.primefactors">sympy.primefactors</a> function can be used.</p>
<p>The iteration process is straightforward, and the number of distinct primes can be determined using the length of the set of the prime decomposition.
To identify the solution, check the next four numbers that have four distinct prime factors each, and return the first number that satisfies this condition.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0047/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def distinct_primes_factors():
    for i in itertools.count(5):
        if (
            len(set(primefactors(i)))
            == len(set(primefactors(i + 1)))
            == len(set(primefactors(i + 2)))
            == len(set(primefactors(i + 3)))
            == 4
        ):
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cache-is-life"><a class="header" href="#cache-is-life">Cache is life</a></h1>
<p>A clear strategy to enhance the <a href="problems/problem_0047/./solution1.html">Brute force</a> approach is to cache some results.
At each iteration, only the prime decomposition of the current number needs to be computed.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0047/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def distinct_primes_factors():
    cache = [False] * 4
    for i in itertools.count(1):
        cache[i % 4] = len(set(primefactors(i))) == 4
        if all(cache):
            return i - 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="good-old-sieve"><a class="header" href="#good-old-sieve">Good old Sieve</a></h1>
<p>The <a href="problems/problem_0047/./solution2.html">Cache is life</a> approach involves computing the prime decomposition of each number, which is a costly operation that can be avoided using a sieve.
The downside of this approach is that the sieve requires an arbitrary limit, but it can be increased until the solution is found.
Instead of determining which number are primes, the sieve stores the number of distinct prime factors for each number.</p>
<p>The <a href="https://docs.sympy.org/latest/modules/ntheory.html#sympy.ntheory.factor_.primefactors">sympy.primefactors</a> function combined multiples algorithm, making its exact complexity difficult to determine.
Nevertheless, it is expected to be no more than \( O(sqrt{n}) \), resulting in a previous approach of \( O(n\sqrt{n}) \).</p>
<p>The Sieve of Eratosthenes complexity is \( O(n\log\log{n}) \), which is better than the previous approach.
In practive, \( \log\log{n} \) is very small and can be disregarded for simplicity, resulting in a complexity of \( O(n) \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0047/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def factors_sieves(n):
    factors = [0] * (n + 1)
    consecutive = 0
    for i in range(2, n + 1):
        if factors[i] == 0:
            for j in range(2, int(n / i)):
                factors[i * j] += 1
            consecutive = 0
        elif factors[i] == 4:
            consecutive += 1
        else:
            consecutive = 0

        if consecutive == 4:
            return i - 3
    return None
</code></pre>
<p>To find the final solution, one can arbitrarily choose a limit and attempt to find a solution.
If no solution is found, the limit can be multiplied by two, and the process can be repeated.
The complexity of this operation is \( O(1 + 2 + 4 + 8 ... + n) \) which is equal to \( O(2n) \) and equivalent to \( O(n) \).</p>
<p>In theory, this approach should be faster than the previous one, but in practice, it may not be faster for small limits.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0047/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def distinct_primes_factors():
    for i in itertools.count(1):
        res = factors_sieves(2**i)
        if res is not None:
            return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-46"><a class="header" href="#solution-46">Solution</a></h1>
<hr />
<blockquote>
<p>134043</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-powers"><a class="header" href="#self-powers"><a href="https://projecteuler.net/problem=48">Self powers</a></a></h1>
<blockquote>
<p>The series, \( 1^{1}+2^{2}+3^{3}+...+10^{10}=10405071317 \).</p>
<p>Find the last ten digits of the series, \( 1^{1}+2^{2}+3^{3}+...+1000^{1000} \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-47"><a class="header" href="#brute-force-47">Brute force</a></h1>
<p>The naive approach consists of computing the sum of the series and then take the last 10 digits.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0048/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def self_powers():
    return sum(i**i for i in range(1, 1001)) % 10**10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modulus-reduction"><a class="header" href="#modulus-reduction">Modulus reduction</a></h1>
<p>The <a href="problems/problem_0048/./solution1.html">Brute force</a> approach only works thanks to Python's infinite precision integers.
In other languages, the result of \( 1000^{1000} \) is too large to be stored in an integer.</p>
<p>Thus, the need of a <a href="https://en.wikipedia.org/wiki/Modular_exponentiation#Direct_method">modulus exponentiation</a> algorithm, which exploits the property that \(a \times b \pmod{m} = [(a \pmod{m}) \times (b \pmod{m})] \pmod{m} \) for any \( m \).
Although modulus exponentiation may involve more multiplications than exponentiation followed by modulus, because optimized exponentiation algorithms are better than \( O(n) \).
In modulus exponentiation the base is always bound by \( m \), leading to smaller exponentiation and faster computation overall.
Consequently, this method reduce both the memory usage, which make it suitable for other languages, and the computation time.</p>
<p>The use of <a href="https://docs.python.org/3/library/functools.html#functools.reduce">functools.reduce</a> eliminates the need for a loop and is a more efficient and elegant solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0048/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def mod_pow(b, e, mod):
    return reduce(lambda acc, _: (acc * b) % mod, range(e), 1)
</code></pre>
<p>Similarly, the cumulative sum can also be computed using <a href="https://docs.python.org/3/library/functools.html#functools.reduce">functools.reduce</a>.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0048/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def self_powers():
    mod = 10**10
    sums = (mod_pow(i, i, mod) for i in range(1, 1001))
    return reduce(lambda acc, y: (acc + y) % mod, sums)
</code></pre>
<p>It is worth mentioning that there exists many optimized techniques for <a href="https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method">modular exponentiation</a> which can be implemented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-47"><a class="header" href="#solution-47">Solution</a></h1>
<hr />
<blockquote>
<p>9110846700</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-permutations"><a class="header" href="#prime-permutations"><a href="https://projecteuler.net/problem=49">Prime permutations</a></a></h1>
<blockquote>
<p>The arithmetic sequence, \( 1487 \), \( 4817 \), \( 8147 \), in which each of the terms increases by \( 3330 \), is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the \( 4 \)-digit numbers are permutations of one another.</p>
<p>There are no arithmetic sequences made up of three \( 1 \)-, \( 2 \)-, or \( 3 \)-digit primes, exhibiting this property, but there is one other \( 4 \)-digit increasing sequence.</p>
<p>What \( 12 \)-digit number do you form by concatenating the three terms in this sequence?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-48"><a class="header" href="#brute-force-48">Brute force</a></h1>
<p>The brute force approach iterates over all four-digit numbers, \( i \), and all numbers \( j \) until \( i \), \( i + j \) and \( i + 2j \) are primes and permutations of each other.
The requirement for the four-digit numbers implies that \(1000 \leq i &lt; 10000 \) and \( i + 2j &lt; 10000 \Rightarrow j &lt; \frac{10000 - i}{2} \).</p>
<p>The permutations condition can be verified by sorting the digits of each number and comparing the sorted strings.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0049/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def prime_permutations():
    for i in range(1000, 10000):
        if i == 1487:
            continue
        for j in range(1, (10000 - i) // 2):
            if (
                isprime(i)
                and isprime(i + j)
                and isprime(i + 2 * j)
                and sorted(str(i)) == sorted(str(i + j)) == sorted(str(i + 2 * j))
            ):
                return str(i) + str(i + j) + str(i + 2 * j)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primes-permutations"><a class="header" href="#primes-permutations">Primes permutations</a></h1>
<p>An improvement to the <a href="problems/problem_0049/./solution1.html">Brute force</a> approach can be made by avoiding the iterations over all numbers.
The most restrictive requirements of the problem are that the solution must be four-digit and prime.
Fortunately, meeting this condition is really simple as generating the Sieve of Eratosthenes between \( 1000 \) and \( 10000 \) gives a list of all four-digit primes.</p>
<p>The remaining conditions require that the three numbers must be permutations of each other and in arithmetic progression.
However, it's difficult to determine all primes that are in arithmetic progression efficiently.
As a result, it is better to focus on the permutation requirement.
By grouping all primes based on their sorted digits results in lists of four-digit primes with the same permutations.</p>
<p>Finally, the arithmetic constraint can be verified by iterating through each group to find \( p_1 \), \( p_2 \), and \( p_3 \) such that \( p_3 = 2p_2 - p_1 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0049/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def prime_permutations():
    primes = list(sieve.primerange(1000, 10000))
    primes_permutations = defaultdict(list)
    for prime in primes:
        primes_permutations[&quot;&quot;.join(sorted(str(prime)))].append(prime)

    for perm in primes_permutations.values():
        if len(perm) &lt; 3 or perm[0] == 1487:
            continue

        for i, p1 in enumerate(perm):
            for p2 in perm[i + 1 :]:
                p3 = 2 * p2 - p1
                if p3 in perm:
                    return str(p1) + str(p2) + str(p3)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-48"><a class="header" href="#solution-48">Solution</a></h1>
<hr />
<blockquote>
<p>296962999629</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="consecutive-prime-sum"><a class="header" href="#consecutive-prime-sum"><a href="https://projecteuler.net/problem=50">Consecutive prime sum</a></a></h1>
<blockquote>
<p>The prime \( 41 \), can be written as the sum of six consecutive primes:</p>
<p>\[
41 = 2 + 3 + 5 + 7 + 11 + 13
\]</p>
<p>This is the longest sum of consecutive primes that adds to a prime below one-hundred.</p>
<p>The longest sum of consecutive primes below one-thousand that adds to a prime, contains \( 21 \) terms, and is equal to \( 953 \).</p>
<p>Which prime, below one-million, can be written as the sum of the most consecutive primes?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-49"><a class="header" href="#brute-force-49">Brute force</a></h1>
<p>To solve the problem of finding the prime number below one million that can be expressed as the longest sum of consecutive primes, the first idea is to generate all the primes below one million.
Subsequently, brute-forcing all possible combinations of consecutive primes can be evaluated to identify the longest sequence whose sum is also a prime.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0050/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def consecutive_prime_sum(lim=10**6):
    primes = list(sieve.primerange(2, lim))
    res = 0
    max_len = 0
    for i in range(len(primes)):
        for j in range(i + max_len, len(primes)):
            s = sum(primes[i:j])
            if s &gt;= lim:
                break
            if j - i &gt; max_len and s in primes:
                max_len = j - i
                res = s
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cumulative-sum"><a class="header" href="#cumulative-sum">Cumulative sum</a></h1>
<p>The <a href="problems/problem_0050/./solution1.html">Brute force</a> approach has a time complexity of \( O(n^3) \), due to the double loop and the computation of the sum of consecutive primes at each iteration.
However, the Sieve of Eratosthenes used for generated the primes has a time complexity of \( O(n\log(\log(n))) \), suggesting that it might be possible to improve the brute force approach.</p>
<p>A major drawback of the brute force approach is the computation of the sum of consecutive primes at each iteration.
This can be optimized by using a cumulative sum, which has the additional benefit that the sum of consecutive primes between \( i \) and \( j \) is equal to \( S_j - S_i \), where \( S_i \) is the cumulative sum of the first \( i \) primes.
Therefore, searching for the sum of any consecutive primes can be done in constant time.</p>
<p>To effectively iterate over all possible combinations of consecutive primes, it's best to start from the longest possible sequence and then decrease the size of the sequence until a sum is prime.
This sequence can be obtained by finding the first cumulative sum that is greater than \( 1000000 \) since it is obvious that the sequence must start from the first prime.
Using a binary search this window size can be found in \( O(\log(n)) \).</p>
<p>The remaining step involve iterating over all the possible windows of consecutive primes until a sum is prime.
Using a set to store the primes can further improve the time complexity of searching if a sum is prime.</p>
<p>In theory, the time complexity of this approach is \( O(wn) \), where \( w \) is the size of the longest window and \( n \) is the number of primes below \( 1000000 \).
Estimating \( w \) based on the size of \( n \) is difficult, but it's clear that it is much smaller than \( n \).
For example in our case \( w \) is \( 546 \) and \( n \) is \( 664579 \).
In practice, this approach only take a couple of iterations since \( w \) is very small, and the iteration is done starting from the largest window.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0050/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def consecutive_prime_sum(lim=10**6):
    primes = list(sieve.primerange(2, lim))
    primes_set = set(primes)
    cumul_sum = list(accumulate(primes))
    max_window = bisect.bisect_left(cumul_sum, lim)
    for window in range(max_window, 0, -1):
        for i in range(len(cumul_sum) - window):
            s = cumul_sum[i + window] - cumul_sum[i]
            if s &gt;= lim:
                break
            if s in primes_set:
                return s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-49"><a class="header" href="#solution-49">Solution</a></h1>
<hr />
<blockquote>
<p>997651</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-digit-replacements"><a class="header" href="#prime-digit-replacements"><a href="https://projecteuler.net/problem=51">Prime digit replacements</a></a></h1>
<blockquote>
<p>By replacing the \( 1^{st} \) digit of the \( 2 \)-digit number \( *3 \), it turns out that six of the nine possible values: \( 13 \), \( 23 \), \( 43 \), \( 53 \), \( 73 \), and \( 83 \), are all prime.</p>
<p>By replacing the \( 3 \)rd and \( 4 \)th digits of \( 56 \)*\( * \)3 with the same digit, this \( 5 \)-digit number is the first example having seven primes among the ten generated numbers, yielding the family: \( 56003 \), \( 56113 \), \( 56333 \), \( 56443 \), \( 56663 \), \( 56773 \), and \( 56993 \). Consequently \( 56003 \), being the first member of this family, is the smallest prime with this property.</p>
<p>Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-50"><a class="header" href="#brute-force-50">Brute force</a></h1>
<p>A straightforward approach to determine the smallest prime that belongs to an eight prime value family involves iterating through all primes and checking whether it is possible to replace \( k \) digits with numbers \( d \) ranging from \( 0 \) to \( 9 \) while still retaining 8 primes.
The condition being the difficulty of the problem, can be split into two parts:</p>
<ul>
<li>Find all the permutation of digits that should be replaced.</li>
<li>Replace the digits with numbers ranging from \( 0 \) to \( 9 \) and check whether the resulting number is prime.</li>
</ul>
<p>The first part can be done quite simply by generating a mask using <a href="https://docs.python.org/3/library/itertools.html#itertools.product">itertools.product</a>.
The mask is binary list with a length equal to the length of the number to verify, where the value <code>True</code> indicates that the digit at the same index should be replaced.</p>
<p>Although the second part may present some challenges in terms of efficiency, its implementation should remain straightforward since the method is intended to be naive.
To solve this, a string of the same length as the original number is constructed, where each digit is selected from either the initial number or the value \( d \), depending on the mask.</p>
<p>Certain corner cases requires some consideration:</p>
<ul>
<li>Number starting with \( 0 \) are invalid, otherwise the smallest seven prime value family would start at \( 03 \). Thus any permutation where the first digit is replaced by \( 0 \) should be skipped.</li>
<li>The mask can not consist of only <code>False</code> values, as this would mean that no digit is replaced. Consequently, any permutations with an all-<code>False</code> mask should be discarded.</li>
</ul>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0051/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_nth_prime_value_family(n):
    for mask in itertools.product([False, True], repeat=len(n)):
        seq_len = 0
        res = 0
        for d in &quot;0123456789&quot;:
            if mask[0] and d == &quot;0&quot; or not any(mask):
                continue
            first = int(&quot;&quot;.join((d if mask[j] else n[j] for j in range(len(n)))))
            if isprime(first):
                if seq_len == 0:
                    res = first

                seq_len += 1
                if seq_len == 8:
                    return res
    return None
</code></pre>
<p>The remaining step simply iterate through all primes and verify whether the number is an eight prime value family.
For simplicity, the <a href="https://docs.sympy.org/latest/modules/ntheory.html#sympy.ntheory.generate.sieve">sympy.sieve</a> functions is used to generate an infinite sequence of primes.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0051/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def prime_digit_replacements():
    for i in sieve:
        res = is_nth_prime_value_family(str(i))
        if res is not None:
            return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-observations"><a class="header" href="#simple-observations">Simple observations</a></h1>
<p>The <a href="problems/problem_0051/./solution1.html">Brute force</a> approach is very slow and highly inefficient, mainly due to redundant verification.
For example, several numbers, such as \( 12345 \) and \( 12346 \), are checked multiples times when the replacement includes the last digit.
Therefore, it is necessary to find a better approach to determine which numbers and which replacements are required.</p>
<p>Let's start with some simple observations that can be made to improve the efficiency of the algorithm:</p>
<ol>
<li>Since the first number of the sequence must be a prime, there is no need to check numbers lower than the current one during digit replacement.
This is because smaller prime are already been verified.</li>
<li>Since the family is an eight prime value family, at least 8 replacements must be prime.
Using <strong>1</strong>, it's unnecessary to replace digits greater than \( 2 \), as this would result in fewer than 8 possible replacements.</li>
<li>Only replacements of \( 3k \) digits, with \( k &gt; 0 \) can give a solution.
Let's first remember that a number \( n \) is divisible by \( 3 \) if and only if the sum of its digits is divisible by \( 3 \).
The rest modulo \( 3 \) of the sum of the digits of the initial numbers excluding the one that will be replaced is either \( 0 \), \( 1 \) or \( 2 \).
If the number of replacements is \( 2 \), then the rest modulo \( 3 \) of the sum of the replacements for \( 0 \) to \( 9 \) is: \( 0 \), \( 2 \), \( 1 \), \( 0 \), \( 2 \), \( 1 \), \( 0 \), \( 2 \), \( 1 \), \( 0 \) respectively.
Therefore, whatever the initial number is, the sum of the digits will always be divisible by \( 3 \) at least 3 times, and thus the maximum value family is \( 7 \).
The same reasoning can be applied to other non-multiples of \( 3 \) digits replacements.</li>
<li>Using <strong>1</strong>, it is possible to generate the replacements more efficiently by adding to the current number the mask multiplied by the nth digit.
For example, if the current number is \( 12345 \) and the mask is \( 00101 \), then the replacement is \( 12345 + 101 * d \).</li>
</ol>
<p>Using these observations, it is possible to compute much more efficiently the prime digit replacements.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0051/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def is_nth_prime_value_family(n):
    for d in range(3):  # Observation 2
        mask = 0
        occurrences = 0
        for i, m in enumerate(str(n)[::-1]):  # Reverse string for easier mask creation
            if m == str(d):
                mask += 10**i
                occurrences += 1

        if occurrences == 0 or occurrences % 3 != 0:  # Observation 3
            continue

        seq_len = 0
        for r in range(10 - d):
            if seq_len + 10 - r &lt; 8:  # Observation 2
                break
            if isprime(n + r * mask):  # Observation 4
                seq_len += 1
            if seq_len == 8:
                return n
</code></pre>
<p>The remaining step is the same as the <a href="problems/problem_0051/./solution1.html">Brute force</a> approach.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0051/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def prime_digit_replacements():
    for i in sieve:
        res = is_nth_prime_value_family(i)
        if res is not None:
            return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-50"><a class="header" href="#solution-50">Solution</a></h1>
<hr />
<blockquote>
<p>121313</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="permuted-multiples"><a class="header" href="#permuted-multiples"><a href="https://projecteuler.net/problem=52">Permuted multiples</a></a></h1>
<blockquote>
<p>It can be seen that the number, \( 125874 \), and its double, \( 251748 \), contain exactly the same digits, but in a different order.</p>
<p>Find the smallest positive integer, x, such that \( 2 \)x, \( 3 \)x, \( 4 \)x, \( 5 \)x, and \( 6 \)x, contain the same digits.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-51"><a class="header" href="#brute-force-51">Brute force</a></h1>
<p>The brute force approach for this problem is very simple, as the task of identifying numbers sharing the same digit has already been solved in the <a href="problems/problem_0052/../problem_0049/problem.html">Prime permutations</a> problem with the <a href="problems/problem_0052/../problem_0049/solution1.html">Brute force</a> approach.</p>
<p>The remaining step consist of iterating through all positive numbers until all products wth number from 2 to 6 are permutations of the original integer.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0052/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def permuted_multiples():
    for i in itertools.count(1):
        if all(sorted(str(i)) == sorted(str(i * j)) for j in range(2, 7)):
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observation-is-insight"><a class="header" href="#observation-is-insight">Observation is insight</a></h1>
<p>Although the <a href="problems/problem_0052/solution1.html">Brute force</a> approach can effectively solve the problem, exploring alternative methodologies can offer valuable insights.
In this case, several pertinent observations can be made:</p>
<ol>
<li>The number must be a multiple of \( 9 \), because every number are congruent to the sum of their digits modulo \( 9 \), thus \( x \equiv s \pmod{9} \), where \( s \) is the sum of digits of \( x \).
Since \( 2x \equiv s \pmod{9} \), it follows that \( 2x - x \equiv s - s \pmod{9} \), which implies that \( x \equiv 0 \pmod{9} \).</li>
<li>The first digit of the number must be \( 1 \), otherwise \( 2x \) would have one more digit than \( x \).</li>
<li>According to the previous observation, \( 2x \) must start with \( 2 \) or \( 3 \), \( 3x \) must start with \( 3 \) or \( 4 \) and so on.
Therefore, the number must at least contain 6 digits to satisfy to contain digits from \( 1 \) to \( 6 \).</li>
<li>The number must contain a \( 0 \) or a \( 5 \) because \( 5x \) is obviously a multiple of \( 5 \).</li>
</ol>
<p>It's actually possible to continue with the observation and find the solution by hand.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0052/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def permuted_multiples():
    for i in itertools.count(100008, 9):  # Observation 1 and 4
        s = str(i)
        if int(s[0]) != 1 or all(d not in s for d in &quot;05&quot;):  # Observation 2 and 3
            continue
        if all(sorted(s) == sorted(str(i * j)) for j in range(2, 7)):
            return i
</code></pre>
<p>It is worth noting that the solution is trivial if one know the property of <a href="https://en.wikipedia.org/wiki/7#In_decimal">\frac{1}{7}</a> in decimal representation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-51"><a class="header" href="#solution-51">Solution</a></h1>
<hr />
<blockquote>
<p>142857</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="combinatoric-selections"><a class="header" href="#combinatoric-selections"><a href="https://projecteuler.net/problem=53">Combinatoric selections</a></a></h1>
<blockquote>
<p>There are exactly ten ways of selecting three from five, \( 12345 \):</p>
<p>\[
123, 124, 125, 134, 135, 145, 234, 235, 245,\text{ and }345
\]</p>
<p>In combinatorics, we use the notation, \( \displaystyle \binom 5 3 = 10 \).</p>
<p>In general, \( \displaystyle \binom n r = \dfrac{n!}{r!(n-r)!} \), where \( r \le n \), \( n!=n \times (n-1) \times ... \times 3 \times 2 \times 1 \), and \( 0!=1 \).</p>
<p>It is not until n \( =23 \), that a value exceeds one-million: \( \displaystyle \binom{23}{10}=1144066 \).</p>
<p>How many, not necessarily distinct, values of \( \displaystyle \binom n r \) for \( 1 \le n \le 100 \), are greater than one-million?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-52"><a class="header" href="#brute-force-52">Brute force</a></h1>
<p>A direct approach to determine all distinct values of \( \displaystyle \binom n r \leq 1000000 \) for \( 1 \le n \le 100 \) is as follows:</p>
<ul>
<li>Calculate \( \displaystyle \binom n r \) using the formula \( \displaystyle \binom n r = \dfrac{n!}{r!(n-r)!} \).</li>
<li>Iterate over each \( n \) from \( 1 \) to \( 100 \) and \( r \) from \( 1 \) to \( n \) and count the number of \( \displaystyle \binom n r &gt; 1,000,000 \).</li>
</ul>
<p>The first task can be simply implemented using the <a href="https://docs.python.org/3/library/math.html#math.factorial">math.factorial</a> function.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0053/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def ncr(n, r):
    return int((factorial(n) / (factorial(r) * factorial(n - r))))
</code></pre>
<p>The solution is then simpy implemented by iterating over all \( n \) and \( r \) and counting the number of \( \displaystyle \binom n r \) that are greater than \( 1,000,000 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0053/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def combinatoric_selections():
    return sum(ncr(n, r) &gt; 1000000 for n in range(23, 101) for r in range(1, n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pascals-triangle"><a class="header" href="#pascals-triangle">Pascal's Triangle</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal's triangle</a> is a triangular array of the binomial coefficients.
A small example of the Pascal's triangle is depicted below:</p>
<p>\[
\begin{align}
&amp;1\\
&amp;1\ 1\\
&amp;1\ 2\ \ 1\\
&amp;1\ 3\ \ 3\ \ 1\\
&amp;1\ 4\ \ 6\ \ 4\ \ 1\\
&amp;1\ 5\ 10\ 10\ 5\ 1\\
\end{align}
\]</p>
<p>The rows of the triangle are indexed from \( 1 \) to \( n \) and the columns are indexed from \( 1 \) to \( r \).</p>
<p>It describes the symmetry of the binomial coefficients, which is the reason why it is only necessary to calculate half of the triangle.
Furthermore, if a coefficient is larger than \( n \), all coefficients between it and its mirror on the same row will also be larger than \( n \).
This observation allows for more efficient iteration over the triangle. <strong>(1)</strong></p>
<p>Furthermore, recomputing the binomial coefficients is very inefficient, which is why using a cache table for the factorials is a good idea.
Alternatively, the binomial coefficients can be computed using the previous row by applying the following formula:
\[
\binom{n}{r} = \binom{n - 1}{r - 1} + \binom{n - 1}{r}
\]</p>
<p>The downside of this approach is that all the coefficients of the previous row have to be computed, which is unnecessary as stated in the first observation.
Therefore, the following formula is used to compute the coefficients, which only requires information about the current row: <strong>(2)</strong>
\[
\binom{n}{1} = n\\
\binom{n}{r} = \dfrac{n - r + 1}{r} \binom{n}{r - 1}
\]</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0053/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def combinatoric_selections():
    res = 0
    for n in range(23, 101):
        ncr = n
        for r in range(2, n // 2 + 1):
            ncr = (ncr * (n - r + 1)) // r  # Observation 2
            if ncr &gt; 1000000:
                res += n - 2 * r + 1  # Observation 1
                break
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-52"><a class="header" href="#solution-52">Solution</a></h1>
<hr />
<blockquote>
<p>4075</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="poker-hands"><a class="header" href="#poker-hands"><a href="https://projecteuler.net/problem=54">Poker hands</a></a></h1>
<blockquote>
<p>In the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way:</p>
<ul>
<li><strong>High Card</strong>: Highest value card.</li>
<li><strong>One Pair</strong>: Two cards of the same value.</li>
<li><strong>Two Pairs</strong>: Two different pairs.</li>
<li><strong>Three of a Kind</strong>: Three cards of the same value.</li>
<li><strong>Straight</strong>: All cards are consecutive values.</li>
<li><strong>Flush</strong>: All cards of the same suit.</li>
<li><strong>Full House</strong>: Three of a kind and a pair.</li>
<li><strong>Four of a Kind</strong>: Four cards of the same value.</li>
<li><strong>Straight Flush</strong>: All cards are consecutive values of same suit.</li>
<li><strong>Royal Flush</strong>: Ten, Jack, Queen, King, Ace, in same suit.</li>
</ul>
<p>The cards are valued in the order:
\( 2 \), \( 3 \), \( 4 \), \( 5 \), \( 6 \), \( 7 \), \( 8 \), \( 9 \), \( 10 \), Jack, Queen, King, Ace.</p>
<p>If two players have the same ranked hands then the rank made up of the highest value wins; for example, a pair of eights beats a pair of fives (see example \( 1 \) below). But if two ranks tie, for example, both players have a pair of queens, then highest cards in each hand are compared (see example \( 4 \) below); if the highest cards tie then the next highest cards are compared, and so on.</p>
<p>Consider the following five hands dealt to two players:</p>
<div style="text-align: center">
<table><tr><td><b>Hand</b></td><td><b>Player 1</b></td><td><b>Player 2</b></td><td><b>Winner</b></td>
</tr><tr><td><b>1</b></td><td>5H 5C 6S 7S KD<br /><div class="center" style="font-size: 90%">Pair of Fives</div></td><td>2C 3S 8S 8D TD<br /><div class="center" style="font-size: 90%">Pair of Eights</div></td><td>Player 2</td>
</tr><tr><td><b>2</b></td><td>5D 8C 9S JS AC<br /><div class="center" style="font-size: 90%">Highest card Ace</div></td><td>2C 5C 7D 8S QH<br /><div class="center" style="font-size: 90%">Highest card Queen</div></td><td>Player 1</td>
</tr><tr><td><b>3</b></td><td>2D 9C AS AH AC<br /><div class="center" style="font-size: 90%">Three Aces</div></td><td>3D 6D 7D TD QD<br /><div class="center" style="font-size: 90%">Flush  with Diamonds</div></td><td>Player 2</td>
</tr><tr><td><b>4</b></td><td>4D 6S 9H QH QC<br /><div class="center" style="font-size: 90%">Pair of Queens<br />Highest card Nine</div></td><td>3D 6D 7H QD QS<br /><div class="center" style="font-size: 90%">Pair of Queens<br />Highest card Seven</div></td><td>Player 1</td>
</tr><tr><td><b>5</b></td><td>2H 2D 4C 4D 4S<br /><div class="center" style="font-size: 90%">Full House<br />With Three Fours</div></td><td>3C 3D 3S 9S 9D<br /><div class="center" style="font-size: 90%">Full House<br />with Three Threes</div></td><td>Player 1</td>
</tr></table></div>
<p>The file, <a href="https://projecteuler.net/project/resources/p054_poker.txt">poker.txt</a>, contains one-thousand random hands dealt to two players. Each line of the file contains ten cards (separated by a single space): the first five are Player \( 1 \)'s cards and the last five are Player \( 2 \)'s cards. You can assume that all hands are valid (no invalid characters or repeated cards), each player's hand is in no specific order, and in each hand there is a clear winner.</p>
<p>How many hands does Player \( 1 \) win?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-53"><a class="header" href="#brute-force-53">Brute force</a></h1>
<p>For once, this problem only requires implementation of poker rules and does not involve any mathematical or algorithmic concepts.
While the rules are straightforward, it can be tedious to implement due to the many possible outcomes.
It is important to understand how to compare two hands to write less verbose code and not avoid missing some outcomes.</p>
<p>The rules for comparing hands are as follows:</p>
<ul>
<li>The hand with the highest rank wins.</li>
<li>If two hands have the same rank, the one with the highest card wins.</li>
<li>If two hands have the same rank and the same highest card, the one with the second-highest card wins and so on.</li>
</ul>
<p>There is a special case for the Full House rank, for example, the Full House <code>4D 4S 4H 2C 2D</code> is better than the Full House <code>3D 3S 3H 5C 5D</code> because the three fours are better than the three threes (even if the pair of fives is better than the pair of twos).
Therefore, the rank of the hand alone is not sufficient to compare two hands, it is also required to know the occurrences of each card rank.</p>
<p>There may be more tricky cases (depending on the poker variant), but this is enough to solve the problem.</p>
<p>The input file is read using <code>read_file</code> function which returns a simple list of all cards of both hands.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0054/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return [line.split() for line in file.read().splitlines()]
</code></pre>
<p>For convenience and readability, <code>Rank</code>, <code>Suit</code> and <code>Hand</code> enums are defined and the <code>from_string</code> function is used to parse the input strings into cards.</p>
<p>Then, three information are extracted from each hand:</p>
<ul>
<li>The list of cards (sorted by occurrence and rank).</li>
<li>If the hand is straight (all cards have consecutive ranks).</li>
<li>If the hand is flush (all cards have the same suit).</li>
</ul>
<p>Creating a tuple with rank of the hand and the list of cards (sorted by occurrence and rank) is enough to compare two hands.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0054/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def get_hand(hand):
    values = sorted([Card.from_string(card[0]) for card in hand])
    occ, values = zip(*sorted(((v, k) for k, v in Counter(values).items()), reverse=True))

    is_straight = all(values[i].value == values[i + 1].value + 1 for i in range(len(values) - 1))
    is_flush = len(set(card[1] for card in hand)) == 1

    if occ == (4, 1):
        hand = Hand.FOUR_OF_A_KIND
    elif occ == (3, 2):
        hand = Hand.FULL_HOUSE
    elif occ == (3, 1, 1):
        hand = Hand.THREE_OF_A_KIND
    elif occ == (2, 2, 1):
        hand = Hand.TWO_PAIR
    elif occ == (2, 1, 1, 1):
        hand = Hand.ONE_PAIR
    elif is_straight and is_flush and values[0] == Card.ACE:
        hand = Hand.ROYAL_FLUSH
    elif is_straight and is_flush:
        hand = Hand.STRAIGHT_FLUSH
    elif is_flush:
        hand = Hand.FLUSH
    elif is_straight:
        hand = Hand.STRAIGHT
    elif occ == (1, 1, 1, 1, 1):
        hand = Hand.HIGH_CARD
    else:
        raise ValueError(&quot;Invalid hand&quot;)

    return hand, *values
</code></pre>
<p>The rest is just a matter of iterating over all the hands and counting the number of wins for player 1.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0054/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def poker_hands(file):
    return sum(get_hand(hand[:5]) &gt; get_hand(hand[5:]) for hand in read_file(file))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-53"><a class="header" href="#solution-53">Solution</a></h1>
<hr />
<blockquote>
<p>376</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lychrel-numbers"><a class="header" href="#lychrel-numbers"><a href="https://projecteuler.net/problem=55">Lychrel numbers</a></a></h1>
<blockquote>
<p>If we take \( 47 \), reverse and add, \( 47+74=121 \), which is palindromic.</p>
<p>Not all numbers produce palindromes so quickly. For example,</p>
<p>\[
349 + 943 = 1292,\\\\
1292 + 2921 = 4213\\\\
4213 + 3124 = 7337
\]</p>
<p>That is, \( 349 \) took three iterations to arrive at a palindrome.</p>
<p>Although no one has proved it yet, it is thought that some numbers, like \( 196 \), never produce a palindrome. A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome. In fact, \( 10677 \) is the first number to be shown to require over fifty iterations before producing a palindrome: \( 4668731596684224866951378664 \) (\( 53 \) iterations, \( 28 \)-digits).</p>
<p>Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is \( 4994 \).</p>
<p>How many Lychrel numbers are there below ten-thousand?</p>
<p>NOTE: Wording was modified slightly on \( 24 \) April \( 2007 \) to emphasise the theoretical nature of Lychrel numbers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-54"><a class="header" href="#brute-force-54">Brute force</a></h1>
<p>The problem requires to find the number of Lychrel numbers below 10,000.
A Lychrel number is a natural number that cannot become a palindrome through the process of iteratively reversing the number and adding it to the original number.
In this problem, a number is considered a Lychrel number if fails to form a palindrome within 1 to 50 iterations.</p>
<p>The first step is to write a function that checks if a number is a Lychrel number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0055/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_lychrel(n):
    for _ in range(50):
        n += int(str(n)[::-1])
        if str(n) == str(n)[::-1]:
            return False
    return True
</code></pre>
<p>Then, iterating through all numbers below 10000 and checking is enough to solve the problem.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0055/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def lychrel_numbers():
    return sum(is_lychrel(n) for n in range(1, 10000))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-54"><a class="header" href="#solution-54">Solution</a></h1>
<hr />
<blockquote>
<p>249</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="powerful-digit-sum"><a class="header" href="#powerful-digit-sum"><a href="https://projecteuler.net/problem=56">Powerful digit sum</a></a></h1>
<blockquote>
<p>A googol (\( 10100 \)) is a massive number: one followed by one-hundred zeros; \( 100100 \) is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only \( 1 \).</p>
<p>Considering natural numbers of the form, ab, where a, b \( &lt;100 \), what is the maximum digital sum?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-55"><a class="header" href="#brute-force-55">Brute force</a></h1>
<p>Computing the sum of digits of a number is a task that we already know.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0056/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def digits_sum(n):
    return sum(map(int, str(n)))
</code></pre>
<p>Then, we can solve the problem by iterating over all the possible values of a and b, and keeping track of the maximum sum.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0056/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def powerful_digit_sum():
    return max(digits_sum(a**b) for a in range(1, 100) for b in range(1, 100))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-55"><a class="header" href="#solution-55">Solution</a></h1>
<hr />
<blockquote>
<p>972</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="square-root-convergents"><a class="header" href="#square-root-convergents"><a href="https://projecteuler.net/problem=57">Square root convergents</a></a></h1>
<blockquote>
<p>It is possible to show that the square root of two can be expressed as an infinite continued fraction.</p>
<p>\[
\sqrt 2 =1+ \frac 1 {2+ \frac 1 {2 +\frac 1 {2+ \dots}}}
\]</p>
<p>By expanding this for the first four iterations, we get:</p>
<p>\( 1 + \frac 1 2 = \frac 3 2 = 1.5 \)</p>
<p>\( 1 + \frac 1 {2 + \frac 1 2} = \frac 7 5 = 1.4 \)</p>
<p>\( 1 + \frac 1 {2 + \frac 1 {2+\frac 1 2}} = \frac {17}{12} = 1.41666 \dots \)</p>
<p>\( 1 + \frac 1 {2 + \frac 1 {2+\frac 1 {2+\frac 1 2}}} = \frac {41}{29} = 1.41379 \dots \)</p>
<p>The next three expansions are \( \frac{99}{70} \), \( \frac{239}{169} \), and \( \frac{577}{408} \), but the eighth expansion, \( \frac{1393}{985} \), is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.</p>
<p>In the first one-thousand expansions, how many fractions contain a numerator with more digits than the denominator?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-56"><a class="header" href="#brute-force-56">Brute force</a></h1>
<p>This problem involves manipulating numerators and denominators of fractions, and understing the recurrence relation between them at each step is the key to solving it.</p>
<p>For example, starting with \( 1 + \color{red}{\frac{1}{2}} = \frac{3}{2} \), when computing \( 1 + \frac{1}{2 + \color{red}{\frac{1}{2}}} = \frac{5}{2} \), we notice that the denominator is always \( 2 \) plus the fraction of the previous equation.</p>
<p>To compute the new numerator and denominator, the first step is to add \( 2 \) to the fraction, which is equivalent to adding \( 2 \times \text{denominator} \) to the numerator.
The second step is to apply the inverse of the fraction, which simply means swapping the numerator and denominator.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0057/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def new_fraction(numerator, denominator):
    return denominator, 2 * denominator + numerator
</code></pre>
<p>The last step is to add one to this fraction, which is equivalent of adding the denominator to the numerator.
If the new numerator has more digits than the denominator, increment the counter.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0057/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def square_root_convergents():
    numerator = 0
    denominator = 1
    count = 0
    for _ in range(1000):
        numerator, denominator = new_fraction(numerator, denominator)
        if len(str(numerator + denominator)) &gt; len(str(denominator)):
            count += 1
    return count
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-better-recurrence"><a class="header" href="#a-better-recurrence">A better recurrence?</a></h1>
<p>With a bit of algebra, we can explain the recurrence relation in a more elegant way:</p>
<p>\[
\begin{align}
x_n &amp;= 1 + \frac{a_n}{b_n}\\
x_{n+1} &amp;= 1 + \frac{1}{2 + \frac{a_n}{b_n}}\\
\end{align}
\]</p>
<p>It should be clear than \( 2 + \frac{a_n}{b_n} = 1 + x_n \), so we can rewrite the second equation as:</p>
<p>\[
\begin{align}
x_{n+1} &amp;= 1 + \frac{1}{1 + x_n}\\
x_{n+1} &amp;= \frac{2 + x_n}{1 + x_n}\\
\end{align}
\]</p>
<p>We are not actually interested in \( x_{n} \), but in the numerator and denominator of \( x_{n} \), thus if we have \(x_n = \frac{p_n}{q_n}\), we can rewrite the last equation as:</p>
<p>\[
x_{n+1} = \frac{p_{n+1}}{q_{n+1}} = \frac{2 + \frac{p_n}{q_n}}{1 + \frac{p_n}{q_n}} = \frac{\frac{2q_n + p_n}{q_n}}{\frac{q_n + p_n}{q_n}} = \frac{2q_n + p_n}{q_n + p_n}\\
\]</p>
<p>This recurrence is better than the one used in the previous solution, because it explicitly gives the numerator and denominator of \( x_{n} \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0057/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def square_root_convergents():
    pn = 1
    qn = 1
    count = 0
    for _ in range(1000):
        pn, qn = 2 * qn + pn, qn + pn
        if len(str(pn)) &gt; len(str(qn)):
            count += 1
    return count
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-56"><a class="header" href="#solution-56">Solution</a></h1>
<hr />
<blockquote>
<p>153</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="spiral-primes"><a class="header" href="#spiral-primes"><a href="https://projecteuler.net/problem=58">Spiral primes</a></a></h1>
<blockquote>
<p>Starting with \( 1 \) and spiralling anticlockwise in the following way, a square spiral with side length \( 7 \) is formed.</p>
<p>\[
\color{red}{37}\ 36\ 35\ 34\ 33\ 32\ \color{red}{31}\\\\
38\ \color{red}{17}\ 16\ 15\ 14\ \color{red}{13}\ 30\\\\
39\ 18\ \ \color{red}{5}\ \ \ 4\ \ \ \color{red}{3}\ \ 12\ 29\\\\
40\ 19\ \ 6\ \ \ 1\ \ \ 2\ \ 11\ 28\\\\
41\ 20\ \ \color{red}{7}\ \ \ 8\ \ \ 9\ \ 10\ 27\\\\
42\ 21\ 22\ 23\ 24\ 25\ 26\\\\
\color{red}{43}\ 44\ 45\ 46\ 47\ 48\ 49
\]</p>
<p>It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that \( 8 \) out of the \( 13 \) numbers lying along both diagonals are prime; that is, a ratio of \( \frac{8}{13} \approx 62% \).</p>
<p>If one complete new layer is wrapped around the spiral above, a square spiral with side length \( 9 \) will be formed. If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below \( 10 \)%?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-57"><a class="header" href="#brute-force-57">Brute force</a></h1>
<p>This problem should reminisce you of <a href="problems/problem_0058/../problem_0028/problem.html">Problem 28</a>.
Utilizing information from the previous problem, the solution becomes straightforward and involves iterating through each value in the corner until the ratio of primes falls below 10%.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0058/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def spiral_primes():
    res = 0
    for i in itertools.count(3, 2):
        res += (
            isprime(i**2) + isprime(i**2 - (i - 1)) + isprime(i**2 - 2 * (i - 1)) + isprime(i**2 - 3 * (i - 1))
        )
        if res &lt; (2 * i - 1) / 10:
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-57"><a class="header" href="#solution-57">Solution</a></h1>
<hr />
<blockquote>
<p>26241</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="xor-decryption"><a class="header" href="#xor-decryption"><a href="https://projecteuler.net/problem=59">XOR decryption</a></a></h1>
<blockquote>
<p>Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange). For example, uppercase A \( =65 \), asterisk (\( * \)) \( =42 \), and lowercase k \( =107 \).</p>
<p>A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key. The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, \( 65 \) XOR \( 42=107 \), then \( 107 \) XOR \( 42=65 \).</p>
<p>For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes. The user would keep the encrypted message and the encryption key in different locations, and without both &quot;halves&quot;, it is impossible to decrypt the message.</p>
<p>Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key. If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message. The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.</p>
<p>Your task has been made easy, as the encryption key consists of three lower case characters. Using <a href="https://projecteuler.net/project/resources/p059_cipher.txt">p059_cipher.txt</a> (right click and 'Save Link\( / \)Target As\( ... \)'), a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-58"><a class="header" href="#brute-force-58">Brute force</a></h1>
<p>Decrypting ciphertexts is a common task in cryptography.
This problem provides a ciphertext and the key length.
Given the short length of the key, one solution is to try all possible keys and see which one gives a plaintext that makes sense.
However, since I'm too lazy to check all the outputs, let's think about it a bit more.</p>
<p><a href="https://en.wikipedia.org/wiki/Frequency_analysis">Frequency analysis</a> is a method used to break simple substitution ciphers.
Counting the number of occurrences of each character in the ciphertext and comparing it with the frequencies of the letters in the English language can give some clues about the plaintext.
As 'e' is the most common letter in English, the most common letter in the ciphertext is likely to be 'e'.</p>
<p>To find the key, the first step is to split the ciphertext into blocks of length equal to the key length.
Then, applying XOR to the most common character in each block with 'e' should give each block's key.</p>
<p>The first step is to parse the ciphertext and get a list of integers to apply XOR to.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0059/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def parse_file():
    with open(&quot;cipher.txt&quot;, &quot;r&quot;) as f:
        return [int(x) for x in f.read().split(&quot;,&quot;)]
</code></pre>
<p>Using <a href="https://docs.python.org/3/library/collections.html#collections.Counter.most_common">collections.Counter.most_common</a> to determine the most common character in each block and <a href="https://docs.python.org/3/library/itertools.html#itertools.cycle">itertools.cycle</a> to iterate over the key repeatedly will be helpful.
Lastly, applying XOR operations between each character in the ciphertext and the corresponding character of the key gives the plaintext.</p>
<p>Due to the nature of the text, the most frequent character is more likely to be ' ' (space) than 'e'.
This is because the ciphertext is an English text, as a result, applying XOR using ' ' to the most common character in each block yields the correct solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0059/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def xor_decryption():
    code = parse_file()
    k1 = Counter(code[::3]).most_common(1)[0][0] ^ ord(&quot; &quot;)
    k2 = Counter(code[1::3]).most_common(1)[0][0] ^ ord(&quot; &quot;)
    k3 = Counter(code[2::3]).most_common(1)[0][0] ^ ord(&quot; &quot;)
    key = [k1, k2, k3]
    res = [chr(c ^ p) for (c, p) in zip(parse_file(), itertools.cycle(key))]
    return sum(ord(c) for c in res)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-58"><a class="header" href="#solution-58">Solution</a></h1>
<hr />
<blockquote>
<p>129448</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-pair-sets"><a class="header" href="#prime-pair-sets"><a href="https://projecteuler.net/problem=60">Prime pair sets</a></a></h1>
<blockquote>
<p>The primes \( 3 \), \( 7 \), \( 109 \), and \( 673 \), are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime. For example, taking \( 7 \) and \( 109 \), both \( 7109 \) and \( 1097 \) are prime. The sum of these four primes, \( 792 \), represents the lowest sum for a set of four primes with this property.</p>
<p>Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-59"><a class="header" href="#brute-force-59">Brute force</a></h1>
<p>The problem requires finding the set of five primes that has the lowest sum and for which any two primes concatenate to produce another prime.
A brute force approach can be used, but it requires to generate all the primes up to a certain arbitrary limit.
Then, 5 nested loops are used to find the first set of five primes that satisfy the condition.
If the concatenation of two primes is not prime, the search for the current set of primes can be stopped.</p>
<p>Determining whether two concatenated primes are prime is done by converting the numbers to strings and checking whether the concatenation of the strings is prime.
It is worth noting that another method involving logarithms can be used to determine whether the concatenation of two numbers is prime, but it is not as straightforward as the string approach.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0060/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def concat(p1, p2):
    return isprime(int(str(p1) + str(p2))) and isprime(int(str(p2) + str(p1)))
</code></pre>
<p>The rest is the 5 nested loops, for each loop, only the new prime is checked against the previous ones.
The limit is set to 10000, which is enough to find the solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0060/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def prime_pair_sets():
    primes = list(sieve.primerange(10000))
    for i, p1 in enumerate(primes):
        for j, p2 in enumerate(primes[:i]):
            if any(not concat(p, p2) for p in (p1,)):
                continue
            for k, p3 in enumerate(primes[:j]):
                if any(not concat(p, p3) for p in (p1, p2)):
                    continue
                for l, p4 in enumerate(primes[:k]):
                    if any(not concat(p, p4) for p in (p1, p2, p3)):
                        continue
                    for p5 in primes[:l]:
                        if all(concat(p, p5) for p in (p1, p2, p3, p4)):
                            return p1 + p2 + p3 + p4 + p5
</code></pre>
<p>This solution may not yield the smallest sum because the order of iteration is not designed to minimize the sum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cliques-graph-theory"><a class="header" href="#cliques-graph-theory">Clique's graph theory</a></h1>
<p>Another solution is to use the <a href="https://en.wikipedia.org/wiki/Clique_(graph_theory)">clique</a> graph theory.
A clique is a subset of vertices in an undirected graph, such that every two distinct vertices in the clique are adjacent.
In this problem, a graph can be defined with vertices representing primes and edges representing the concatenation of two primes being prime.
The solution can be found by finding the clique of size 5 with the smallest sum.
Indeed, a clique of size 5 is a set of 5 vertices (primes) such that every two vertices are adjacent (every concatenation of two primes is prime).</p>
<p>To simplify the process of creating the graph and finding the clique, the <a href="https://networkx.github.io/">networkx</a> library is used.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0060/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def prime_pair_sets():
    primes = list(sieve.primerange(10000))
    pairs = ((p1, p2) for p1 in primes for p2 in primes if p1 &lt; p2 and concat(p1, p2))
    graph = nx.Graph()
    graph.add_edges_from(pairs)
    five_cliques = [sum(clique) for clique in find_cliques(graph) if len(clique) == 5]
    return sorted(five_cliques)[0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-59"><a class="header" href="#solution-59">Solution</a></h1>
<hr />
<blockquote>
<p>26033</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="cyclical-figurate-numbers"><a class="header" href="#cyclical-figurate-numbers"><a href="https://projecteuler.net/problem=61">Cyclical figurate numbers</a></a></h1>
<blockquote>
<p>Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:</p>
<p>\[
\begin{align}
&amp; Triangle &amp;&amp; P_{3,n} = n(n+1)/2 &amp;&amp; 1, 3, 6, 10, 15, ... \\
&amp; Square &amp;&amp; P_{4,n} = n^2 &amp;&amp; 1, 4, 9, 16, 25, ... \\
&amp; Pentagonal &amp;&amp; P_{5,n} = n(3n-1)/2 &amp;&amp; 1, 5, 12, 22, 35, ... \\
&amp; Hexagonal &amp;&amp; P_{6,n} = n(2n-1) &amp;&amp; 1, 6, 15, 28, 45, ... \\
&amp; Heptagonal &amp;&amp; P_{7,n} = n(5n-3)/2 &amp;&amp; 1, 7, 18, 34, 55, ... \\
&amp; Octagonal &amp;&amp; P_{8,n} = n(3n-2) &amp;&amp; 1, 8, 21, 40, 65, ...
\end{align}
\]</p>
<p>The ordered set of three \( 4 \)-digit numbers: \( 8128 \), \( 2882 \), \( 8281 \), has three interesting properties.</p>
<ol>
<li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).</li>
<li>Each polygonal type: triangle \( (P_{3,127}=8128) \), square \( (P_{4,91}=8281) \), and pentagonal \( (P_{5,44}=2882) \), is represented by a different number in the set.</li>
<li>This is the only set of \( 4 \)-digit numbers with this property.</li>
</ol>
<p>Find the sum of the only ordered set of six cyclic \( 4 \)-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-60"><a class="header" href="#brute-force-60">Brute force</a></h1>
<p>The problem is to find the sum of the set of six cyclic 4-digit numbers for which each polygonal type is represented by a cyclic number in the set.
To resume, this problem has 3 constraints:</p>
<ol>
<li>The numbers are 4-digit numbers.</li>
<li>The numbers are cyclic.</li>
<li>Each number is a polygon of a given type.</li>
</ol>
<p>The brute force solution for this problem, while simple, is not easy to implement due to its recursive nature.</p>
<p>The idea is to try every 4-digit number until a polygon is found.
Starting with the last two digits of the previous polygon, this operation should be repeated 5 times.
If all polygon types have been found, and the last two digits of the last polygon are the same as the first two digits of the first polygon, the solution is the sum of this cycle.</p>
<p>Overall, the recursive algorithm requires to keep track of the remaining polygon types, the current number, and the current cycle.
The remaining polygon types is represented with a list of functions that return whether a number is a polygon.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0061/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def find_cycle(first_two_digits, is_polygonals, cycle):
    if not is_polygonals:
        if cycle[0] // 100 == cycle[-1] % 100:
            return cycle
        return []

    for last_two_digits in range(10, 100):
        p = first_two_digits * 100 + last_two_digits
        for i, is_polygonal in enumerate(is_polygonals):
            if is_polygonal(p):
                new_cycle = find_cycle(last_two_digits, is_polygonals[:i] + is_polygonals[i + 1 :], cycle + [p])
                if new_cycle:
                    return new_cycle

    return []
</code></pre>
<p>The rest is to actually build the list of polygon types and to call the recursive function.
The formulas for each polygon type are similar to the one in <a href="problems/problem_0061/../problem_0042/problem.html">Problem 0042</a>, and can be found in the source code.
Therefore, they will not be repeated in this text for brevity.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0061/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def cyclical_figurate_numbers():
    is_triangular = lambda n: ((1 + (1 + 8 * n) ** 0.5) / 2).is_integer()
    is_square = lambda n: (n**0.5).is_integer()
    is_pentagonal = lambda n: ((1 + (1 + 24 * n) ** 0.5) / 6).is_integer()
    is_hexagonal = lambda n: ((1 + (1 + 8 * n) ** 0.5) / 4).is_integer()
    is_heptagonal = lambda n: ((3 + (9 + 40 * n) ** 0.5) / 10).is_integer()
    is_octagonal = lambda n: ((1 + (1 + 3 * n) ** 0.5) / 3).is_integer()
    is_polygonals = [is_triangular, is_square, is_pentagonal, is_hexagonal, is_heptagonal, is_octagonal]

    for i in range(10, 100):
        cycle = find_cycle(i, is_polygonals, [])
        if cycle:
            return sum(cycle)

    return []
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching-polygonal-numbers"><a class="header" href="#caching-polygonal-numbers">Caching polygonal numbers</a></h1>
<p>Instead of iterating through all 4-digit numbers, pre-computing all polygonal numbers and then iterating through them is a better approach.</p>
<p>It does not change the <code>find_cycle</code> function by much, instead of trying every 4-digit number, it tries every polygonal number.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0061/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def find_cycle(first_two_digits, polygonals, cycle):
    if not polygonals:
        if cycle[0] // 100 == cycle[-1] % 100:
            return cycle
        return []

    for i in range(len(polygonals)):
        for p in polygonals[i]:
            if p // 100 == first_two_digits:
                new_cycle = find_cycle(p % 100, polygonals[:i] + polygonals[i + 1 :], cycle + [p])
                if new_cycle:
                    return new_cycle

    return []
</code></pre>
<p>The rest is also very similar, the difference is the list of polygon types which is now a list of sets of polygonal numbers and the iteration is done starting with the octogonals numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0061/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def cyclical_figurate_numbers():
    triangles = set(n * (n + 1) // 2 for n in range(45, 141))
    squares = set(n**2 for n in range(32, 100))
    pentagonals = set(n * (3 * n - 1) // 2 for n in range(26, 82))
    hexagonals = set(n * (2 * n - 1) for n in range(23, 71))
    heptagonals = set(n * (5 * n - 3) // 2 for n in range(21, 64))
    octagonals = set(n * (3 * n - 2) for n in range(19, 59))

    polygonals = [triangles, squares, pentagonals, hexagonals, heptagonals]
    for p in octagonals:
        cycle = find_cycle(p, polygonals, [p])
        if cycle:
            return sum(cycle)

    return []
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-60"><a class="header" href="#solution-60">Solution</a></h1>
<hr />
<blockquote>
<p>28684</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="cubic-permutations"><a class="header" href="#cubic-permutations"><a href="https://projecteuler.net/problem=62">Cubic permutations</a></a></h1>
<blockquote>
<p>The cube, \( 41063625 \) (\( 345^3 \)), can be permuted to produce two other cubes: \( 56623104 \) (\( 384^3 \)) and \( 66430125 \) (\( 405^3 \)). In fact, \( 41063625 \) is the smallest cube which has exactly three permutations of its digits which are also cube.</p>
<p>Find the smallest cube for which exactly five permutations of its digits are cube.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-61"><a class="header" href="#brute-force-61">Brute force</a></h1>
<p>The problem is to find the smallest cube \( n^3 \) such that it has at least \( 5 \) permutations that are also cubes.
The brute force approach is exactly what it sounds like:</p>
<ol>
<li>Generate all cubes \( n^3 \).</li>
<li>Generate all permutations of this cube .</li>
<li>Check if the permutations are cubes with the same number of digits and is not already counted.</li>
<li>If there are \( 5 \) or more permutations that meet the criteria, then the solution is found</li>
</ol>
<p>Using <a href="https://docs.python.org/3/library/itertools.html#itertools.permutations">itertools.permutations</a> greatly simplifies the second step.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0062/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def cubic_permutations():
    for cube in (i**3 for i in itertools.count(1)):  # Condition 1
        cubes = {cube}

        for p in itertools.permutations(str(cube)):  # Condition 2
            new_cube = int(&quot;&quot;.join(p))
            if p[0] != &quot;0&quot; and is_cube(new_cube) and new_cube not in cubes:  # Condition 3
                cubes.add(new_cube)
        if len(cubes) &gt;= 5:  # Condition 4
            return min(cubes)
</code></pre>
<p>Although this method works for the given example, it is too slow to solve the problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterating-and-caching"><a class="header" href="#iterating-and-caching">Iterating and caching</a></h1>
<p>The main issue with the <a href="problems/problem_0062/./solution1.html">Brute force</a> approach is that it checks the same permutations multiples times and many of them are not cubes, making it very inefficient.</p>
<p>To overcome this issue, we can use a similar approach to <a href="problems/problem_0062/../problem_0049/problem.html">Problem 0049</a> which involves:</p>
<ol>
<li>Generating all cubes \( n^3 \).</li>
<li>Grouping the cubes with the same permutation together.</li>
<li>If one of the groups has at least \( 5 \) cubes, the solution is found.</li>
</ol>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0062/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def cubic_permutations():
    permutations = defaultdict(list)
    for cube in (i**3 for i in itertools.count(1)):  # Condition 1
        ordered_digits = &quot;&quot;.join(sorted(str(cube)))
        permutations[ordered_digits].append(cube)  # Condition 2
        if len(permutations[ordered_digits]) &gt;= 5:  # Condition 3
            return min(permutations[ordered_digits])
</code></pre>
<p>Note that the function actually returns the smallest cube of the first group with at least \( 5 \) cubes.
While this is sufficient for this problem, it will not necessarily provide the correct answer with groups of bigger sizes, like \( 6 \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-61"><a class="header" href="#solution-61">Solution</a></h1>
<hr />
<blockquote>
<p>127035954683</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="powerful-digit-counts"><a class="header" href="#powerful-digit-counts"><a href="https://projecteuler.net/problem=63">Powerful digit counts</a></a></h1>
<blockquote>
<p>The \( 5 \)-digit number, \( 16807=7^5 \), is also a fifth power. Similarly, the \( 9 \)-digit number, \( 134217728=8^9 \), is a ninth power.</p>
<p>How many n-digit positive integers exist which are also an nth power?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-62"><a class="header" href="#brute-force-62">Brute force</a></h1>
<p>The problem is to determine the number of positive integers that are nth power.
Here, positive integers refer to integers greater than 0.</p>
<p>The brute force algorithm for solving this problem is relatively straightforward:</p>
<ol>
<li>Iterate through all positive integers.</li>
<li>For each integer, iterate through all positive powers.</li>
<li>If the length of the computer number is equal to the power, increment the counter.</li>
</ol>
<p>However, the challenge lies in determining when to terminate both iterations.</p>
<p>To express the problem mathematically, we search all \( n \) and \( x \) such that \( 10^{n-1} \leq x^n &lt; 10^n \).
It follows that \( x \) must be less than \( 10 \), and \( 10^{n-1} \) grows faster than \( x^n \) since \( x &lt; 10 \).
Therefore, the iteration over \( n \) can be stopped when \( 10^{n-1} &gt; x^n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0063/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def powerful_digit_counts():
    res = 0
    for i in range(1, 10):
        for j in itertools.count(1):
            if len(str(i**j)) == j:
                res += 1
            elif len(str(i**j)) &lt; j:
                break
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="back-to-initial-equation"><a class="header" href="#back-to-initial-equation">Back to initial equation</a></h1>
<p>In the <a href="problems/problem_0063/./solution1.html">Brute force</a> solution, we found that \( 1 &lt; x &lt; 10 \) and \( 10^{n-1} &gt; x^n \) for \( n \) sufficiently large.
Rather than iterating through all \( n \) until \( 10^{n-1} &gt; x^n \), solving the equation \( 10^{n-1} = x^n \) for \( n \) gives the exact limit for \( n \).</p>
<p>\[
\begin{align}
&amp;\Leftrightarrow 10^{n-1} = x^n \\
&amp;\Leftrightarrow \log_{10}\left(10^{n-1}\right) = \log_{10}\left(x^n\right) \\
&amp;\Leftrightarrow n - 1 = n\log_{10}\left(x\right) \\
&amp;\Leftrightarrow n(1 - \log_{10}\left(x\right)) = 1 \\
&amp;\Leftrightarrow n = \frac{1}{1 - \log_{10}\left(x\right)} \\
\end{align}
\]</p>
<p>Since \( n \) is an integer, the limit is the largest integer for which the inequality holds true.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0063/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def powerful_digit_counts():
    return sum(floor(1 / (1 - log10(i))) for i in range(1, 10))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-62"><a class="header" href="#solution-62">Solution</a></h1>
<hr />
<blockquote>
<p>49</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="odd-period-square-roots"><a class="header" href="#odd-period-square-roots"><a href="https://projecteuler.net/problem=64">Odd period square roots</a></a></h1>
<blockquote>
<p>All square roots are periodic when written as continued fractions and can be written in the form:</p>
<p>\( \displaystyle \quad \quad \sqrt{N}=a_0+\frac 1 {a_1+\frac 1 {a_2+ \frac 1 {a3+ \dots}}} \)</p>
<p>For example, let us consider \( \sqrt{23} \):</p>
<p>\( \quad \quad \sqrt{23}=4+\sqrt{23}-4=4+\frac 1 {\frac 1 {\sqrt{23}-4}}=4+\frac 1  {1+\frac{\sqrt{23}-3}7} \)</p>
<p>If we continue we would get the following expansion:</p>
<p>\( \displaystyle \quad \quad \sqrt{23}=4+\frac 1 {1+\frac 1 {3+ \frac 1 {1+\frac 1 {8+ \dots}}}} \)</p>
<p>The process can be summarised as follows:</p>
<p>\[
\begin{align}
&amp;a_0=4, \frac 1 {\sqrt{23}-4}=\frac {\sqrt{23}+4} 7=1+\frac {\sqrt{23}-3} 7\\
&amp;a_1=1, \frac 7 {\sqrt{23}-3}=\frac {7(\sqrt{23}+3)} {14}=3+\frac {\sqrt{23}-3} 2\\
&amp;a_2=3, \frac 2 {\sqrt{23}-3}=\frac {2(\sqrt{23}+3)} {14}=1+\frac {\sqrt{23}-4} 7\\
&amp;a_3=1, \frac 7 {\sqrt{23}-4}=\frac {7(\sqrt{23}+4)} 7=8+\sqrt{23}-4\\
&amp;a_4=8, \frac 1 {\sqrt{23}-4}=\frac {\sqrt{23}+4} 7=1+\frac {\sqrt{23}-3} 7\\
&amp;a_5=1, \frac 7 {\sqrt{23}-3}=\frac {7 (\sqrt{23}+3)} {14}=3+\frac {\sqrt{23}-3} 2\\
\\
&amp;a_6=3, \frac 2 {\sqrt{23}-3}=\frac {2(\sqrt{23}+3)} {14}=1+\frac {\sqrt{23}-4} 7\\
&amp;a_7=1, \frac 7 {\sqrt{23}-4}=\frac {7(\sqrt{23}+4)} {7}=8+\sqrt{23}-4\\
\end{align}
\] </p>
<p>It can be seen that the sequence is repeating. For conciseness, we use the notation \( \sqrt{23}=[4;(1,3,1,8)] \), to indicate that the block \( (1,3,1,8) \) repeats indefinitely.</p>
<p>The first ten continued fraction representations of (irrational) square roots are:</p>
<p>\[
\begin{align}
&amp;\sqrt{2}=[1;(2)],\text{period=1}\\
&amp;\sqrt{3}=[1;(1,2)],\text{period=2}\\
&amp;\sqrt{5}=[2;(4)],\text{period=1}\\
&amp;\sqrt{6}=[2;(2,4)],\text{period=2}\\
&amp;\sqrt{7}=[2;(1,1,1,4)],\text{period=4}\\
&amp;\sqrt{8}=[2;(1,4)],\text{period=2}\\
&amp;\sqrt{10}=[3;(6)],\text{period=1}\\
&amp;\sqrt{11}=[3;(3,6)],\text{period=2}\\
&amp;\sqrt{12}=[3;(2,6)],\text{period=2}\\
&amp;\sqrt{13}=[3;(1,1,1,1,6)],\text{period=5}\\
\end{align}
\]</p>
<p>Exactly four continued fractions, for \( N \le 13 \), have an odd period.</p>
<p>How many continued fractions for \( N \le  10,000 \) have an odd period?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-63"><a class="header" href="#brute-force-63">Brute force</a></h1>
<p>The solution asks for the number of continued fractions with an odd period.
A continued fraction is an expression obtained through an iterative process of representing a number as the sum of its integer part and the reciprocal of another number, then writing this other number as the sum of its integer part and another reciprocal, and so on. <sup><a href="https://www.britannica.com/science/continued-fraction">1</a></sup></p>
<p>To solve the problem, the first step is to understand the iterative nature of the continued fractions.</p>
<p>The continued fraction is defined using \( a_0 = \left\lfloor \sqrt{N} \right\rfloor \) as:
\[
\begin{align}
\sqrt{N} &amp;= a_0 + \sqrt{N} - a_0\\
&amp;= a_0 + \frac{1}{\frac{1}{\sqrt{N} - a_0}} = a_0 + \frac{1}{\frac{\sqrt{N} + a_0}{N - a_0^2}} = a_0 + \frac{1}{a_1 + \frac{\sqrt{N} - b_1}{c_1}}\\
\end{align}\\
\text{where } c_1 = N - a_0^2; \quad a_1 = \left\lfloor \frac{\sqrt{N} + a_0}{c_1} \right\rfloor; \quad b_1 = -(a_0 - a_1c_1)
\]</p>
<p>Repeating the process gives:</p>
<p>\[
\begin{align}
a_1 + \frac{\sqrt{N} - b_1}{c_1} &amp;= a_1 + \frac{1}{\frac{c_1}{\sqrt{N} - b_1}} = a_1 + \frac{1}{\frac{\sqrt{N} + b_1}{\frac{N - b_1^2}{c_1}}} = a_1 + \frac{1}{a_2 + \frac{\sqrt{N} - b_2}{c_2}}\\
\end{align}\\
\text{where } c_2 = \frac{N - b_1^2}{c_1}; \quad a_2 = \left\lfloor \frac{\sqrt{N} + b_1}{c_2} \right\rfloor; \quad b_2 = -(b_1 - a_2c_2)
\]</p>
<p>The process can be continued, and the following pattern can be observed:</p>
<p>\[
\begin{align}
c_{n+1} &amp;= \frac{N - b_n^2}{c_n}\\
a_{n+1} &amp;= \left\lfloor \frac{\sqrt{N} + b_n}{c_{n+1}} \right\rfloor\\
b_{n+1} &amp;= -(b_n - a_{n+1}c_{n+1})
\end{align}
\]</p>
<p>The first equation can be rewritten as \( a_0 + \sqrt{N} - a_0 = a_0 + \frac{\sqrt{N} - a_0}{1} = a_0 + \frac{\sqrt{N} - b_0}{c_0} \) which results in the same pattern as the second equation and provides the initialisation for the iterative process.
The iteration can be stopped when \( b_n \) and \( c_n \) repeat, because the continued fraction will also repeat itself.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0064/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def period_square_roots(n):
    a_0 = floor(sqrt(n))
    if a_0 * a_0 == n:
        return 0

    bn = a_0
    cn = 1
    remainders = {}

    for pos in itertools.count(1):
        cn = (n - (bn * bn)) / cn
        an = floor((sqrt(n) + bn) / cn)
        bn = -(bn - (an * cn))
        if (bn, cn) in remainders:
            return pos - remainders[bn, cn]
        remainders[bn, cn] = pos
</code></pre>
<p>The solution can be computed by trying all the numbers \( N \) below \( 10000 \) and counting the number of continued fractions with an odd period.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0064/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def odd_period_square_roots():
    return sum(period_square_roots(n) % 2 for n in range(2, 10001))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="another-property-of-continued-fractions"><a class="header" href="#another-property-of-continued-fractions">Another property of continued fractions</a></h1>
<p>Going back to the equation:</p>
<p>\[
\frac{\sqrt{N} - b_1}{c_1} = a_2 + \frac{\sqrt{N} - b_2}{c_2}
\]</p>
<p>and </p>
<p>\[
\begin{align}
c_{n+1} &amp;= \frac{N - b_n^2}{c_n}\\
a_{n+1} &amp;= \left\lfloor \frac{\sqrt{N} + b_n}{c_{n+1}} \right\rfloor\\
b_{n+1} &amp;= -(b_n - a_{n+1}c_{n+1})
\end{align}
\]</p>
<p>The following can be deduced:</p>
<ul>
<li>\( b_2 &lt; \sqrt{N} \), because \( c_2 = \frac{N - b_1^2}{c_1} \) is positive.</li>
<li>\( b_2 \leq a_0 \), because \( a_0 = \left\lfloor \sqrt{N} \right\rfloor \).</li>
<li>\( b_2 = a_2c_2 - b_1 \leq a_0 \)</li>
</ul>
<p>If \( a_2 = 2a_0 \), then \( b_2 = 2a_0c_2 - b_1 \leq a_0 \), because all terms are positive integers we have \( c_2 = 1 \) and \( b_1 = a_0 \).
Which results with \( b_2 = -(b_1 - a_2c_2) = -(a_0 - 2a_0) = a_0 \)
The first expression becomes \( \frac{\sqrt{N} - b_1}{c_1} = a_2 + \frac{\sqrt{N} - b_2}{c_2} = 2a_0 + \frac{\sqrt{N} - a_0}{1} \)
This is similar to the first iteration of the algorithm, which means that the sequence will repeat when \( a_n = 2a_0 \).
The formal proof can be found in the paper <a href="https://web.math.princeton.edu/mathlab/jr02fall/Periodicity/alexajp.pdf">On continued fractions of the square root of prime numbers</a>.</p>
<p>This property is much easier to implement than remembering every \( b_n \) and \( c_n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0064/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def period_square_roots(n):
    a_0 = floor(sqrt(n))
    if a_0 * a_0 == n:
        return 0

    bn = a_0
    cn = 1

    for pos in itertools.count(1):
        cn = (n - (bn * bn)) / cn
        an = floor((sqrt(n) + bn) / cn)
        bn = -(bn - (an * cn))
        if an == 2 * a_0:
            return pos
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0064/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def odd_period_square_roots():
    return sum(period_square_roots(n) % 2 for n in range(2, 10001))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-63"><a class="header" href="#solution-63">Solution</a></h1>
<hr />
<blockquote>
<p>1322</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="convergents-of-e"><a class="header" href="#convergents-of-e"><a href="https://projecteuler.net/problem=65">Convergents of e</a></a></h1>
<blockquote>
<p>The square root of \( 2 \) can be written as an infinite continued fraction.</p>
<p>\( \sqrt{2} = 1 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + ...}}}} \)</p>
<p>The infinite continued fraction can be written, \( \sqrt{2} = [1; (2)] \), \( (2) \) indicates that \( 2 \) repeats ad infinitum. In a similar way, \( \sqrt{23} = [4; (1, 3, 1, 8)] \).</p>
<p>It turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for \( \sqrt{2} \).</p>
<p>\[
\begin{align}
&amp;1+ \dfrac{1}{2} = \dfrac{3}{2} \\
&amp;1+ \dfrac{1}{2 + \dfrac{1}{2}} = \dfrac{7}{5}\\
&amp;1+ \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2}}} = \dfrac{17}{12}\\
&amp;1+ \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2 + \dfrac{1}{2}}}} = \dfrac{41}{29}\\
\end{align}
\]</p>
<p>Hence the sequence of the first ten convergents for \( \sqrt{2} \) are:</p>
<p>\( 1, \dfrac{3}{2}, \dfrac{7}{5}, \dfrac{17}{12}, \dfrac{41}{29}, \dfrac{99}{70}, \dfrac{239}{169}, \dfrac{577}{408}, \dfrac{1393}{985}, \dfrac{3363}{2378}, ... \)</p>
<p>What is most surprising is that the important mathematical constant,
\( e = [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, ... , 1, 2k, 1, ...] \).</p>
<p>The first ten terms in the sequence of convergents for \( e \) are:</p>
<p>\( 2, 3, \dfrac{8}{3}, \dfrac{11}{4}, \dfrac{19}{7}, \dfrac{87}{32}, \dfrac{106}{39}, \dfrac{193}{71}, \dfrac{1264}{465}, \dfrac{1457}{536}, ... \)</p>
<p>The sum of digits in the numerator of the \( 10 \)th convergent is \( 1+4+5+7=17 \).</p>
<p>Find the sum of digits in the numerator of the \( 100 \)th convergent of the continued fraction for \( e \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-64"><a class="header" href="#brute-force-64">Brute force</a></h1>
<p>The problem is to find the sum of the digits in the numerator of the 100th convergent of the continued fraction for \( e \).</p>
<p>The key to solve the problem is to understand the pattern of the numerator for each iteration.
By observing the relation between the numerator, denominator and the convergent, the recursive relation should become evident.
Starting with numerators \( h_1 \) and \( h_2 \), and convergent \( a_1 \), the recursive relationship can be defined as follows: \( h_n = a_n h_{n-1} + h_{n-2} \).
As the convergent pattern is already given, computing the numerator for the \( 100 \)th convergent is a matter of applying the recursive relation \( 100 \) times.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0065/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def convergents_of_e():
    an = [2] + [1 if i % 3 != 2 else 2 * (i // 3 + 1) for i in range(1, 100)]
    h1, h2 = 0, 1
    for i in range(100):
        h1, h2 = h2, h1 + an[i] * h2
    return sum(int(c) for c in str(h2))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-64"><a class="header" href="#solution-64">Solution</a></h1>
<hr />
<blockquote>
<p>272</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="diophantine-equation"><a class="header" href="#diophantine-equation"><a href="https://projecteuler.net/problem=66">Diophantine equation</a></a></h1>
<blockquote>
<p>Consider quadratic Diophantine equations of the form:</p>
<p>\[
x^{2} – Dy^{2} = 1
\]</p>
<p>For example, when D\( = \)1\( 3 \), the minimal solution in \( x \) is \( 6492 - 13 \times 1802=1 \).</p>
<p>It can be assumed that there are no solutions in positive integers when \( D \) is square.</p>
<p>By finding minimal solutions in x for \( D = \{2, 3, 5, 6, 7\} \), we obtain the following:</p>
<p>\[
3^{2} – 2×2^{2} = 1\\\\
2^{2} – 3×1^{2} = 1\\\\
\color{red}{9}^{2} – 5×4^{2} = 1\\\\
5^{2} – 6×2^{2} = 1\\\\
8^{2} – 7×3^{2} = 1
\]</p>
<p>Hence, by considering minimal solutions in \( x \) for \( D \leq 7 \), the largest \( x \) is obtained when \( D = 5 \).</p>
<p>Find the value of \( D \leq 1000 \) in minimal solutions of \( x \) for which the largest value of \( x \) is obtained.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-65"><a class="header" href="#brute-force-65">Brute force</a></h1>
<p>The problem is to find the value of \( D \leq 1000 \) for which \( x \) is maximised in the equation \( x^2 - Dy^2 = 1 \).</p>
<p>Brute forcing the solution is easy, for each \( D \leq 1000 \) that is not a perfect square, and for each \( x &gt; 1 \), if \( y = \sqrt{\frac{x^2 - 1}{D}} \) is an integer, then \( x^2 - Dy^2 = 1 \) is satisfied.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0066/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def diophantine_equation():
    res = 0
    for d in range(2, 1001):
        if sqrt(d).is_integer():
            continue

        for x in itertools.count(2):
            if (sqrt((x**2 - 1) / d)).is_integer():
                res = max(res, x)
                break

    return res
</code></pre>
<p>However, the brute force approach is not effective and does not provide the solution for \( D = 61 \) as \( x \) becomes too large...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solving-pells-equations"><a class="header" href="#solving-pells-equations">Solving Pell's equations</a></h1>
<p>This diophantine equation is called <a href="https://en.wikipedia.org/wiki/Pell%27s_equation">Pell's equation</a>, and it is possible to solve it using the <a href="https://en.wikipedia.org/wiki/Pell%27s_equation#Fundamental_solution_via_continued_fractions">continued fraction</a> expansion of \( \sqrt{D} \).</p>
<p>This method involves finding the numerator and denominator of the \( i \)-th convergent of \( \sqrt{D} \) denoted by \( h_i \) and \( k_i \) respectively, where \( h_i^2 - D k_i^2 = 1 \) for some \( i \).
Furthermore, the first \( i \) that satisfies this condition corresponds to the smallest \( x \) that satisfies the equation.</p>
<p>With <a href="problems/problem_0066/../problem_0065/problem.html">Problem 0065</a>, we know the recurrence relation for computing \( h_i \) and \( k_i \) is:</p>
<p>\[
h_i = a_i h_{i-1} + h_{i-2}\\
k_i = a_i k_{i-1} + k_{i-2}
\]</p>
<p>where \( a_i \) is the \( i \)-th convergent of \( \sqrt{D} \).</p>
<p>The cycle of convergent of \( \sqrt{D} \) can be computed using the method <a href="problems/problem_0066/../problem_0064/solution2.html">Another property of continued fractions</a>.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0066/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def get_convergent_cycle(n):
    a_0 = floor(sqrt(n))
    res = []
    if a_0 * a_0 == n:
        return []

    bn = a_0
    cn = 1

    for _ in itertools.count(1):
        cn = (n - (bn * bn)) / cn
        an = floor((sqrt(n) + bn) / cn)
        bn = -(bn - (an * cn))
        res.append(an)
        if an == 2 * a_0:
            return res
</code></pre>
<p>Then, using the recurrence relation, we can compute \( h_i \) and \( k_i \) and find the first \( i \) that satisfies \( h_i^2 - D k_i^2 = 1 \) for each \( D \leq 1000 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0066/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def diophantine_equation():
    x, res = 0, 0
    for d in range(2, 1001):
        an = get_convergent_cycle(d)
        if not an:
            continue

        h1, h2, k1, k2 = 1, floor(sqrt(d)), 0, 1
        for i in itertools.count(0):
            h1, h2 = h2, h1 + an[i % len(an)] * h2
            k1, k2 = k2, k1 + an[i % len(an)] * k2
            if h2 * h2 - d * k2 * k2 == 1:
                x, res = max((h2, d), (x, res))
                break

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-65"><a class="header" href="#solution-65">Solution</a></h1>
<hr />
<blockquote>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-path-sum-ii"><a class="header" href="#maximum-path-sum-ii"><a href="https://projecteuler.net/problem=67">Maximum path sum II</a></a></h1>
<blockquote>
<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is \( 23 \).</p>
<p>\[
\color{red}{3}\\\\
2\ \color{red}{4}\ 6\\\\
8\ 5\ \color{red}{9}\ 3
\]</p>
<p>That is, \( 3+7+4+9=23 \).</p>
<p>Find the maximum total from top to bottom in <a href="https://projecteuler.net/project/resources/p067_triangle.txt">triangle.txt</a> (right click and 'Save Link/Target As...'), a \( 15 \)K text file containing a triangle with one-hundred rows.</p>
<p><strong>NOTE:</strong> This is a much more difficult version of <a href="https://projecteuler.net/problem=18">Problem 18</a>. It is not possible to try every route to solve this problem, as there are \( 2^{99} \) altogether! If you could check one trillion (\( 10^12 \)) routes every second it would take over twenty billion years to check them all. There is an efficient algorithm to solve it. ;o)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-4"><a class="header" href="#dynamic-programming-4">Dynamic programming</a></h1>
<p>This problem is the same as <a href="problems/problem_0067/../problem_0018/problem.html">Problem 0018</a>, but with a larger triangle.</p>
<p>As we did in the <a href="problems/problem_0067/../problem_0018/solution2.html">Dynamic programming</a> solution for Problem 0018, we can reduce the triangle by replacing each number with the sum of itself and the largest number below it.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0067/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def maximum_path_sum_II(filename):
    triangle = read_file(filename)

    for i in range(len(triangle) - 2, -1, -1):
        for j in range(len(triangle[i])):
            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])

    return triangle[0][0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-66"><a class="header" href="#solution-66">Solution</a></h1>
<hr />
<blockquote>
<p>7273</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="magic-5-gon-ring"><a class="header" href="#magic-5-gon-ring"><a href="https://projecteuler.net/problem=68">Magic 5-gon ring</a></a></h1>
<blockquote>
<p>Consider the following &quot;magic&quot; \( 3 \)-gon ring, filled with the numbers \( 1 \) to \( 6 \), and each line adding to nine.</p>
<p style="text-align: center;"><img alt="" class="dark_img" src="https://projecteuler.net/project/images/p068_1.png"/></p>
<p>Working <strong>clockwise</strong>, and starting from the group of three with the numerically lowest external node (\( 4 \),\( 3 \),\( 2 \) in this example), each solution can be described uniquely. For example, the above solution can be described by the set: \( 4 \),\( 3 \),\( 2 \); \( 6 \),\( 2 \),\( 1 \); \( 5 \),\( 1 \),\( 3 \).</p>
<p>It is possible to complete the ring with four different totals: \( 9 \), \( 10 \), \( 11 \), and \( 12 \). There are eight solutions in total.</p>
<div class="center">
<table width="400" cellspacing="0" cellpadding="0"><tr><td width="100"><b>Total</b></td><td width="300"><b>Solution Set</b></td>
</tr><tr><td>9</td><td>4,2,3; 5,3,1; 6,1,2</td>
</tr><tr><td>9</td><td>4,3,2; 6,2,1; 5,1,3</td>
</tr><tr><td>10</td><td>2,3,5; 4,5,1; 6,1,3</td>
</tr><tr><td>10</td><td>2,5,3; 6,3,1; 4,1,5</td>
</tr><tr><td>11</td><td>1,4,6; 3,6,2; 5,2,4</td>
</tr><tr><td>11</td><td>1,6,4; 5,4,2; 3,2,6</td>
</tr><tr><td>12</td><td>1,5,6; 2,6,4; 3,4,5</td>
</tr><tr><td>12</td><td>1,6,5; 3,5,4; 2,4,6</td>
</tr></table></div>
<p>By concatenating each group it is possible to form \( 9 \)-digit strings; the maximum string for a \( 3 \)-gon ring is \( 432621513 \).</p>
<p>Using the numbers \( 1 \) to \( 10 \), and depending on arrangements, it is possible to form \( 16 \)- and \( 17 \)-digit strings. What is the maximum <strong>16-digit</strong> string for a &quot;magic&quot; \( 5 \)-gon ring?</p>
<p style="text-align: center;"><img alt="" class="dark_img" src="https://projecteuler.net/project/images/p068_2.png"/></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-66"><a class="header" href="#brute-force-66">Brute force</a></h1>
<p>The problem is to find the maximum 16-digit string for a &quot;magic&quot; 5-gon ring.
In this context, a &quot;magic&quot; gon ring is valid if all lines add up to the same number.</p>
<p>To solve this problem the brute force way, we need to:</p>
<h4 id="1-generate-all-possible-rings"><a class="header" href="#1-generate-all-possible-rings">1. Generate all possible rings.</a></h4>
<p>There exists multiple possible representation of a ring, one simple approach is to use a list where the first elements are the inner ring and the last five elements are the outer ring in clockwise order.
Generating every possible rings can be easily done using <code>itertools.permutations</code>.</p>
<h4 id="2-check-if-each-ring-is-valid"><a class="header" href="#2-check-if-each-ring-is-valid">2. Check if each ring is valid.</a></h4>
<p>To validate a &quot;magic&quot; gon ring, it is enough to check if all lines add up to the same number.
The \( i \)-th line is the sum of the \( i \)-th element of the inner ring, the \( i + 1 \)-th element of the inner ring, and the \( i \)-th element of the outer ring.
If all lines have the same sum, then the ring is valid.
This is checked by verifying that the set of line sums has only one element.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0068/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_gon_valid(inner, outer):
    return len(set(inner[i] + inner[(i + 1) % 5] + outer[i] for i in range(5))) == 1
</code></pre>
<h4 id="3-check-if-each-ring-is-a-16-digit-string"><a class="header" href="#3-check-if-each-ring-is-a-16-digit-string">3. Check if each ring is a 16-digit string.</a></h4>
<p>The string representation of a ring is the concatenation of each line, starting with the lowest external node and reading clockwise.
Each line is represented by the concatenation of the outer node, and the two inner nodes.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0068/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def ring_to_string(inner, outer):
    start = outer.index(min(outer))
    return &quot;&quot;.join((str(outer[i % 5]) + str(inner[i % 5]) + str(inner[(i + 1) % 5]) for i in range(start, start + 5)))
</code></pre>
<p>Finding string of length 16 is trivial.</p>
<h4 id="4-find-the-maximum-16-digit-string"><a class="header" href="#4-find-the-maximum-16-digit-string">4. Find the maximum 16-digit string.</a></h4>
<p>The maximum 16-digit string can be found using <code>max</code> built-in function, as it performs a lexicographical comparison.</p>
<p>The rest is to put it all together.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0068/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def magic_5_gon_ring():
    all_gons = itertools.permutations(range(1, 11))  # Condition 1
    valid_gons = filter(lambda gon: is_gon_valid(gon[:5], gon[5:]), all_gons)  # Condition 2
    string_gons = map(lambda gon: ring_to_string(gon[:5], gon[5:]), valid_gons)
    string_gons = filter(lambda gon: len(gon) == 16, string_gons)  # Condition 3
    res = max(string_gons)  # Condition 4
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-67"><a class="header" href="#solution-67">Solution</a></h1>
<hr />
<blockquote>
<p>6531031914842725</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="totient-maximum"><a class="header" href="#totient-maximum"><a href="https://projecteuler.net/problem=69">Totient maximum</a></a></h1>
<blockquote>
<p>Euler's Totient function, \( \phi(n) \) [sometimes called the phi function], is defined as the number of positive integers not exceeding n which are relatively prime to n. For example, as \( 1 \), \( 2 \), \( 4 \), \( 5 \), \( 7 \), and \( 8 \), are all less than or equal to nine and relatively prime to nine, \( \phi(9)=6 \).</p>
<div class="center">
<table class="grid center"><tr><td><b>$n$</b></td>
<td><b>Relatively Prime</b></td>
<td><b>$\phi(n)$</b></td>
<td><b>$n/\phi(n)$</b></td>
</tr><tr><td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr><tr><td>3</td>
<td>1,2</td>
<td>2</td>
<td>1.5</td>
</tr><tr><td>4</td>
<td>1,3</td>
<td>2</td>
<td>2</td>
</tr><tr><td>5</td>
<td>1,2,3,4</td>
<td>4</td>
<td>1.25</td>
</tr><tr><td>6</td>
<td>1,5</td>
<td>2</td>
<td>3</td>
</tr><tr><td>7</td>
<td>1,2,3,4,5,6</td>
<td>6</td>
<td>1.1666...</td>
</tr><tr><td>8</td>
<td>1,3,5,7</td>
<td>4</td>
<td>2</td>
</tr><tr><td>9</td>
<td>1,2,4,5,7,8</td>
<td>6</td>
<td>1.5</td>
</tr><tr><td>10</td>
<td>1,3,7,9</td>
<td>4</td>
<td>2.5</td>
</tr></table></div>
<p>It can be seen that \( n=6 \) produces a maximum \( \frac{n}{\phi(n)} \) for \( n\leq 10 \).</p>
<p>Find the value of \( n\leq 1,000,000 \) for which \( \frac{n}{\phi(n)} \) is a maximum.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-67"><a class="header" href="#brute-force-67">Brute force</a></h1>
<p>The problem is to find the value of \( n \) for which \( \frac{n}{\phi(n)} \) is a maximum.</p>
<p>The naive approach is to compute \( \phi(n) \) for all \( n \) up to \( 1,000,000 \) and then find the maximum value of \( \frac{n}{\phi(n)} \).
\( \phi(n) \) can be computed by summing the count of coprimes numbers of \( n \) up to \( n - 1 \).</p>
<p>Two numbers are considered coprime if their greatest common divisor is \( 1 \), indicating that they have no common factors.
Checking for coprime numbers can be done by verifying if there exists any number that is a factor of both numbers in the range from \( 1 \) to \( \min(a, b) \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0069/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def are_coprime(a, b):
    return not any(a % i == 0 and b % i == 0 for i in range(2, min(a, b) + 1))
</code></pre>
<p>Finally, the rest is to compute \( \frac{n}{\phi(n)} \) for all \( n \) up to \( 1,000,000 \) and find the maximum value.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0069/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def totient_maximum():
    res = 0
    res_n = 0
    for n in range(2, 1000001):
        totient = sum(are_coprime(n, i) for i in range(1, n))
        res = max(res, n / totient)
        if n / totient &gt; res:
            res = n / totient
            res_n = n
    return res_n
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching-totients"><a class="header" href="#caching-totients">Caching totients</a></h1>
<p>The current <a href="problems/problem_0069/./solution1.html">Brute force</a> solution is inefficient due to its bottleneck is the computation of \( \phi(n) \).
The function <code>are_coprime</code> is called \( n \) times, and each call takes \( O(n) \) time, leading to a total runtime of \( O(n^3) \) for all \( \phi(n) \).</p>
<p>A more efficient solution involves using a similar process to the <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>, where every multiple of a \( a \leq n \) is not coprime to \( n \).
By employing this method, \( \phi(n) \) for all \( n \) can be computed in \( O(n \log(\log(n))) \) time.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0069/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def totient_list(n):
    tlist = list(range(n))
    for i in range(1, n):
        p = tlist[i]
        for j in range(2 * i, n, i):
            tlist[j] -= p
    return tlist
</code></pre>
<p>Furthermore, caching all totients enables the computation of \( \frac{n}{\phi(n)} \) for all \( n \) in linear time.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0069/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def totient_maximum(limit=1000001):
    res = 0
    res_n = 0
    totatives = totient_list(limit)
    for n in range(2, limit):
        if n / totatives[n] &gt; res:
            res = n / totatives[n]
            res_n = n
    return res_n
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eulers-totient-function"><a class="header" href="#eulers-totient-function">Euler's totient function</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler's totient function</a> is defined as \( \phi(n) \).
There are several formulae for computing \( \phi(n) \), one of which is the following:</p>
<p>\[ \phi(n) = n \prod_{p \in \mathcal{P}} \left( 1 - \frac{1}{p} \right) \]</p>
<p>where \( \mathcal{P} \) is the set of prime factors of \( n \).</p>
<p>Remembering that the solution is \( n \) for which \( \frac{n}{\phi(n)} \) is a maximum, which is equivalent to finding \( n \) for which \( \frac{\phi(n)}{n} \) is a minimum, we can rewrite the above formula as</p>
<p>\[ \frac{\phi(n)}{n} = \prod_{p \in \mathcal{P}} \left( 1 - \frac{1}{p} \right) \]</p>
<p>Obviously, this is minimized when \( \mathcal{P} \) is large, therefore the solution is the number which has the largest number of prime factors.</p>
<p>In our case, \( n \leq 1000000 \), so the solution is \( 2 \cdot 3 \cdot 5 \cdot 7 \cdot 11 \cdot 13 \cdot 17 = 510510 \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-68"><a class="header" href="#solution-68">Solution</a></h1>
<hr />
<blockquote>
<p>510510</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="totient-permutation"><a class="header" href="#totient-permutation"><a href="https://projecteuler.net/problem=70">Totient permutation</a></a></h1>
<blockquote>
<p>Euler's Totient function, \( \varphi (n) \) [sometimes called the phi function], is used to determine the number of positive numbers less than or equal to \( n \) which are relatively prime to \( n \). For example, as \( 1 \), \( 2 \), \( 4 \), \( 5 \), \( 7 \), and \( 8 \), are all less than nine and relatively prime to nine, \( \varphi(9) = 6 \).
The number \( 1 \) is considered to be relatively prime to every positive number, so \( \varphi(1) = 1 \)</p>
<p>Interestingly, \( \varphi(87109) = 79180 \), and it can be seen that \( 87109 \) is a permutation of \( 79180 \).</p>
<p>Find the value of \( n \), \( 1&lt;n&lt;10^7 \), for which \( \varphi(n) \) is a permutation of \( n \) and the ratio \( \frac{n}{\varphi(n)} \) produces a minimum.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-68"><a class="header" href="#brute-force-68">Brute force</a></h1>
<p>The problem is very similar to the <a href="problems/problem_0070/../problem_0069/problem.html">Problem 0069</a> as it also involves Euler's totient function.
This problem asks to find the value of \( n \) for which \( \frac{n}{\phi(n)} \) is minimal and \( n \) is a permutation of \( \phi(n) \).</p>
<p>Thanks to the <a href="problems/problem_0070/../problem_0069/solution1.html">Problem 0069</a>, generating a list of totients is easy.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0070/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def totient_list(n):
    tlist = list(range(n))
    for i in range(1, n):
        p = tlist[i]
        for j in range(2 * i, n, i):
            tlist[j] -= p
    return tlist
</code></pre>
<p>Therefore, filtering every totient that is not a permutation of its index and finding the minimum ratio is all that is left to do.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0070/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def totient_permutation(limit=10000001):
    totatives = totient_list(limit)
    totatives = ((n, t) for n, t in enumerate(totatives) if sorted(str(n)) == sorted(str(t)) and n &gt; 1)
    return min(totatives, key=lambda x: x[0] / x[1])[0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eulers-totient-function-1"><a class="header" href="#eulers-totient-function-1">Euler's totient function</a></h1>
<p>Recalling that \( \phi(n) = n(1 - \frac{1}{p_1})(1 - \frac{1}{p_2})\dots(1-\frac{1}{p_k}) \) with \( n = p_1^{e_1}p_2^{e_2}\dots p_k^{e_k} \).
It is obvious that minimizing \( \frac{n}{\phi(n)} \) is equivalent to maximizing \( \phi(n) \).</p>
<p>To maximize \( \phi(n) \), it is ideal to choose \( n \) with as few prime factors as possible.
Ideally, \( n \) should be a prime number, but it does not result with a permutation as \( \phi(n) = n - 1 \).
Additionally, \( n \) can not be equal to \( p^k \) as \( n=p^k \) and \( \phi(n) = p^{k-1}(p-1) \) are not permutations of each other.
This can be proven by working modulo 3, but since the proof is not relevant, it is assumed to be true.</p>
<p>Hence, a product of two primes should be chosen, where the two primes are as large as possible, close to each other, and to \( \sqrt{10^7} \).
If no such prime pair exists, then a product of three primes should be chosen, and so on.</p>
<p>If \( a \) and \( b \) are permutations of each other, then \( a - b \) is a multiple of \( 9 \).
Therefore, if \( n \) is a permutation of \( \phi(n) \), then \( n - \phi(n) = p_1 + p_2 -1 \) must be a multiple of \( 9 \).
This property can be used to filter out totients that are not permutations of their index without having to compute the full check, which is computationally expensive.</p>
<p>To find the solution, it is sufficient to consider \( n \) as a product of two primes, so the code below does not consider products of more than two primes.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0070/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def totient_permutation(limit=10000001):
    primes = list(sieve.primerange(2, 2 * int(limit**0.5)))
    res = 0
    ratio = float(&quot;inf&quot;)
    for i in range(len(primes)):
        for j in range(i):
            if (primes[i] + primes[j] - 1) % 9 != 0:
                continue
            n = primes[i] * primes[j]
            if n &gt; limit:
                break
            t = (primes[i] - 1) * (primes[j] - 1)
            if n / t &lt; ratio and sorted(str(n)) == sorted(str(t)):
                res = n
                ratio = n / t
    return res
</code></pre>
<p>While the most optimal iteration would involve iterating over all primes sorted by their distance to \( \sqrt{10^7} \), it is a more complex approach to implement and not worth the effort.
Therefore, for simplicity, the primes are iterated over in ascending order, and the limit is arbitrarily set to \( 2\sqrt{10^7} \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-69"><a class="header" href="#solution-69">Solution</a></h1>
<hr />
<blockquote>
<p>8319823</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="ordered-fractions"><a class="header" href="#ordered-fractions"><a href="https://projecteuler.net/problem=71">Ordered fractions</a></a></h1>
<blockquote>
<p>Consider the fraction, \( \frac{n}{d} \), where n and d are positive integers. If \(n &lt; d\) and \( HCF(n,d) = 1 \), it is called a reduced proper fraction.</p>
<p>If we list the set of reduced proper fractions for \( d ≤ 8 \) in ascending order of size, we get:</p>
<p>\[
\frac{1}{8},\frac{1}{7},\frac{1}{6},\frac{1}{5},\frac{1}{4},\frac{2}{7},\frac{1}{3},\frac{3}{8},\mathbf{\frac{2}{5}},\frac{3}{7},\frac{1}{2},\frac{4}{7},\frac{3}{5},\frac{5}{8},\frac{2}{3},\frac{5}{7},\frac{3}{4},\frac{4}{5},\frac{5}{6},\frac{6}{7},\frac{7}{8}
\]</p>
<p>It can be seen that \( \frac{2}{5} \) is the fraction immediately to the left of \( \frac{3}{7} \).</p>
<p>By listing the set of reduced proper fractions for d ≤ \( 1,000,000 \) in ascending order of size, find the numerator of the fraction immediately to the left of \( \frac{3}{7} \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-69"><a class="header" href="#brute-force-69">Brute force</a></h1>
<p>The problem is to find the maximum reduced proper fraction \( \frac{n}{d} &lt; \frac{3}{7} \) with \( n &lt; d \leq 1000000 \).</p>
<p>The brute force approach iterate over every \( n \) and \( d \) and find the maximum fraction that satisfies the condition.
There is no need to reduce the fraction since the iteration is ascending and the reduced fraction will be found first.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0071/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def ordered_fractions(limit=1000001):
    res = 0, 1
    for n in range(1, limit):
        for d in range(1, limit):
            if res[0] / res[1] &lt; n / d &lt; 3 / 7:
                res = n, d
    return res[0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="farey-sequence"><a class="header" href="#farey-sequence">Farey sequence</a></h1>
<p>The <a href="problems/problem_0071/solution1.html">Brute force</a> is inefficient because the iterations are not in ascending order of \( \frac{n}{d} \).
On way to optimize the solution would be to increase \( n \) until \( \frac{n}{d} &gt; \frac{3}{7} \) and then decrease \( d \) until \( \frac{n}{d} &lt; \frac{3}{7} \), stopping just before either condition is met.
However, a much better solution involves using Farey sequences.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Farey_sequence">Farey sequence</a> is a list of all sorted reduced proper fractions between 0 and 1.</p>
<p>The Farey sequence is constructed by starting with the two fractions \( \frac{0}{1} \) and \( \frac{1}{1} \) and then inserting the mediant of every adjacent pair of fractions.
Each new fraction \( \frac{a + c}{b + d} \) is inserted between \( \frac{a}{b} \) and \( \frac{c}{d} \).</p>
<p>In this problem, we know that \( \frac{2}{5} &lt; \frac{3}{7} \).
Therefore, the solution can be obtained by finding the largest fraction in the Farey sequence with a denominator less than or equal to 1,000,000.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0071/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def ordered_fractions(limit=1000000):
    a, b = 2, 5
    c, d = 3, 7

    while b + d &lt;= limit:
        a, b = a + c, b + d

    return a
</code></pre>
<p>We can further optimize this solution by noting that \( b \) is always updated by adding \( d \) until \( b + d &gt; 1000000 \).
This operation is performed \( k = \lfloor \frac{1000000 - b}{d} \rfloor \) times, so the denominator of the largest fraction is \( b + kd \) and the numerator is \( a + kc \).
For this problem, the largest numerator is \( 2 + 3\lfloor \frac{1000000 - 5}{7} \rfloor = 428570 \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-70"><a class="header" href="#solution-70">Solution</a></h1>
<hr />
<blockquote>
<p>428570</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting-fractions"><a class="header" href="#counting-fractions"><a href="https://projecteuler.net/problem=72">Counting fractions</a></a></h1>
<blockquote>
<p>Consider the fraction, \( \frac{n}{d} \), where n and d are positive integers. If \(n &lt; d\) and \( HCF(n,d) = 1\), it is called a reduced proper fraction.</p>
<p>If we list the set of reduced proper fractions for \( d \leq 8 \) in ascending order of size, we get:</p>
<p>\[
\frac{1}{8}, \frac{1}{7}, \frac{1}{6}, \frac{1}{5}, \frac{1}{4}, \frac{2}{7}, \frac{1}{3}, \frac{3}{8}, \frac{2}{5}, \frac{3}{7}, \frac{1}{2}, \frac{4}{7}, \frac{3}{5}, \frac{5}{8}, \frac{2}{3}, \frac{5}{7}, \frac{3}{4}, \frac{4}{5}, \frac{5}{6}, \frac{6}{7}, \frac{7}{8}
\]</p>
<p>It can be seen that there are \( 21 \) elements in this set.</p>
<p>How many elements would be contained in the set of reduced proper fractions for \( d \leq 1,000,000 \) ?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-70"><a class="header" href="#brute-force-70">Brute force</a></h1>
<p>The <a href="problems/problem_0072/../problem_0071/problem.html">Problem 0071</a> teach us that Farey sequences are useful to solve problem involving HCF.
Given two fractions \( \frac{a}{b} \) and \( \frac{c}{d} \), it is possible to determine the mediant \( \frac{a+c}{b+d} \).</p>
<p>In this problem, the first two terms are \( \frac{0}{1} \) and \( \frac{1}{n} \), with \( n=1000000 \).
The next term \( \frac{p}{q} \) can be found using the first two terms \( \frac{a}{b} \) and \( \frac{c}{d} \):</p>
<p>\[
\frac{a + p}{b + q} = \frac{c}{d}
\]</p>
<p>Since \( \frac{c}{d} \) is in lowest terms, there exists an integer \( k \) such that \( a + p = kc \) and \( b + q = kd \).
Also, \( \frac{p}{q} - \frac{c}{d} = \frac{cb - da}{d(kd - b)} \) so the larger the value of \( k \), the closer \( \frac{p}{q} \) is to \( \frac{c}{d} \).
The next term \( \frac{p}{q} \) is the one with the largest \( k \) such that \( kd - b \leq n \Leftrightarrow k \leq \frac{n + b}{d} \).
This gives the following recurrence relation:</p>
<p>\[
p = \left\lfloor \frac{n + b}{d} \right\rfloor c - a \\
q = \left\lfloor \frac{n + b}{d} \right\rfloor d - b
\]</p>
<p>This relation can be used to generate all the terms of the Farey sequence, in our case, counting the number of terms is enough to solve the problem.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0072/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def counting_fractions(n=1000001):
    a, b, c, d = 0, 1, 1, n
    res = 0

    while c &lt;= n:
        k = (n + b) // d
        a, b, c, d = c, d, k * c - a, k * d - b
        res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="farey-sequence-and-eulers-totient-function"><a class="header" href="#farey-sequence-and-eulers-totient-function">Farey sequence and Euler's totient function</a></h1>
<p>The <a href="problems/problem_0072/solution1.html">Brute force</a> solution is inefficient due to the large number of terms in the Farey sequence.
However, it is still possible to use the Farey sequence to solve this problem efficiently.
A Farey sequence of order \( n \) is defined as the sequence of irreducible fractions between \( 0 \) and \( 1 \) whose denominators do not exceed \( n \).
The number of terms in the Farey sequence is given by the formula \( \left | F_n \right | = \left | F_{n-1} \right | + \phi(n) \), where \( \phi(n) \) is Euler's totient function.
Using the fact that \( \left | F_1 \right | = 2 \), then \( \left | F_n \right | = 1 + \sum_{k=1}^{n} \phi(k) \).</p>
<p>The sum of the totient function is something already done in <a href="problems/problem_0072/../problem_0069/problem.html">Problem 0069</a>.
In this problem, \( \frac{0}{1} \) and \( \frac{1}{n} \) are not counted, so the answer is \( \left | F_n \right | = \sum_{k=1}^{n} \phi(k) - 1 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0072/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def counting_fractions(n=1000000):
    tlist = list(range(n + 1))

    for i in range(1, n + 1):
        p = tlist[i]
        for j in range(2 * i, n + 1, i):
            tlist[j] -= p

    return sum(tlist) - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-71"><a class="header" href="#solution-71">Solution</a></h1>
<hr />
<blockquote>
<p>303963552391</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting-fractions-in-a-range"><a class="header" href="#counting-fractions-in-a-range"><a href="https://projecteuler.net/problem=73">Counting fractions in a range</a></a></h1>
<blockquote>
<p>Consider the fraction, \( \frac{n}{d} \), where n and d are positive integers. If \( n &lt; d \) and \( HCF(n,d) = 1 \), it is called a reduced proper fraction.</p>
<p>If we list the set of reduced proper fractions for \( d \leq 8 \) in ascending order of size, we get:</p>
<p>\[
\frac{1}{8}, \frac{1}{7}, \frac{1}{6}, \frac{1}{5}, \frac{1}{4}, \frac{2}{7}, \frac{1}{3}, \mathbf{\frac{3}{8}, \frac{2}{5}, \frac{3}{7}}, \frac{1}{2}, \frac{4}{7}, \frac{3}{5}, \frac{5}{8}, \frac{2}{3}, \frac{5}{7}, \frac{3}{4}, \frac{4}{5}, \frac{5}{6}, \frac{6}{7}, \frac{7}{8}
\]</p>
<p>It can be seen that there are \( 3 \) fractions between \( \frac{1}{3} \) and \( \frac{1}{2} \).</p>
<p>How many fractions lie between \( \frac{1}{3} \) and \( \frac{1}{2} \) in the sorted set of reduced proper fractions for \( d \leq 12,000 \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-71"><a class="header" href="#brute-force-71">Brute force</a></h1>
<p>The problem is to find the number of reduced proper fractions \( \frac{n}{d} \) such that \( \frac{1}{3} &lt; \frac{n}{d} &lt; \frac{1}{2} \) and \( n \) and \( d \) are coprime.
A brute force solution generates all Farey sequences between \( \frac{1}{3} \) and \( \frac{1}{2} \) and counting the number of fractions in each sequence.</p>
<p>The Stern-Brocot tree can be used to generate Farey sequences.
Starting from two adjacent fractions \( \frac{a}{b} \) and \( \frac{c}{d} \), the mediant \( \frac{a+c}{b+d} \) is also in the Farey sequence.
This process can be repeated with the left fraction and the mediant, and the right fraction and the mediant, and so on.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0073/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def stern_brocot_tree(a, b, c, d):
    if b + d &gt; 12000:
        return 0

    return 1 + stern_brocot_tree(a, b, a + c, b + d) + stern_brocot_tree(a + c, b + d, c, d)
</code></pre>
<p>To solve the problem, the rest is to initialize the tree with the fractions \( \frac{1}{3} \) and \( \frac{1}{2} \), and count the number of fractions in the Farey sequence between them.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0073/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def counting_fractions_in_a_range():
    return stern_brocot_tree(1, 3, 1, 2)
</code></pre>
<p>It is worth noting that the Python default recursion limit may need to be increased for this solution to work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-72"><a class="header" href="#solution-72">Solution</a></h1>
<hr />
<blockquote>
<p>7295372</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="digit-factorial-chains"><a class="header" href="#digit-factorial-chains"><a href="https://projecteuler.net/problem=74">Digit factorial chains</a></a></h1>
<blockquote>
<p>The number \( 145 \) is well known for the property that the sum of the factorial of its digits is equal to \( 145 \):</p>
<p>\[
1! + 4! + 5! = 1 + 24 + 120 = 145
\]</p>
<p>Perhaps less well known is \( 169 \), in that it produces the longest chain of numbers that link back to \( 169 \); it turns out that there are only three such loops that exist:</p>
<p>\[
\begin{align}
&amp;169 \rightarrow 363601 \rightarrow 1454 \rightarrow 169\\
&amp;871 \rightarrow 45361 \rightarrow 871\\
&amp;872 \rightarrow 45362 \rightarrow 872
\end{align}
\]</p>
<p>It is not difficult to prove that EVERY starting number will eventually get stuck in a loop. For example,</p>
<p>\[
\begin{align}
&amp;69 \rightarrow 363600 \rightarrow 1454 \rightarrow 169 \rightarrow 363601 (\rightarrow 1454)\\
&amp;78 \rightarrow 45360 \rightarrow 871 \rightarrow 45361 (\rightarrow 871)\\
&amp;540 \rightarrow 145 (\rightarrow 145)
\end{align}
\]</p>
<p>Starting with \( 69 \) produces a chain of five non-repeating terms, but the longest non-repeating chain with a starting number below one million is sixty terms.</p>
<p>How many chains, with a starting number below one million, contain exactly sixty non-repeating terms?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-72"><a class="header" href="#brute-force-72">Brute force</a></h1>
<p>The objective is to determine the number of chains with a starting number below one million that consist of exactly sixty non-repeating terms.</p>
<p>A straightforward approach is to iterate through each number below one million, calculate the chain using a set to track the terms already seen, and increment the count if the chain has exactly sixty terms.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0074/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def digit_factorial_chains():
    res = 0
    factorials = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
    for i in range(1, 1000000):
        found = set()
        while i not in found:
            found.add(i)
            i = sum([factorials[int(digit)] for digit in str(i)])
        if len(found) == 60:
            res += 1
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching-the-chain"><a class="header" href="#caching-the-chain">Caching the chain</a></h1>
<p>The main drawback of the <a href="problems/problem_0074/./solution1.html">Brute force</a> approach is that it recalculates the whole chain for each number.
One way to improve the performance is to cache the length of the chain for each number of the chain.</p>
<p>This approach use a dictionary to store the chain length for each number.
Instead of using a set, a list is preferred to keep track of the position of each number in the chain.
For each number below one million, the chain is computed as before.
However, if the current number already exists in the dictionary, indicating that its length is already known, the computation can be terminated prematurely.</p>
<p>Upon completion of the chain, every number in the current chain is added to the dictionary.
The value assigned to each number is equal to its position in the chain plus the length of the final element in the chain.
If the final element is not present in the dictionary, its length is set to zero.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0074/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def digit_factorial_chains():
    res = 0
    factorials = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
    cache = {}
    for i in range(1, 1000000):
        found = []
        while i not in found and i not in cache:
            found.append(i)
            i = sum([factorials[int(digit)] for digit in str(i)])
        for j, v in enumerate(found):
            cache[v] = len(found) - j + cache.get(i, 0)
            if cache[v] == 60:
                res += 1
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-73"><a class="header" href="#solution-73">Solution</a></h1>
<hr />
<blockquote>
<p>402</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="singular-integer-right-triangles"><a class="header" href="#singular-integer-right-triangles"><a href="https://projecteuler.net/problem=75">Singular Integer Right Triangles</a></a></h1>
<blockquote>
<p>It turns out that \( 12 \)cm is the smallest length of wire that can be bent to form an integer sided right angle triangle in exactly one way, but there are many more examples.</p>
<ul>
<li>\( 12 \) cm: \( (3,4,5) \)</li>
<li>\( 24 \) cm: \( (6,8,10) \)</li>
<li>\( 30 \) cm: \( (5,12,13) \)</li>
<li>\( 36 \) cm: \( (9,12,15) \)</li>
<li>\( 40 \) cm: \( (8,15,17) \)</li>
<li>\( 48 \) cm: \( (12,16,20) \)</li>
</ul>
<p>In contrast, some lengths of wire, like \( 20 \) cm, cannot be bent to form an integer sided right angle triangle, and other lengths allow more than one solution to be found; for example, using \( 120 \) cm it is possible to form exactly three different integer sided right angle triangles.</p>
<ul>
<li>\( 120 \) cm: \( (30,40,50), (20,48,52), (24,45,51) \)</li>
</ul>
<p>Given that \( L \) is the length of the wire, for how many values of \( L \le 1,500,000 \) can exactly one integer sided right angle triangle be formed?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-of-primitive-pythagorean-triples-1"><a class="header" href="#tree-of-primitive-pythagorean-triples-1">Tree of primitive Pythagorean triples</a></h1>
<p>The objective is to determine the number of Pythagorean triples that yield a unique perimeter.</p>
<p>Thanks to <a href="problems/problem_0075/../problem_0039/problem.html">Problem 0039</a>, the process of computing all pythagorean triples becomes straightforward</p>
<p>We can actually use the code in the <a href="problems/problem_0075/../problem_0039/solution4.html">Tree of primitive Pythagorean triples</a> solution.
However, we need to replace the return statement in order to count the number of perimeter that can only be formed in one possible way.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0075/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def compute_all_pythagorean_triples(results, max_p, abc):
    curr_p = sum(abc)
    if curr_p &lt; max_p:
        for perimeter in range(curr_p, max_p, curr_p):
            results[perimeter] += 1
        compute_all_pythagorean_triples(results, max_p, A @ abc)
        compute_all_pythagorean_triples(results, max_p, B @ abc)
        compute_all_pythagorean_triples(results, max_p, C @ abc)
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0075/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def singular_integer_right_triangles():
    results = defaultdict(int)
    compute_all_pythagorean_triples(results, 1500000, np.array([3, 4, 5]))
    return sum(filter(lambda x: x == 1, results.values()))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-74"><a class="header" href="#solution-74">Solution</a></h1>
<hr />
<blockquote>
<p>161667</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting-summations"><a class="header" href="#counting-summations"><a href="https://projecteuler.net/problem=76">Counting Summations</a></a></h1>
<blockquote>
<p>It is possible to write five as a sum in exactly six different ways:</p>
<p>How many different ways can one hundred be written as a sum of at least two positive integers?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-5"><a class="header" href="#dynamic-programming-5">Dynamic programming</a></h1>
<p>The problems is a variation of the <a href="https://projecteuler.net/problem=31">Coins sums</a> problem.
The only difference is the number of coins, which is now 1, 2, 3, ..., 99.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0076/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def counting_summations(n=100):
    numbers = list(range(1, n))
    cache = [1] + [0] * n

    for number in numbers:
        for i in range(number, n + 1):
            cache[i] += cache[i - number]

    return cache[-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-75"><a class="header" href="#solution-75">Solution</a></h1>
<hr />
<blockquote>
<p>190569291</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-summations"><a class="header" href="#prime-summations"><a href="https://projecteuler.net/problem=77">Prime Summations</a></a></h1>
<blockquote>
<p>It is possible to write ten as the sum of primes in exactly five different ways:</p>
<p>What is the first value which can be written as the sum of primes in over five thousand different ways?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-6"><a class="header" href="#dynamic-programming-6">Dynamic programming</a></h1>
<p>The problems is a variation of the <a href="https://projecteuler.net/problem=31">Coins sums</a> problem.
The only difference is the number of coins, which is now prime numbers.
With trial and error, setting the limit to 100 is enough to get the correct answer.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0077/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def prime_summations(n=100):
    numbers = list(sieve.primerange(1, n + 1))
    cache = [1] + [0] * n

    for number in numbers:
        for i in range(number, n + 1):
            cache[i] += cache[i - number]

    return next(i for i, x in enumerate(cache) if x &gt; 5000)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-76"><a class="header" href="#solution-76">Solution</a></h1>
<hr />
<blockquote>
<p>71</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="coin-partitions"><a class="header" href="#coin-partitions"><a href="https://projecteuler.net/problem=78">Coin Partitions</a></a></h1>
<blockquote>
<p>Let \( p(n) \) represent the number of different ways in which \( n \) coins can be separated into piles. For example, five coins can be separated into piles in exactly seven different ways, so \( p(5) = 7\).</p>
<p>\[
\begin{align}
&amp;OOOOO\\
&amp;OOOO\ \ O\\
&amp;OOO\ \ OO\\
&amp;OOO\ \ O\ \ O\\
&amp;OO\ \ OO\ \ O\\
&amp;OO\ \ O\ \ O\ \ O\\
&amp;O\ \ O\ \ O\ \ O\ \ O
\end{align}
\]</p>
<p>Find the least value of n for which \( p(n) \) is divisible by one million.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-is-hidden-recursion-problem"><a class="header" href="#dynamic-programming-is-hidden-recursion-problem">Dynamic programming is hidden recursion problem</a></h1>
<p>Another coins problem, another dynamic programming solution !
This solution comes naturally when you try to find the different ways \( n \) coins can be separated into piles.</p>
<p>If you were to solve this by hand, you will start with piles of size 1, then of size 2 and one, then of size 3, 2 and one, and so on.
The goal is to find a recurrence relation between \( p(n, k) \) and \( p(n, k+1) \) where \( p(n, k) \) denotes the number of ways to partition \( n \) coins into piles of size \(
k \) or less.</p>
<p>Consider this table:</p>
<style>
table th {
  position: relative;
}

.line {
  position: absolute;
  height: 33px;
  top: 27px;
  bottom: 0;
  margin: auto;
  left: -6px;
  width: 100%;
  border-top: 1px solid #000;
  transform: rotate(25deg); 
}

.diagonal {
  width: 47px;
}
.diagonal span.lb {
  position: absolute;
  bottom: -2px;
  left: 8px;
}
.diagonal span.rt {
  position: absolute;
  top: -5px;
  right: 7px;
}
</style>
<table>
    <tr>
        <th class="diagonal">
          <span class="lb"><strong>n</strong></span>
          <span class="rt"><strong>k</strong></span>
          <div class="line"></div>
        </th>
        <th><strong>1</strong></th>
        <th><strong>2</strong></th>
        <th><strong>3</strong></th>
        <th><strong>4</strong></th>
        <th><strong>5</strong></th>
    </tr>
    <tr>
        <th><strong>1</strong></th>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
    </tr>
    <tr>
        <th><strong>2</strong></th>
        <td>1</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
        <th><strong>3</strong></th>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>3</td>
        <td>3</td>
    </tr>
    <tr>
        <th><strong>4</strong></th>
        <td>1</td>
        <td>3</td>
        <td>4</td>
        <td>5</td>
        <td>5</td>
    </tr>
    <tr>
        <th><strong>5</strong></th>
        <td>1</td>
        <td>3</td>
        <td>5</td>
        <td>6</td>
        <td>7</td>
    </tr>
</table>
<p>Each cell \( (n, k) \) represents the number of ways to partition \( n \) coins into piles of size \( k \) or less.
The recurrence relation closely resembles the of for the <a href="problems/problem_0078/../problem_0031/solution1.html">coin sums problem</a>:</p>
<p>\[ p(n, k) = p(n, k-1) + p(n-k, k) \]</p>
<p>The first term represents the number of ways to partition \( n \) coins into piles of size \( k-1 \) or less, while the second term represents the number of ways to separate \( n \) coins using at least one pile of size \( k \).
Finally, the base cases are \( p(0, k) = 1 \) and \( p(n, k) = p(n, k -1) \) if \( n &lt; k \).</p>
<p>The rest of the code is relatively straightforward if you understand that you can compute each column of the table one after the other.
Furthermore, since you only care about the remainder of the division by \( 10^6 \), you can use the modulo operator to keep the numbers small.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0078/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def coin_partitions(limit=100000):
    divisible_by = 1000000
    cache = [1] * (limit + 1)
    for l in range(2, limit + 1):
        cache[l] = (cache[l] + 1) % divisible_by

        if cache[l] == 0:
            return l

        for n in range(l + 1, limit + 1):
            cache[n] = (cache[n] + cache[n - l]) % divisible_by
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="euler-partition-function"><a class="header" href="#euler-partition-function">Euler partition function</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Partition_function_(number_theory)">partition function</a> \( p(n) \) represents the number of ways to partition \( n \) coins into piles of size \( k \) or less, that is, the function we are looking for.
Using <a href="https://en.wikipedia.org/wiki/Partition_function_(number_theory)#Recurrence_relations">Euler's recurrence relation</a>, we can calculate \( p(n) \) for any \( n \):
\[
\begin{aligned}
p(n) &amp;= \sum_{k\in\mathbb{Z}\backslash\{0\}}^{\infty} (-1)^{k+1} p \left( n - \frac{k(3k-1)}{2} \right)\\
&amp;= \sum_{k=1}^{\infty} (-1)^{k+1} \left[ p \left( n - \frac{k(3k-1)}{2} \right) + p \left( n - \frac{k(3k+1)}{2} \right) \right]
\end{aligned}
\]</p>
<p>This summation is over all nonzero integers \( k \), but since \( p(n) = 0 \) for \( n &lt; 0 \), the series has only finitely many nonzero terms, and can be computed in a finite amount of time.</p>
<p>Using python mutable variables as a cache for previously computed \( p(n) \) values, we can compute \( p(n) \) much more effeciently than the last solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0078/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def p(n, cache={}):
    if n in cache:
        return cache[n]
    if n &lt; 0:
        return 0
    if n &lt; 2:
        return 1

    cum_sum = 0
    for k in range(1, n + 1):
        n1 = n - k * (3 * k - 1) // 2
        n2 = n - k * (3 * k + 1) // 2
        cum_sum += (-1) ** (k + 1) * (p(n1, cache) + p(n2, cache))
        if n1 &lt;= 0:  # n1 &lt; n2, no need to check both
            break

    cache[n] = cum_sum % 1000000
    return cache[n]
</code></pre>
<p>The rest is to find the smallest \( n \) such that \( p(n) \) is divisible by \( 10^6 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0078/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def coin_partitions(n=1000000):
    for i in itertools.count(0):
        r = p(i)
        if r % n == 0:
            return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-77"><a class="header" href="#solution-77">Solution</a></h1>
<hr />
<blockquote>
<p>71</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="passcode-derivation"><a class="header" href="#passcode-derivation"><a href="https://projecteuler.net/problem=79">Passcode Derivation</a></a></h1>
<blockquote>
<p>A common security method used for online banking is to ask the user for three random characters from a passcode. For example, if the passcode was \( 531278 \), they may ask for the \( 2 \)nd, \( 3 \)rd, and \( 5 \)th characters; the expected reply would be: \( 317 \).</p>
<p>The text file, <a href="https://projecteuler.net/resources/documents/0079_keylog.txt">keylog.txt</a>, contains fifty successful login attempts.</p>
<p>Given that the three characters are always asked for in order, analyse the file so as to determine the shortest possible secret passcode of unknown length.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topological-sorting"><a class="header" href="#topological-sorting">Topological sorting</a></h1>
<h2 id="problem"><a class="header" href="#problem">Problem:</a></h2>
<p>We need to to find the shortest passcode based on a series of samples containing three random characters chosen in order.</p>
<h2 id="understanding-the-problem"><a class="header" href="#understanding-the-problem">Understanding the problem</a></h2>
<p>For example, if the samples are \( 145 \), \( 456\) and \( 146 \), we can infer certain order constraints, like \( 1 \) must be before \( 4 \), \( 4 \) before \( 5 \), and so on.
We also know that \( 1 \) is before \( 5 \), but it would be redundant since we already know that \( 1 \) is before \( 4 \) and \( 4 \) is before \( 5 \).</p>
<p>We can represent these constraints as a directed graph, where the nodes are the characters and the edges describe the constraints, i.e. if there is an edge \( a \rightarrow b \), then \( a \) is before \( b \).
For the previous example, the graph would be:</p>
<p align="center">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="332pt" height="67pt" viewBox="0.00 0.00 332.00 67.00">
        <use href="../../images/p0079/p0079-s1-ex-graph.svg#graph"> </use>
    </svg>
</p>
<p>From this graph, it's clear that the shortest passcode is \( 1456 \).
But what if the graph was more complex?
If it was, we would need some algorithm to find the solution, and that is where <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sorting</a> comes in handy.</p>
<h2 id="solution-78"><a class="header" href="#solution-78">Solution</a></h2>
<p>The first step is to read the file:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0079/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return file.read().splitlines()
</code></pre>
<p>Then, we can compute the graph.
I chose to represent the graph as a dictionary of sets, where the keys are the nodes and the values the connected nodes.
Using the previous example, the graph would be represented as:</p>
<pre><code class="language-python">{
    '1': {'4'},
    '4': {'5', '6'},
    '5': {'6'},
}
</code></pre>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0079/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def compute_graph(char):
    graph = defaultdict(set)
    for a, b, c in char:
        graph[a].add(b)
        graph[b].add(c)

    return graph
</code></pre>
<p>Using some visualization, here's what the graph looks like with the real data:</p>
<p align="center">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="692pt" height="317pt" viewBox="0.00 0.00 692.00 317.14">
        <use href="../../images/p0079/p0079-s1-full-graph.svg#graph"> </use>
    </svg>
</p>
<p>Quite tentacular, but we can still guess the passcode: \( 73162890 \).
For the topological sorting, I've opted to use <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a> since it's the easiest to implement.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0079/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def topological_sort(graph):
    marked = set()
    result = []

    def dfs(node):
        if node not in marked:
            # Using defaultdict requires us to check if the node is in the graph
            # to prevent errors during iteration caused by unintentional key creation.
            if node in graph:
                for neighbour in graph[node]:
                    dfs(neighbour)
            marked.add(node)
            result.insert(0, node)

    for node in graph:
        dfs(node)

    return result
</code></pre>
<p>Finally, we merge everything together to obtain the solution:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0079/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def passcode_derivation(filename=&quot;keylog.txt&quot;):
    chars = read_file(filename)
    graph = compute_graph(chars)
    passcode = topological_sort(graph)
    return &quot;&quot;.join(passcode)
</code></pre>
<p>The passcode is indeed \( 73162890 \).</p>
<p>If you understood the solution, you might have noticed that we assumed that the graph is <a href="https://en.wikipedia.org/wiki/Cycle_(graph_theory)">acyclic</a>, meaning it has no cycles.
In our case, this implies that there is no redundant numbers in the passcode.
If there were cycles, finding the passcode would be more challenging... Maybe it will be the subject of another solution?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-79"><a class="header" href="#solution-79">Solution</a></h1>
<hr />
<blockquote>
<p>73162890</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="square-root-digital-expansion"><a class="header" href="#square-root-digital-expansion"><a href="https://projecteuler.net/problem=80">Square Root Digital Expansion</a></a></h1>
<blockquote>
<p>It is well known that if the square root of a natural number is not an integer, then it is irrational. The decimal expansion of such square roots is infinite without any repeating pattern at all.</p>
<p>The square root of two is \( 1.41421356237309504880 \cdots \), and the digital sum of the first one hundred decimal digits is \( 475 \).</p>
<p>For the first one hundred natural numbers, find the total of the digital sums of the first one hundred decimal digits for all the irrational square roots.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="square-roots-by-subtraction"><a class="header" href="#square-roots-by-subtraction">Square roots by subtraction</a></h1>
<h2 id="problem-1"><a class="header" href="#problem-1">Problem</a></h2>
<p>We need to find the sum of the first one hundred decimal digits of the square roots of the first one hundred natural numbers.</p>
<h2 id="understanding-the-problem-1"><a class="header" href="#understanding-the-problem-1">Understanding the problem</a></h2>
<p>The problem is not difficult to understand, the challenge lies in determining the decimal digits of the square roots.</p>
<h2 id="solution-80"><a class="header" href="#solution-80">Solution</a></h2>
<p>We could use Python's decimal module, but that would not be very interesting.
Instead, we will use an algorithm that computes square roots digit by digit.
As usual, Wikipedia has <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Digit-by-digit_calculation">plenty to offer</a>.
I chose the <a href="https://studylib.net/doc/7921494/square-roots-by-subtraction---jarvis--frazer">subtraction method</a> from Jarvis Frazer as it seemed the easiest to implement.</p>
<p>Let \( a = 5n \) and \( b = 5 \), where \( n \) is the number whose square root we want to compute.
We follow the following rules:</p>
<p>\[
\begin{align}
&amp;(R1) \ If\ a\geqslant b,\ replace\ a\ with\ a-b,\ and\ add\ 10\ to\ b.\\
&amp;(R2) \ If\ a&lt; b,\ add\ two\ zeroes\ to\ the\ end\ of\ a,\ and\ add\ a\ zero\ to\ b\ just\ before\ the\ final\ digit.
\end{align}
\]</p>
<p>The process is repeated until \( b \), which approximates the square root of \( n \), is greater than \( 10^{p + 1} \) where \( p \) is the precision.
In our case, \( p = 100 \).
The only special case is when \( a = 0 \), indicating that \( n \) is a perfect square, which si not considered in this problem.</p>
<p>The code is pretty straightforward:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0080/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def square_root(n):
    a, b = 5 * n, 5
    while b &lt; 10**101:
        if a &gt;= b:
            a -= b
            b += 10
        else:
            # Perfect square
            if a == 0:
                return 0
            a *= 100
            b = (b // 10) * 100 + 5

    return b
</code></pre>
<p>To obtain the result, we just have to sum the digits of the first one hundred square roots:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0080/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def square_root_digital_expansion():
    return sum(int(c) for n in range(1, 101) for c in str(square_root(n))[:100])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-81"><a class="header" href="#solution-81">Solution</a></h1>
<hr />
<blockquote>
<p>40886</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-sum-two-ways"><a class="header" href="#path-sum-two-ways"><a href="https://projecteuler.net/problem=81">Path Sum: Two Ways</a></a></h1>
<blockquote>
<p>In the \( 5 \) by \( 5 \) matrix below, the minimal path sum from the top left to the bottom right, by <strong>only moving to the right and down</strong>, is indicated in bold red and is equal to \( 2427 \).</p>
<p>\[
\begin{pmatrix}
\color{red}{131} &amp; 673 &amp; 234 &amp; 103 &amp; 18\\
\color{red}{201} &amp; \color{red}{96} &amp; \color{red}{342} &amp; 965 &amp; 150\\
630 &amp; 803 &amp; \color{red}{746} &amp; \color{red}{422} &amp; 111\\
537 &amp; 699 &amp; 497 &amp; \color{red}{121} &amp; 956\\
805 &amp; 732 &amp; 524 &amp; \color{red}{37} &amp; \color{red}{331}\\
\end{pmatrix}
\]</p>
<p>Find the minimal path sum from the top left to the bottom right by only moving right and down in <a href="https://projecteuler.net/resources/documents/0081_matrix.txt">matrix.txt</a> (right click and &quot;Save Link\( / \)Target As\( ... \)&quot;), a \( 31 \)K text file containing an \( 80 \) by \( 80 \) matrix.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-7"><a class="header" href="#dynamic-programming-7">Dynamic programming</a></h1>
<h2 id="problem-2"><a class="header" href="#problem-2">Problem</a></h2>
<p>This problem is very similar to <a href="problems/problem_0081/../problem_0018/problem.html">Problem 18</a> and <a href="problems/problem_0081/../problem_0067/problem.html">Problem 67</a>
However, instead of a triangular structure, we are dealing with square matrix.
The objective is to find the path from the top left corner to the bottom right corner with the smallest sum.</p>
<h2 id="understanding-the-problem-2"><a class="header" href="#understanding-the-problem-2">Understanding the problem</a></h2>
<p>We can use dynamic programming just like in <a href="problems/problem_0081/../problem_0018/problem.html">Problem 18</a> and <a href="problems/problem_0081/../problem_0067/problem.html">Problem 67</a>.
Starting from the top left corner, we iterate line by line to the bottom right corner.
At each cell, we find which neighboring cell (above or to the left) has the smallest sum and add it to the current cell.
This process is repeated until we reach the bottom right corner.</p>
<h2 id="solution-82"><a class="header" href="#solution-82">Solution</a></h2>
<p>The first step is to read the file and store the matrix in a list of lists.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0081/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return [[int(x) for x in line.split(&quot;,&quot;)] for line in file.read().splitlines()]
</code></pre>
<p>The algorithm is straightforward, we just need to take care of the edges cases where we can't go up or left.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0081/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def path_sum_two_ways(filename=&quot;matrix.txt&quot;):
    matrix = read_file(filename)
    for i in range(len(matrix[0])):
        for j in range(len(matrix[0])):
            if i == 0 and j == 0:
                continue
            elif i == 0:
                matrix[i][j] += matrix[i][j - 1]
            elif j == 0:
                matrix[i][j] += matrix[i - 1][j]
            else:
                matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])
    return matrix[-1][-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-83"><a class="header" href="#solution-83">Solution</a></h1>
<hr />
<blockquote>
<p>427337</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-sum-three-ways"><a class="header" href="#path-sum-three-ways"><a href="https://projecteuler.net/problem=82">Path Sum: Three Ways</a></a></h1>
<blockquote>
<p>NOTE: This problem is a more challenging version of <a href="https://projecteuler.net/problem=81">Problem 81</a>.</p>
<p>The minimal path sum in the \( 5 \) by \( 5 \) matrix below, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down, and right, is indicated in red and bold; the sum is equal to \( 994 \).</p>
<p>\[
\begin{pmatrix}
131 &amp; 673 &amp; \color{red}{234} &amp; \color{red}{103} &amp; \color{red}{18}\\
\color{red}{201} &amp; \color{red}{96} &amp; \color{red}{342} &amp; 965 &amp; 150\\
630 &amp; 803 &amp; 746 &amp; 422 &amp; 111\\
537 &amp; 699 &amp; 497 &amp; 121 &amp; 956\\
805 &amp; 732 &amp; 524 &amp; 37 &amp; 331\\
\end{pmatrix}
\]</p>
<p>Find the minimal path sum from the left column to the right column in <a href="https://projecteuler.net/resources/documents/0082_matrix.txt">matrix.txt</a> (right click and &quot;Save Link\( / \)Target As\( ... \)&quot;), a \( 31 \)K text file containing an \( 80 \) by \( 80 \) matrix.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-8"><a class="header" href="#dynamic-programming-8">Dynamic programming</a></h1>
<h2 id="problem-3"><a class="header" href="#problem-3">Problem</a></h2>
<p>The problem is the exact same as <a href="problems/problem_0082/../problem_0081/problem.html">Problem 81</a>, but this time, we can go up.</p>
<h2 id="understanding-the-solution"><a class="header" href="#understanding-the-solution">Understanding the solution</a></h2>
<p>In this problem, moving up <strong>and</strong> down multiple times within the same column is allowed.
However, the optimal path won't go both up and down within the same column.
That would be wasting steps because every cell has a positive value.
So if we iterate from top to bottom, we only need to know if the cell above has been updated.
Similarly, if we iterate from bottom to top, we only need to know if the cell below has been updated.</p>
<p>Now, let's take a look at this example where we iterate from left to right for the first column: </p>
<p>\[
\begin{bmatrix}
\color{red}{1} &amp; 1 &amp; 10\\
\color{red}{10} &amp; 1 &amp; 10\\
\color{red}{15} &amp; 1 &amp; 1
\end{bmatrix} \Longrightarrow \begin{bmatrix}
1 &amp; \color{red}{2} &amp; 10\\
10 &amp; \color{red}{11} &amp; 10\\
15 &amp; \color{red}{16} &amp; 1
\end{bmatrix}\\
\]</p>
<p>Nothing fancy here; we add the left cell's value to the current cell.
Now, let's iterate from top to bottom for this column, updating the green cell:</p>
<p>\[
\begin{bmatrix}
1 &amp; \color{red}{2} &amp; 10\\
10 &amp; \color{green}{11} &amp; 10\\
15 &amp; \color{red}{16} &amp; 1
\end{bmatrix} \rightarrow (\color{red}{2} + 1) &lt; \color{green}{11}\rightarrow \begin{bmatrix}
1 &amp; \color{red}{2} &amp; 10\\
10 &amp; \color{red}{3} &amp; 10\\
15 &amp; \color{green}{16} &amp; 1
\end{bmatrix} \rightarrow (\color{red}{3} + 1) &lt; \color{green}{16}\rightarrow \begin{bmatrix}
1 &amp; \color{red}{2} &amp; 10\\
10 &amp; \color{red}{3} &amp; 10\\
15 &amp; \color{red}{4} &amp; 1
\end{bmatrix}\
\
\]</p>
<p>During the update, we're comparing the <span style="color:green">current cell's updated value</span> with the <span style="color:red">above cell updated value</span> plus the current cell's initial value.
For this case, \( \color{green}{11} \) is compared with \( \color{red}{2} + 1 \).
Keep repeating this process until you reach the column's bottom, then do the same from bottom to top:</p>
<p>\[
\begin{bmatrix}
1 &amp; \color{red}{2} &amp; 10\\
10 &amp; \color{green}{3} &amp; 10\\
15 &amp; \color{red}{4} &amp; 1
\end{bmatrix} \rightarrow (\color{red}{4} + 1) &gt; \color{green}{3}\rightarrow \begin{bmatrix}
1 &amp; \color{green}{2} &amp; 10\\
10 &amp; \color{red}{3} &amp; 10\\
15 &amp; \color{red}{4} &amp; 1
\end{bmatrix} \rightarrow (\color{red}{3} + 1) &gt; \color{green}{2}\rightarrow \begin{bmatrix}
1 &amp; \color{red}{2} &amp; 10\\
10 &amp; \color{red}{3} &amp; 10\\
15 &amp; \color{red}{4} &amp; 1
\end{bmatrix}\
\
\]</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>The first step is to read the file and store the matrix, in this case, in a list of lists.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0082/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, &quot;r&quot;) as file:
        return [[int(x) for x in line.split(&quot;,&quot;)] for line in file.read().splitlines()]
</code></pre>
<p>The main challenge is handling the top-to-bottom and bottom-to-top iterations.
Since we need to keep track of both the updated columns and initial columns, updating the matrix in place won't work.
Instead, we can create a copy of the first column that will represent the updated values of the current column's smallest path.</p>
<p>So, when updating from left to right, we simply add to this copy the value of the initial cell of the right column.
When updating from top to bottom, we compare the updated value of the current cell with the updated value of the cell above plus the initial value of the current cell.
The process is the same for the bottom-to-top iteration.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0082/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def path_sum_three_ways(filename=&quot;.txt&quot;):
    rows = read_file(filename)
    current = [r[0] for r in rows]

    for x in range(1, len(rows[0])):
        for y in range(len(rows)):  # Left to right
            current[y] += rows[y][x]
        print(current)
        for y in range(1, len(rows)):  # Top to bottom
            current[y] = min(current[y], current[y - 1] + rows[y][x])
        for y in range(len(rows) - 2, -1, -1):  # Bottom to top
            current[y] = min(current[y], current[y + 1] + rows[y][x])

    return min(current)
</code></pre>
<p>The answer is the minimum value of the copied column after we have iterated through the whole matrix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-84"><a class="header" href="#solution-84">Solution</a></h1>
<hr />
<blockquote>
<p>260324</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>You can download each solution and modify it as much as you like. However, 
please do not copy the answer to the Euler project without thinking about it 
first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>You can contribute as much as you want to the project, for more information
please see <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/README.md">README.md</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
