<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Project Euler</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Solution of Project Euler problems">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="problems/project_euler.html"><strong aria-hidden="true">2.</strong> Project Euler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0001/problem.html"><strong aria-hidden="true">2.1.</strong> Problem 1: Multiples of 3 and 5</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0001/solution1.html"><strong aria-hidden="true">2.1.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0001/solution2.html"><strong aria-hidden="true">2.1.2.</strong> Three by three</a></li><li class="chapter-item "><a href="problems/problem_0001/solution3.html"><strong aria-hidden="true">2.1.3.</strong> Summing everything</a></li><li class="chapter-item "><a href="problems/problem_0001/solution.html"><strong aria-hidden="true">2.1.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0002/problem.html"><strong aria-hidden="true">2.2.</strong> Problem 2: even Fibonacci numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0002/solution1.html"><strong aria-hidden="true">2.2.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0002/solution2.html"><strong aria-hidden="true">2.2.2.</strong> Fibonacci recurrence</a></li><li class="chapter-item "><a href="problems/problem_0002/solution3.html"><strong aria-hidden="true">2.2.3.</strong> Fibonacci and the golden ratio</a></li><li class="chapter-item "><a href="problems/problem_0002/solution.html"><strong aria-hidden="true">2.2.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0003/problem.html"><strong aria-hidden="true">2.3.</strong> Problem 3: Largest prime factor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0003/solution1.html"><strong aria-hidden="true">2.3.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0003/solution2.html"><strong aria-hidden="true">2.3.2.</strong> Two by two</a></li><li class="chapter-item "><a href="problems/problem_0003/solution.html"><strong aria-hidden="true">2.3.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0004/problem.html"><strong aria-hidden="true">2.4.</strong> Problem 4: Largest palindrome product</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0004/solution1.html"><strong aria-hidden="true">2.4.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0004/solution2.html"><strong aria-hidden="true">2.4.2.</strong> Factorisation is the key</a></li><li class="chapter-item "><a href="problems/problem_0004/solution3.html"><strong aria-hidden="true">2.4.3.</strong> With pen and paper</a></li><li class="chapter-item "><a href="problems/problem_0004/solution.html"><strong aria-hidden="true">2.4.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0005/problem.html"><strong aria-hidden="true">2.5.</strong> Problem 5: Smallest multiple</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0005/solution1.html"><strong aria-hidden="true">2.5.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0005/solution2.html"><strong aria-hidden="true">2.5.2.</strong> Prime factorization</a></li><li class="chapter-item "><a href="problems/problem_0005/solution3.html"><strong aria-hidden="true">2.5.3.</strong> Least common multiple</a></li><li class="chapter-item "><a href="problems/problem_0005/solution.html"><strong aria-hidden="true">2.5.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0006/problem.html"><strong aria-hidden="true">2.6.</strong> Problem 6: Sum square difference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0006/solution1.html"><strong aria-hidden="true">2.6.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0006/solution2.html"><strong aria-hidden="true">2.6.2.</strong> Summation formula</a></li><li class="chapter-item "><a href="problems/problem_0006/solution.html"><strong aria-hidden="true">2.6.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0007/problem.html"><strong aria-hidden="true">2.7.</strong> Problem 7: 10001st prime</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0007/solution1.html"><strong aria-hidden="true">2.7.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0007/solution2.html"><strong aria-hidden="true">2.7.2.</strong> Almost six by six</a></li><li class="chapter-item "><a href="problems/problem_0007/solution3.html"><strong aria-hidden="true">2.7.3.</strong> Prime number theorem</a></li><li class="chapter-item "><a href="problems/problem_0007/solution.html"><strong aria-hidden="true">2.7.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0008/problem.html"><strong aria-hidden="true">2.8.</strong> Problem 8: Largest product in a series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0008/solution1.html"><strong aria-hidden="true">2.8.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0008/solution2.html"><strong aria-hidden="true">2.8.2.</strong> 0 are useless</a></li><li class="chapter-item "><a href="problems/problem_0008/solution.html"><strong aria-hidden="true">2.8.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0009/problem.html"><strong aria-hidden="true">2.9.</strong> Problem 9: Special Pythagorean triplet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0009/solution1.html"><strong aria-hidden="true">2.9.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0009/solution2.html"><strong aria-hidden="true">2.9.2.</strong> With a little thought</a></li><li class="chapter-item "><a href="problems/problem_0009/solution3.html"><strong aria-hidden="true">2.9.3.</strong> Prime Pythagorean triples</a></li><li class="chapter-item "><a href="problems/problem_0009/solution.html"><strong aria-hidden="true">2.9.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0010/problem.html"><strong aria-hidden="true">2.10.</strong> Problem 10: Summation of primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0010/solution1.html"><strong aria-hidden="true">2.10.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0010/solution2.html"><strong aria-hidden="true">2.10.2.</strong> Summation minus summation</a></li><li class="chapter-item "><a href="problems/problem_0010/solution3.html"><strong aria-hidden="true">2.10.3.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0010/solution.html"><strong aria-hidden="true">2.10.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0011/problem.html"><strong aria-hidden="true">2.11.</strong> Problem 11: Largest product in a grid</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0011/solution1.html"><strong aria-hidden="true">2.11.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0011/solution.html"><strong aria-hidden="true">2.11.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0012/problem.html"><strong aria-hidden="true">2.12.</strong> Problem 12: Highly divisible triangular number</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0012/solution1.html"><strong aria-hidden="true">2.12.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0012/solution2.html"><strong aria-hidden="true">2.12.2.</strong> Common factor</a></li><li class="chapter-item "><a href="problems/problem_0012/solution.html"><strong aria-hidden="true">2.12.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0013/problem.html"><strong aria-hidden="true">2.13.</strong> Problem 13: Large sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0013/solution1.html"><strong aria-hidden="true">2.13.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0013/solution.html"><strong aria-hidden="true">2.13.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0014/problem.html"><strong aria-hidden="true">2.14.</strong> Problem 14: Longest Collatz sequence</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0014/solution1.html"><strong aria-hidden="true">2.14.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0014/solution2.html"><strong aria-hidden="true">2.14.2.</strong> Caching</a></li><li class="chapter-item "><a href="problems/problem_0014/solution.html"><strong aria-hidden="true">2.14.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0015/problem.html"><strong aria-hidden="true">2.15.</strong> Problem 15: Lattice paths</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0015/solution1.html"><strong aria-hidden="true">2.15.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0015/solution2.html"><strong aria-hidden="true">2.15.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0015/solution3.html"><strong aria-hidden="true">2.15.3.</strong> Combination</a></li><li class="chapter-item "><a href="problems/problem_0015/solution.html"><strong aria-hidden="true">2.15.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0016/problem.html"><strong aria-hidden="true">2.16.</strong> Problem 16: Power digit sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0016/solution1.html"><strong aria-hidden="true">2.16.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0016/solution.html"><strong aria-hidden="true">2.16.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0017/problem.html"><strong aria-hidden="true">2.17.</strong> Problem 17: Number letter counts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0017/solution1.html"><strong aria-hidden="true">2.17.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0017/solution.html"><strong aria-hidden="true">2.17.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0018/problem.html"><strong aria-hidden="true">2.18.</strong> Problem 18: Maximum path sum I</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0018/solution1.html"><strong aria-hidden="true">2.18.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0018/solution2.html"><strong aria-hidden="true">2.18.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0018/solution.html"><strong aria-hidden="true">2.18.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0019/problem.html"><strong aria-hidden="true">2.19.</strong> Problem 19: Counting Sundays</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0019/solution1.html"><strong aria-hidden="true">2.19.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0019/solution.html"><strong aria-hidden="true">2.19.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0020/problem.html"><strong aria-hidden="true">2.20.</strong> Problem 20: Factorial digit sum</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0020/solution1.html"><strong aria-hidden="true">2.20.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0020/solution.html"><strong aria-hidden="true">2.20.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0021/problem.html"><strong aria-hidden="true">2.21.</strong> Problem 21: Amicable numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0021/solution1.html"><strong aria-hidden="true">2.21.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0021/solution.html"><strong aria-hidden="true">2.21.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0022/problem.html"><strong aria-hidden="true">2.22.</strong> Problem 22: Names scores</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0022/solution1.html"><strong aria-hidden="true">2.22.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0022/solution.html"><strong aria-hidden="true">2.22.2.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0023/problem.html"><strong aria-hidden="true">2.23.</strong> Problem 23: Non-abundant sums</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0023/solution1.html"><strong aria-hidden="true">2.23.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0023/solution2.html"><strong aria-hidden="true">2.23.2.</strong> Set</a></li><li class="chapter-item "><a href="problems/problem_0023/solution.html"><strong aria-hidden="true">2.23.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0024/problem.html"><strong aria-hidden="true">2.24.</strong> Problem 24: Lexicographic permutations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0024/solution1.html"><strong aria-hidden="true">2.24.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0024/solution2.html"><strong aria-hidden="true">2.24.2.</strong> Maths permutations</a></li><li class="chapter-item "><a href="problems/problem_0024/solution.html"><strong aria-hidden="true">2.24.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0025/problem.html"><strong aria-hidden="true">2.25.</strong> Problem 25: 1000-digit Fibonacci number</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0025/solution1.html"><strong aria-hidden="true">2.25.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0025/solution2.html"><strong aria-hidden="true">2.25.2.</strong> Fibonacci convergence</a></li><li class="chapter-item "><a href="problems/problem_0025/solution.html"><strong aria-hidden="true">2.25.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0026/problem.html"><strong aria-hidden="true">2.26.</strong> Problem 26: Reciprocal cycles</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0026/solution1.html"><strong aria-hidden="true">2.26.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0026/solution2.html"><strong aria-hidden="true">2.26.2.</strong> Carmichael function</a></li><li class="chapter-item "><a href="problems/problem_0026/solution.html"><strong aria-hidden="true">2.26.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0027/problem.html"><strong aria-hidden="true">2.27.</strong> Problem 27: Quadratic primes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0027/solution1.html"><strong aria-hidden="true">2.27.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0027/solution2.html"><strong aria-hidden="true">2.27.2.</strong> Shorten the intervals</a></li><li class="chapter-item "><a href="problems/problem_0027/solution3.html"><strong aria-hidden="true">2.27.3.</strong> Lucky numbers of Euler</a></li><li class="chapter-item "><a href="problems/problem_0027/solution.html"><strong aria-hidden="true">2.27.4.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0028/problem.html"><strong aria-hidden="true">2.28.</strong> Problem 28: Number spiral diagonals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0028/solution1.html"><strong aria-hidden="true">2.28.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0028/solution2.html"><strong aria-hidden="true">2.28.2.</strong> Summation</a></li><li class="chapter-item "><a href="problems/problem_0028/solution.html"><strong aria-hidden="true">2.28.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0029/problem.html"><strong aria-hidden="true">2.29.</strong> Problem 29: Distinct powers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0029/solution1.html"><strong aria-hidden="true">2.29.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0029/solution2.html"><strong aria-hidden="true">2.29.2.</strong> Discarding duplicate</a></li><li class="chapter-item "><a href="problems/problem_0029/solution.html"><strong aria-hidden="true">2.29.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0030/problem.html"><strong aria-hidden="true">2.30.</strong> Problem 30: Digit fifth powers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0030/solution1.html"><strong aria-hidden="true">2.30.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0030/solution2.html"><strong aria-hidden="true">2.30.2.</strong> Search unique combination</a></li><li class="chapter-item "><a href="problems/problem_0030/solution.html"><strong aria-hidden="true">2.30.3.</strong> Solution</a></li></ol></li><li class="chapter-item "><a href="problems/problem_0031/problem.html"><strong aria-hidden="true">2.31.</strong> Problem 31: Coin sums</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="problems/problem_0031/solution1.html"><strong aria-hidden="true">2.31.1.</strong> Brute force</a></li><li class="chapter-item "><a href="problems/problem_0031/solution2.html"><strong aria-hidden="true">2.31.2.</strong> Dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0031/solution3.html"><strong aria-hidden="true">2.31.3.</strong> Better dynamic programming</a></li><li class="chapter-item "><a href="problems/problem_0031/solution.html"><strong aria-hidden="true">2.31.4.</strong> Solution</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="usage/usage.html"><strong aria-hidden="true">3.</strong> Usage</a></li><li class="chapter-item expanded "><a href="contributing/contributing.html"><strong aria-hidden="true">4.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Project Euler</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/TurtleSmoke/Project-Euler" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This document gathers explanations on the solutions of the
<a href="https://projecteuler.net">Euler Project</a> exercises.
Each exercise has its own part, which can be discovered in the table of 
contents.
You can find the source code of every solution as well as the source code of my
<a href="https://rust-lang.github.io/mdBook/">mdBook</a> on my <a href="https://github.com/">Github</a>:
<a href="https://github.com/TurtleSmoke/Project-Euler">TurtleSmoke Project Euler</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-euler"><a class="header" href="#project-euler"><a href="https://projecteuler.net/">Project Euler</a></a></h1>
<h2 id="what-is-project-euler"><a class="header" href="#what-is-project-euler"><strong>What is Project Euler?</strong></a></h2>
<blockquote>
<p>Project Euler is a series of challenging mathematical/computer programming
problems that will require more than just mathematical insights to solve.
Although mathematics will help you arrive at elegant and efficient methods,
the use of a computer and programming skills will be required to solve
most problems.</p>
<p>The motivation for starting Project Euler, and its continuation, is to
provide a platform for the inquiring mind to delve into unfamiliar areas
and learn new concepts in a fun and recreational context.</p>
</blockquote>
<h2 id="who-are-the-problems-aimed-at"><a class="header" href="#who-are-the-problems-aimed-at"><strong>Who are the problems aimed at?</strong></a></h2>
<blockquote>
<p>The intended audience include students for whom the basic curriculum is not
feeding their hunger to learn, adults whose background was not primarily
mathematics but had an interest in things mathematical, and professionals
who want to keep their problem solving and mathematics on the cutting edge.</p>
<p>Currently we have 1036139 registered members who have solved at least one
problem, representing 220 locations throughout the world, and collectively
using 108 different programming langues to solve the problems.</p>
</blockquote>
<h2 id="can-anyone-solve-the-problems"><a class="header" href="#can-anyone-solve-the-problems"><strong>Can anyone solve the problems?</strong></a></h2>
<blockquote>
<p>The problems range in difficulty and for many the experience is inductive
chain learning. That is, by solving one problem it will expose you to a
new concept that allows you to undertake a previously inaccessible problem.
So the determined participant will slowly but surely work his/her way
through every problem.</p>
</blockquote>
<h2 id="what-next"><a class="header" href="#what-next"><strong>What next?</strong></a></h2>
<blockquote>
<p>In order to track your progress it is necessary to setup an account and
have Cookies enabled.</p>
<p>If you already have an account, then
<a href="https://projecteuler.net/sign_in">Sign In</a>. Otherwise, please
<a href="https://projecteuler.net/register">Register</a> – it's completely free!
However, as the problems are challenging, then you may wish to view the
<a href="https://projecteuler.net/archives">Problems</a> before registering.</p>
</blockquote>
<hr />
<p style="text-align: center; font-size: 125%; font-style: italic; color: #bbb">
Project Euler exists to encourage, challenge, and develop the skills 
and enjoyment of anyone with an interest in the fascinating world of mathematics.
</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiples-of-3-and-5"><a class="header" href="#multiples-of-3-and-5"><a href="https://projecteuler.net/problem=1">Multiples of 3 and 5</a></a></h1>
<blockquote>
<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we
get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force"><a class="header" href="#brute-force">Brute force</a></h1>
<p>The first problem is actually quite easy, the naive solution is to iterate over
each number between 0 and 1000 and check those that are multiples of 3 or 5.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=1000):
    return sum(i for i in range(limit) if i % 3 == 0 or i % 5 == 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="three-by-three"><a class="header" href="#three-by-three">Three by three</a></h1>
<p>The <a href="problems/problem_0001/solution1.html">Brute force</a> is actually quite slow, at least it would be if
the limit was greater than 1000. Since only multiples of 3 and 5 are useful,
iterating 3 by 3 and then 5 by 5 will be faster. We have to be careful with the
multiples of 3 and 5 because they will be counted twice. So we have to subtract
them from the result.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=1000):
    sum_3 = sum(i for i in range(0, limit, 3) if i % 3 == 0)
    sum_5 = sum(i for i in range(0, limit, 5) if i % 5 == 0)
    sum_15 = sum(i for i in range(0, limit, 15) if i % 15 == 0)
   
    return sum_3 + sum_5 - sum_15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summing-everything"><a class="header" href="#summing-everything">Summing everything</a></h1>
<p>The <a href="problems/problem_0001/solution2.html">Three by three</a> solution is quite interesting because it
reduces the problem into smaller parts. For example, the sum of multiples of
three is the following:</p>
<p>\[ 3 + 6 + 9 + 12 + 15 + ... \]
\[ 3 * ( 1 + 2 + 3 + 4 + 5 ...) \]
\[ 3 * \sum_{i=0}^{\lfloor\frac{1000}{3}\rfloor} x_i \]</p>
<p>It is the sum of an arithmetic sequences, which is equal to:</p>
<p>\[ \frac{n*(n+1)}{2} \]</p>
<p>The <a href="problems/problem_0001/solution2.html">Three by three</a> solution can be reduced to:</p>
<p>\[ 3 * \frac{\lfloor\frac{999}{3}\rfloor * (\lfloor\frac{999}{3}\rfloor + 1)}{2} +5 * \frac{\lfloor\frac{999}{5}\rfloor * (\lfloor\frac{999}{5}\rfloor + 1)}{2} -15 * \frac{\lfloor\frac{999}{15}\rfloor * (\lfloor\frac{999}{15}\rfloor + 1)}{2} \]</p>
<p>Note that the limit is 999 because 1000 should not be included.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0001/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def sum_of_three_and_five(limit=999):
    limit_3 = limit // 3
    limit_5 = limit // 5
    limit_15 = limit // 15

    sum_3 = 3 * (limit_3 * (limit_3 + 1) // 2)
    sum_5 = 5 * (limit_5 * (limit_5 + 1) // 2)
    sum_15 = 15 * (limit_15 * (limit_15 + 1) // 2)

    return sum_3 + sum_5 - sum_15
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution"><a class="header" href="#solution">Solution</a></h1>
<hr />
<blockquote>
<p>233168</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="even-fibonacci-numbers"><a class="header" href="#even-fibonacci-numbers"><a href="https://projecteuler.net/problem=2">Even Fibonacci numbers</a></a></h1>
<blockquote>
<p>Each new term in the Fibonacci sequence is generated by adding the
previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>
<p align="center"> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... </p>
<p>By considering the terms in the Fibonacci sequence whose values do not
exceed four million, find the sum of the even-valued terms.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-1"><a class="header" href="#brute-force-1">Brute force</a></h1>
<blockquote>
<p>The <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a> form
a sequence, called the Fibonacci
<a href="https://en.wikipedia.org/wiki/Integer_sequence">sequence</a>, such that each
number is the sum of the two preceding ones, starting from 0 and 1.</p>
</blockquote>
<p>The sum of all even numbers in the Fibonacci sequence less than 4 million can be
calculated quite easily by iterating over the sequence until the threshold is
reached by adding each even number to the result.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    f0 = 1
    f1 = 2
    res = 0
    while f0 &lt; limit:
        if f0 % 2 == 0:
            res += f0
        f0, f1 = f1, f0 + f1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-recurrence"><a class="header" href="#fibonacci-recurrence">Fibonacci recurrence</a></h1>
<p>If we take a look at the Fibonacci series:</p>
<blockquote>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...</p>
</blockquote>
<p>Since our only concern is the parity of the numbers, with O being odd and E
even:</p>
<blockquote>
<p>E, O, O, E, O, O, E, O, O, E, O, O, E, O, O, E, ...</p>
</blockquote>
<h4 id="it-seems-that-every-third-number-of-the-series-is-even-lets-try-to-prove-it-properly"><a class="header" href="#it-seems-that-every-third-number-of-the-series-is-even-lets-try-to-prove-it-properly">It seems that every third number of the series is even, let's try to prove it properly.</a></h4>
<p>\[ \begin{gather} If\ n=0\ then\ F_{0}=0\ is\ even\\\\ Assuming\ that\ F_ {3n} \ is\ even.\\ \\ F_{3( n+1)} =F_{3n+2} +F_{3n+1} =( F_{3n+1} +F_{3n}) +F_{3n+1} =2F_{3n+1} +F_ {3n}\\ \\ Since\ F_{3n} \ is\ even\ and\ 2F_{3n+1} \ is\ also\ even,\ we\ have\ F_{3( n+1)} \ even\\ because\ it\ is\ the\ sum\ of\ two\ even\ numbers. \end{gather} \]</p>
<h4 id="this-mean-that-the-series-of-even-fibonacci-number-is"><a class="header" href="#this-mean-that-the-series-of-even-fibonacci-number-is">This mean that the series of even Fibonacci number is:</a></h4>
<p>\[ \begin {gather} E_{n} = F_{3n}\\ E_{n+2} = F_{3n+6} = F_{3n+5} + F_ {3n+4}\\ E_{n+2} = (F_{3n+4} + F_{3n+3}) + (F_{3n+3} + F_{3n+2})\\ E_{n+2} = (F_{3n+3} + F_{3n+2} + F_{3n+3}) + (F_{3n+3} + F_{3n+1} + F_{3n})\\ E_{n+2} = 3F_{3n+3} + (F_{3n+2} + F_{3n+1}) + F_{3n}\\ E_{n+2} = 4F_{3(n+1)} + F_{3n}\\ E_{n+2} = 4E_{n+1} + E_{n}\\ \end{gather} \]</p>
<h4 id="which-result-int-the-following-recurrence-relation"><a class="header" href="#which-result-int-the-following-recurrence-relation">Which result int the following recurrence relation:</a></h4>
<p>\[ E_{n} = 4E_ {n-1} + E_{n-2} \]</p>
<h4 id="we-are-searching-for"><a class="header" href="#we-are-searching-for">We are searching for:</a></h4>
<p>\[ \sum_{k=1}^ {n}E_k \]</p>
<h4 id="this-can-be-simplified-as-follows"><a class="header" href="#this-can-be-simplified-as-follows">This can be simplified as follows:</a></h4>
<p>\[ \begin{align} \sum_{k=1}^{n}E_ {k+1} &amp;= \sum_{k=1}^{n}4E_{k} + \sum_{k=1} ^{n}E_{k-1}\\ \sum_{k=1}^{n}E_{k}&amp;= \frac{1}{4}(\sum_{k=1}^{n}E_{k+1} - \sum_{k=1}^{n}E_{k-1})\\ &amp;= \frac{1}{4}(\sum_{k=2}^{n+1}E_{k} - \sum_{k=0}^{n-1}E_{k})\\ &amp;= \frac{1}{4}(E_{n+1} + E_{n} - E_1 - E_0)\\ &amp;= \frac{1}{4}(E_{n+1} + E_{n} - 2)\\ \end{align} \]</p>
<p>The result can be calculated by iterating until \( E_{n+1} \) is greater than
the limit, so that \( E_n \) is less than the limit, then apply the previous
function.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    e0 = 0
    e1 = 2
    while e1 &lt; limit:
        e0, e1 = e1, 4 * e1 + e0

    return (e1 + e0 - 2) // 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-and-the-golden-ratio"><a class="header" href="#fibonacci-and-the-golden-ratio">Fibonacci and the golden ratio</a></h1>
<p>Although the number of iterations of the second solution is lower than that of
the first solution, it is possible to do better:</p>
<p>\[ \begin{align} \frac{1}{4}(E_{n+1} + E_{n} - 2) &amp;= \frac{1}{4}(F_{3(n+1)} + F_{3n} - 2)\\ &amp;= \frac{1}{4}(F_{3n+2} + F_{3n+1} + F_{3n} - 2)\\ &amp;= \frac{1}{4}(2F_{3n+2} - 2)\\ &amp;= \frac{1}{2}(F_{3n+2} - 1)\\ \end{align} \]</p>
<p>This does not really change the problem, since we still need to iterate until
\( F_{3n} \) reach the limit and then compute \(\frac{1}{2}(F_
{3n+2} - 1)\).</p>
<p>Actually, the Fibonacci numbers can be approximated with the following
<a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression">equation</a>:</p>
<p>\[ F_{n} = \frac{\varphi^{n} - (-\varphi)^{-n}}{\sqrt{5}} \]</p>
<p>where \( \varphi = \frac{1+\sqrt{5}}{2} \) is the
<a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a>.</p>
<p>\( -(-\varphi)^{-n} \) can be ignored for large numbers which gives the
equation:</p>
<p>\[ F_{n} = \frac{\varphi^{n}}{\sqrt{5}} \]</p>
<p>The limit is the n-th Fibonacci number such that:</p>
<p>\[ \begin{align} F_{n} &amp;\leqslant M\\ \frac{\varphi ^{n}}{\sqrt{5}} &amp;\leqslant M\\ \varphi ^{n} &amp;\leqslant \sqrt{5} M\\ n\log( \varphi ) &amp;\leqslant \log\left(\sqrt{5} M\right)\\ n &amp;\leqslant \left\lfloor \frac{\log\left(\sqrt{5} M\right)}{\log( \varphi )} \right\rfloor \end{align} \]</p>
<p>The result can be computed with \(\frac{1}{2}(F_{n+2} - 1) \) where \( n =
\left\lfloor \frac{\log\left(\sqrt{5} M\right)}{\log( \varphi )} \right\rfloor
\):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0002/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def sum_of_even_fibonacci_numbers(limit=4000000):
    golden_ratio = (1 + sqrt(5)) / 2
    n = floor(log(sqrt(5) * limit) / log(golden_ratio))
    fn = round((golden_ratio**(n + 2)) / sqrt(5))

    return (fn - 1) // 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-1"><a class="header" href="#solution-1">Solution</a></h1>
<hr />
<blockquote>
<p>4613732</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-prime-factor"><a class="header" href="#largest-prime-factor"><a href="https://projecteuler.net/problem=3">Largest prime factor</a></a></h1>
<blockquote>
<p>The prime factors of 13195 are 5, 7, 13 and 29.</p>
<p>What is the largest prime factor of the number 600851475143 ?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-2"><a class="header" href="#brute-force-2">Brute force</a></h1>
<p>\( i \) is a factor of \( n \) if \( n\ \equiv\ 0\ [i] \), in our case it
is enough to iterate over each number. When a factor is found, we simply divide
\( n \) by that factor and continue as long as \( n \) is greater than one.
When \( n \) is equal to one, we simply return the current factor which is
also the largest.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0003/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_prime_factor(n=600851475143):
    res = 2
    while n != 1:
        if n % res == 0:
            n //= res
        else:
            res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-by-two"><a class="header" href="#two-by-two">Two by Two</a></h1>
<p>Since all primes except 2 are odd and in our case 2 is not a factor of
600851475143, we can start with 3 and iterate two by two, which is not a great
improvement, but this problem has no interesting solution anyway.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0003/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_prime_factor(n=600851475143):
    res = 3
    while n != 1:
        if n % res == 0:
            n //= res
        else:
            res += 2

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-2"><a class="header" href="#solution-2">Solution</a></h1>
<hr />
<blockquote>
<p>6857</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-palindrome-product"><a class="header" href="#largest-palindrome-product"><a href="https://projecteuler.net/problem=4">Largest palindrome product</a></a></h1>
<blockquote>
<p>A palindromic number reads the same both ways. The largest palindrome made
from the product of two 3-digit numbers is 9009 = 91 × 99.</p>
<p>Find the largest palindrome made from the product of two 3-digit numbers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-3"><a class="header" href="#brute-force-3">Brute force</a></h1>
<p>We are searching the largest palindrome made from the product of two 3-digit
numbers. Firstly, it is necessary to know when a number is a palindrome. This
can be done easily using python iteration.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_palindrome(n):
    return str(n) == str(n)[::-1]
</code></pre>
<p>A better solution exists using modulus and division, but performance is not the
goal here.</p>
<p>The range of 3-digit numbers is \( [100; 999] \), the naive solution will
consist in simply iterate over each number and check which product is the
largest palindrome. A little trick: if \( 100 * 200 \) does not work, \(
200 * 100 \) won't work either, so the second loop starts from the current
number of the first one.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_palindrome_product():
    res = 0
    for x in range(100, 1000):
        for y in range(x, 1000):
            if x * y &gt; res and is_palindrome(x * y):
                res = x * y
                
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorisation-is-the-key"><a class="header" href="#factorisation-is-the-key">Factorisation is the key</a></h1>
<p>We know that the researched number is larger than \( 100*100 = 10000 \)
and smaller than \( 999*999 = 998001 \). So it must be of the form \(
abcba \) or \( abccba \). Let's assume it is of the form \( abccba \), if
it does not work, we'll try with \( abcba \).</p>
<p>\( abccba = 10001a + 10010b + 1100c = 11(9091a + 910b + 100c) \) which means
that the palindrome must be divisible by 11. Since 11 is prime, either \(
100001a \), \( 10010b \) or \( 1100c \) is a multiple of 11, which is why
the iteration can be done 11 by 11.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0004/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_palindrome_product():
    res = 0
    for x in range(110, 1000, 11):
        for y in range(x, 1000):
            if x * y &gt; res and is_palindrome(x * y):
                res = x * y

    return res
</code></pre>
<p>We went from 405450 iterations with the <a href="problems/problem_0004/solution1.html">Brute force</a> to 36450
iterations !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-pen-and-paper"><a class="header" href="#with-pen-and-paper">With pen and paper</a></h1>
<p>In <a href="problems/problem_0004/solution2.html">Factorisation is the key</a>, we assume that the number was of
the form \( abccba \). Since it is the factor of two 3-digit number, we have :</p>
<p>\[ \begin{align} abccba &amp;= (100a + 10b + c)(100d + 10e + f)\\ &amp;= 10000ad + 1000(bd + ae) + 100(cd + be + af) + 10(ce + bf) + cf \end{align} \]</p>
<p>Assuming the first digit is 9, then \( cf \) must be equal to 9 as well.</p>
<p>The only ways to make the last digit nine are:</p>
<p>\[ 1 * 9\\ 3 * 3\\ 7 * 7 \]</p>
<p>Thus, both number must start with 9 and end with either 1, 3, 7 or 9. We also
know that \( 100a + 10b + c \) or \( 100d + 10e + f \) is divisible by 11.
The only numbers divisible by 11 and ending with 1, 3, 7 or 9 in the
\( [900; 999]
\) are :</p>
<p>\[ 913\\ 957\\ 979 \]</p>
<p>This give us:</p>
<p>\[ \text{a = 9}\\ \text{b = 1, 5 or 7}\\ \text{c = 3, 7 or 9}\\ \]</p>
<p>Resulting in the numbers:</p>
<p>\[
(900 + 10 + 3)(900 + 10e + 3) = 824439 + 9130x\\
(900 + 50 + 7)(900 + 10e + 7) = 867999 + 9570x\\
(900 + 70 + 9)(900 + 10e + 1) = 882079 + 9790x \]</p>
<p>The first number implies that \( e \) is equal to 9 because if \( e \) was
equal to 8, then \(824439 * 9130 * 8 = 897479 \) would not start with 9.
With \( e = 9 \) we have \( 913 * 993 \) which is the correct answer. Both
\( (900 + 50 + 7)(900 + 10e + 7) \) and \( (900 + 70 + 9)(900 + 10e + 1) \)
give smaller palindrome.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-3"><a class="header" href="#solution-3">Solution</a></h1>
<hr />
<blockquote>
<p>906609</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="smallest-multiple"><a class="header" href="#smallest-multiple"><a href="https://projecteuler.net/problem=5">Smallest multiple</a></a></h1>
<blockquote>
<p>2520 is the smallest number that can be divided by each of the numbers
from 1 to 10 without any remainder.</p>
<p>What is the smallest positive number that is evenly divisible by all of
the numbers from 1 to 20?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-4"><a class="header" href="#brute-force-4">Brute force</a></h1>
<p>As always, the brute force solution is quite simple, first determine if a number
is evenly divisible by all numbers from 1 to 20.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def is_evenly_divisible(n):
    for i in range(1, 21):
        if n % i != 0:
            return False
        
    return True
</code></pre>
<p>Then iterate until you find a solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def smallest_multiple():
    i = 1
    while not is_evenly_divisible(i):
        i += 1

    return i
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-factorization"><a class="header" href="#prime-factorization">Prime factorization</a></h1>
<p>The <a href="problems/problem_0005/solution2.html">Brute force</a> is actually very slow. A better solution can be
found using prime factorization. The key is to understand that when \( x \)
divides \( y \) evenly, it is because the prime factors of \( x\) are
contained in \( y \). For example, \( 20 = 2^2 * 5 \) which means that a
number divisible by 20 is also divisible by 2, 4 and 5.</p>
<p>Calculating the prime factorization of each number from 1 to 20 give us:</p>
<p>\[\begin{align} 20 &amp;= 2^2 * 5\\ 19 &amp;= 19\\ 18 &amp;= 2 * 3^2\\ 17 &amp;= 17\\ 16 &amp;= 2^4\\ 15 &amp;= 3 * 5\\ 14 &amp;= 2 * 7\\ 13 &amp;= 13\\ 12 &amp;= 2^2 * 3\\ 11 &amp;= 11\\ \end{align} \]</p>
<p>We can stop here, because 10 is included in 20, 9 in 18, 8 in 16, 7 in 14, 6 in
12, 5 in 20, 4 in 20, 3 in 18, 2 in 20 and 1 in 20.</p>
<p>It gives us the answer: \( 2^4 * 3^2 * 5 * 7 * 11 * 13 * 17 * 19 =
232792560 \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="least-common-multiple"><a class="header" href="#least-common-multiple">Least common multiple</a></h1>
<p>Actually, the problem is to find
the <a href="https://en.wikipedia.org/wiki/Least_common_multiple#Reduction_by_the_greatest_common_divisor">least common multiple</a>
which is:</p>
<p>\[ LCT(1, 2, ..., N) \]</p>
<p>To find the \( LCT \) of \( 1 \) through \( N \), we need all the primes
\( \leqslant N \). For each prime, we need its maximum power that won't exceed
\( N \). Which can be done easily using logarithms:</p>
<p>\[ \begin{align} p^{k} &amp;\leqslant N\\ k\log( p) &amp;\leqslant \log( N)\\ k&amp;=\left\lfloor \frac{\log( N)}{\log( p)}\right\rfloor\\ \end{align} \]</p>
<p>So the \( LCT \) of \( 1 \) through \( N \) is:</p>
<p>\[ \prod p^{\left\lfloor \frac{\log(N)}{\log(p)} \right\rfloor } \]</p>
<p>We also know that it's pointless to search the maximum power of primes greater
than \( \sqrt{n} \) because it will always be 1.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0005/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def smallest_multiple(n=20):
    # Returns a list of all primes &lt;= n
    primes = sieve.primerange(n + 1)
    sqrt_n, log_n = sqrt(n), log(n)
    res = 1
    for p in primes:
        if p &lt; sqrt_n:
            res *= p**(floor(log_n / log(p)))
        else:
            res *= p

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-4"><a class="header" href="#solution-4">Solution</a></h1>
<hr />
<blockquote>
<p>232792560</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="sum-square-difference"><a class="header" href="#sum-square-difference"><a href="https://projecteuler.net/problem=6">Sum square difference</a></a></h1>
<blockquote>
<p>The sum of the squares of the first ten natural numbers is,
\[ 1^2 + 2^2 +...+10^2=385 \]
The square of the sum of the first ten natural number is,
\[ (1+2+...10)^2 = 3025 \]
Hence the difference between the sum of the squares of the first ten
natural numbers and the square of the sum is \( 3025 - 385 = 2640 \)</p>
<p>Find the difference between the sum of the squares of the first one 
hundred natural numbers and the square of the sum.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-5"><a class="header" href="#brute-force-5">Brute force</a></h1>
<p>Finding the difference between the sum of the squares and the square of the sum
required two steps:</p>
<p>Find the sum of the squares:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_squares(n):
    return sum(i**2 for i in range(1, n + 1))
</code></pre>
<p>And the square of the sum:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def square_of_sum(n):
    return sum(i for i in range(1, n + 1))**2
</code></pre>
<p>Finally, just subtract the square of the sum by the sum of the squares:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_square_difference(n=100):
    return square_of_sum(n) - sum_of_squares(n)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-formula"><a class="header" href="#summation-formula">Summation formula</a></h1>
<p>We learned in <a href="problems/problem_0006/../problem_0001/problem.html">Problem 1: Multiples of 3 and 5</a>
that:</p>
<p>\[ \sum{k} = \frac{n(n+1)}{2} \]</p>
<p>This gives the following formula for the square of the sum:</p>
<p>\[ (1+2+...+10)^2 = \left(\sum{k}\right)^2 = \left(\frac{n(n+1)}{2}\right)^2 = \frac{n^2 (n+1)^2}{4} \]</p>
<p>The sum of the squares can be found using the formula:</p>
<p>\[ \sum{k^2} = \frac{n(n+1)(2n+1)}{6} \]</p>
<p>There are many demonstrations to prove this equation, let's just look at one of
them:</p>
<p>\[ \begin{align} ( k-1)^{3} &amp;=k^{3} -3k^{2} +3k-1\\ k^{3} -( k-1)^{3} &amp;=3k^{2} -3k+1\\ \sum _{k=1}^{n}\left( k^{3} -( k-1)^{3}\right) &amp;=\sum _{k=1}^{n} 3k^{2} -3k+1 \\ \sum _{k=1}^{n} k^{3} -\sum _{k=1}^{n}( k-1)^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\sum _{k=1}^{n} k+\sum _{k=1}^{n} 1\\ \sum _{k=1}^{n} k^{3} -\sum _{k=0}^{n-1} k^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\frac{n( n+1)}{2} +n\\ n^{3} &amp;=3\sum _{k=1}^{n} k^{2} -3\frac{n( n+1)}{2} +n\\ \sum _{k=1}^{n} k^{2} &amp;=\frac{1}{3} n^{3} +\frac{n( n+1)}{2} -\frac{1}{3} n\\ \sum _{k=1}^{n} k^{2} &amp;=\frac{n( n+1)( 2n+1)}{6} \end{align} \]</p>
<p>The solution can be found in constant time with these two equations:</p>
<p>\[ \frac{n^2(n+1)^2}{4} - \frac{n(n+1)(2n+1)}{6} = \frac{3n^4+2n^3-3n^2-2n}{12} \]</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0006/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def sum_square_difference(n=100):
    return (3 * n**4 + 2 * n**3 - 3 * n**2 - 2 * n) // 12
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-5"><a class="header" href="#solution-5">Solution</a></h1>
<hr />
<blockquote>
<p>25164150</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="10001st-prime"><a class="header" href="#10001st-prime"><a href="https://projecteuler.net/problem=7">10001st prime</a></a></h1>
<blockquote>
<p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>
<p>What is the 10 001st prime number?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-6"><a class="header" href="#brute-force-6">Brute force</a></h1>
<p>A well known and fast way to generate primes is the
<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>.
The only problem is that we need an upper bound, which is not the case here
since we don't know the size of the 10001st prime.</p>
<p>We will have to test the primality of each number, if it is prime, then we store
it, otherwise we continue with the next number until the list of prime numbers
that we stored contains 10001 elements. The last one being the answer.</p>
<p>To determine the primality of a number, we can check if one of the preceding
primes can divide it, if not, the number is prime.</p>
<p>Since even number can not be prime, we can go two by two just like
the <a href="problems/problem_0007/../problem_0003/solution2.html">Two by Two</a> solution
of <a href="problems/problem_0007/../problem_0003/problem.html">Problem 3: Largest prime factor</a>.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    i = 3
    primes = [2]
    while len(primes) &lt; n:
        if all(i % p != 0 for p in primes):  # No divisor in the previous prime.
            primes.append(i)
        i += 2

    return primes[-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="almost-six-by-six"><a class="header" href="#almost-six-by-six">Almost six by six</a></h1>
<p>Actually, it is possible to speed up a little the previous program knowing that
every prime \( n &gt; 3 \) is of the form :</p>
<p>\[ 6k+1 \text{ or } 6k-1 \]</p>
<p>Let's try to persuade ourselves that this is true. All prime numbers are of the
form:</p>
<p>\[ 6k - 1\\ 6k\\ 6k+1\\ 6k+2\\ 6k+3\\ 6k+4\\ \]</p>
<p>Nothing amazing, but as we are looking for prime number, we can remove some of
them :</p>
<p>\( 6k \), \( 6k + 2 \) and \( 6k + 4 \) are even number, so they cannot be
prime.</p>
<p>\( 6k + 3 = 3(3k + 1) \) which is divisible by 3 and thus not prime
(except 3).</p>
<p>Which let us with: \( 6k + 1 \) and \( 6k - 1 \).</p>
<p>Thus, we can rewrite the old program to check only those numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    i = 1
    primes = [2, 3]
    while len(primes) &lt; n:
        if all((6 * i - 1) % p != 0 for p in primes):
            primes.append(6 * i - 1)
        if all((6 * i + 1) % p != 0 for p in primes):
            primes.append(6 * i + 1)
        i += 1

    return primes[n - 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-number-theorem"><a class="header" href="#prime-number-theorem">Prime number theorem</a></h1>
<p>As I said in the <a href="problems/problem_0007/solution1.html">Brute force</a> solution, the fasted way to
generate primes is the sieve of eratosthenes, but it requires an upper bound. We
can not find the exact upper bound, but we can have a good approximation using
the <a href="https://en.wikipedia.org/wiki/Prime_number_theorem">Prime number theorem</a>:</p>
<p>\[  \pi(N) \sim \frac{N}{\log(N)} \]</p>
<p>Where \( \pi(N) \) is the
<a href="https://en.wikipedia.org/wiki/Prime-counting_function">prime-counting function</a>
.</p>
<p>This function give the number of primes \( M \) less than or equal to \( N
\), in our case we want to determine \( N \) knowing \( M \). Which give us
another formula:</p>
<p>\[ \begin{align} \frac{N}{\log(N)} &amp;\leqslant M\\ \frac{\log(N)}{N} &amp;\leqslant \frac{1}{M}\\ -\frac{\log(N)}{N} &amp;\leqslant -\frac{1}{M}\\ -\frac{\log(N)}{e^{\log(N)}} &amp;\leqslant -\frac{1}{M}\\ -\log(N)e^{-\log(N)} &amp;\leqslant -\frac{1}{M} \end{align} \]</p>
<p>The <a href="https://en.wikipedia.org/wiki/Lambert_W_function">Lambert \( W \) function</a>
says that \( we^w = z \Leftrightarrow w = \mathit{W}_{k}(z) \). This give us:</p>
<p>\[ \begin{align} -\log( N) e^{-\log( N)} &amp;\leqslant -\frac{1}{M}\\ -\log( N) &amp;\leqslant W_{k}\left( -\frac{1}{M}\right)\\ N &amp;\leqslant e^{-W_{k}\left( -\frac{1}{M}\right)} \end{align} \]</p>
<p>The solutions of Lambert's \( W \) function with real number can be found with
ony two branches: \( W_0 \) and \( W_{-1} \) suffice.</p>
<p>For real number \( z \) and \( w \) the equation \( we^w = z \) can be
solved for \( w \) only if \( w \geqslant -\frac{1}{e} \). if \( z
\geqslant 0 \) we get \( w = W_0(z) \) and the two values \( w = W_0(z) \)
and \( w = W_{-1}(z) \) if \( -\frac{1}{e} \leqslant w &lt; 0 \).</p>
<p>We have \( w = -\log(N) \) so we are in the second case. We need to determine
which of \(W_0(z) \) and \( W_{-1}(z) \) is the right formula.</p>
<p>The branch 0 converge to 1 when \( z \) converge to 0. Actually, for \( M &gt;
3 \) we have \( \lceil W_k(-\frac{1}{M}) \rceil = 1\). It implies that the
good branch is -1.</p>
<p>We can actually build the sieve of eratosthenes with the upper bound \( e^ {-W_
{-1}(-\frac{1}{M})} \). Lambert's \( W \) function cannot be expressed in
terms of
<a href="https://en.wikipedia.org/wiki/Elementary_function">elementary functions</a>, so
the formula cannot be simplified. The value of Lambert's \( W \) function
requires an iterative method to be found, as this is quite a difficult problem
we will use the
<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.lambertw.html">lambertw</a>
from <a href="https://docs.scipy.org/doc/scipy/index.html">scipy</a> to determine our upper
bound.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0007/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def n_th_prime(n=10001):
    if n &lt; 3:
        return [2, 3][n - 1]

    limit_pi_1 = ceil(exp(-lambertw(-1 / n, -1).real))
    primes = sieve.primerange(limit_pi_1 + 1)

    return next(islice(primes, n - 1, n))
</code></pre>
<p>Note that <code>sieve.primerange</code> returns a <code>generator</code>, so we use slice to get the
n-th element.</p>
<p>When \( N &lt; 3 \), we have \( -\log(N) \geqslant -\frac{1}{e} \) which means
the Lambert's W function has no solution. We can simply hard-code the case of 1
and 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-6"><a class="header" href="#solution-6">Solution</a></h1>
<hr />
<blockquote>
<p>104743</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-series"><a class="header" href="#largest-product-in-a-series"><a href="https://projecteuler.net/problem=8">Largest product in a series</a></a></h1>
<blockquote>
<p>The four adjacent digits in the 1000-digit number that have the greatest
product are 9 × 9 × 8 × 9 = 5832.</p>
<p>\[ \begin{align}\\ 73167176531330624919225119674426574742355349194934\\ 96983520312774506326239578318016984801869478851843\\ 85861560789112949495459501737958331952853208805511\\ 12540698747158523863050715693290963295227443043557\\ 66896648950445244523161731856403098711121722383113\\ 62229893423380308135336276614282806444486645238749\\ 30358907296290491560440772390713810515859307960866\\ 70172427121883998797908792274921901699720888093776\\ 65727333001053367881220235421809751254540594752243\\ 52584907711670556013604839586446706324415722155397\\ 53697817977846174064955149290862569321978468622482\\ 83972241375657056057490261407972968652414535100474\\ 82166370484403199890008895243450658541227588666881\\ 16427171479924442928230863465674813919123162824586\\ 17866458359124566529476545682848912883142607690042\\ 24219022671055626321111109370544217506941658960408\\ 07198403850962455444362981230987879927244284909188\\ 84580156166097919133875499200524063689912560717606\\ 05886116467109405077541002256983155200055935729725\\ 71636269561882670428252483600823257530420752963450\\ \end{align} \]</p>
<p>Find the thirteen adjacent digits in the 1000-digit number that have the
greatest product. What is the value of this product?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-7"><a class="header" href="#brute-force-7">Brute force</a></h1>
<p>We are searching for the largest product of 13 adjacent digits in a 1000-digit
number. We want to calculate the product of each 13 adjacent digits and find the
largest one.</p>
<p>The 1000-digit number will be stored in a file, so the first step is to get this
number as a string and remove each trailing newline (\n):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, 'r') as file:
        return file.read().replace('\n', '')
</code></pre>
<p>Given this string, we need to calculate the product of 13 adjacent digits, which
can be done easily
using <a href="https://docs.python.org/3/library/math.html#math.prod">math.prod()</a>.
Then, simply repeat this step for all 13 adjacent digits contained in the
1000-digit number and save the maximum of these products.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_product_in_series(n, adj=13):
    res = 0
    for i in range(len(n) - adj):
        res = max(prod(int(digit) for digit in n[i: i + adj]), res)

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0-are-useless"><a class="header" href="#0-are-useless">0 are useless</a></h1>
<p>The problem requires calculating a product, a product of something and 0 will
always give a result of 0. Which means that every 13 adjacent digits containing
0 are useless since the result will never be the largest product.</p>
<p>The 1000-digit number can actually be split around each 0, of course if a number
has less than 13 digits it can be deleted.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def split_series(n):
    return [sub_n for sub_n in n.split(&quot;0&quot;) if len(sub_n) &gt;= 13]
</code></pre>
<p>Another improvement reside in not calculating every product from the start, for
example if we search the product of 3 adjacent digits in 12345, the 3 solutions
are:</p>
<pre><code class="language-python">1*2*3     = 6
  2*3*4   = (6 / 1) * 4 = 24
    3*4*5 = (24 / 3) * 5 = 60
</code></pre>
<p>The second product is the same as the first, just divide the digit that is not
present and multiply the one that is. We have to be careful with the digit 0
because division by 0 is an error, but we have already solved the problem just
before, so we can assume our number will never contain the digit 0.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_product_in_series(n, adj=13):
    res = 0
    current = prod(int(digit) for digit in n[0: adj])
    for i in range(len(n) - adj):
        current = (current // int(n[i])) * int(n[i + adj])
        res = max(res, current)

    return res
</code></pre>
<p>We simply repeat this step for each sub-number of the 1000-digit split around 0.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0008/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def largest_product_in_multiples_series(sub_n, adj=13):
    res = 0
    for n in sub_n:
        res = max(largest_product_in_series(n, adj), res)
    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-7"><a class="header" href="#solution-7">Solution</a></h1>
<hr />
<blockquote>
<p>23514624000</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-pythagorean-triplet"><a class="header" href="#special-pythagorean-triplet"><a href="https://projecteuler.net/problem=9">Special Pythagorean triplet</a></a></h1>
<blockquote>
<p>A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,
\[ a^2 + b ^2 = c^2 \]
For example, \( 3^2 + 4^2 = 9 + 16 = 25 = 5^2. \)</p>
<p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.<br />
Find the product abc.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-8"><a class="header" href="#brute-force-8">Brute force</a></h1>
<p>We are searching for \( a \), \( b \) and \( c \) such that \( a &lt; b
&lt; c \), \( a + b + c = 1000 \) and \( a^2 + b^2 = c^2 \). The brute force
solution will simply iterate to 1000 for \( a \), \( b \)
and \( c \) and stop when the above equations are true.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for a in range(1001):
        for b in range(a + 1, 1001):
            for c in range(b + 1, 1001):
                if a + b + c == 1000 and a**2 + b**2 == c**2:
                    return a * b * c
               
    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="with-a-little-thought"><a class="header" href="#with-a-little-thought">With a little thought</a></h1>
<p>The <a href="problems/problem_0009/solution1.html">Brute force solution</a> can be simplified a bit knowing that
\( a + b + c = 1000 \) implies \( c = 1000 - a - b \). This removes a for
loop and an equation, since \( a + b + c = 1000 \) will always be true.</p>
<p>Another simplification can be made by knowing that \( a &lt; b &lt; c \). This
implies that \( a \), \( b \) and \( c \) are lower than 500, otherwise
\( a + b + c \) will be greater than 1000.</p>
<p>This gives us the following :</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for a in range(501):
        for b in range(a + 1, 501):
            c = 1000 - a - b
            if a**2 + b**2 == c**2:
                return a * b * c

    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prime-pythagorean-triples"><a class="header" href="#prime-pythagorean-triples">Prime Pythagorean triples</a></h1>
<p>Given an arbitrary pair of integers m and n with m &gt; n &gt; 0. Euclid's formula
states that the integers :</p>
<p>\[ a = m^2 - n^2,\ b=2mn,\ c=m^2+n^2 \]</p>
<p>form a Pythagorean triple: \( a^2 + b^2 = c^2 \)</p>
<p>If we calculate \( a^2 + b ^2 \):</p>
<p>\[ a^2 + b^2 = (m^2-n^2)^2 + (2mn)^2 = m^2 + 4m^2n^2 - 2m^2n^2 + n^2 = (m^2 + n^2)^2 = c^2 \]</p>
<p>Which is coherent, the problem changes from finding \( a \), \( b \) and \(
c \) to finding \( m \) and \( n \), we have:</p>
<p>\[ \begin{align} a+b+c &amp;= 1000\\ 2mn + 2m^2 &amp;= 1000\\ n &amp;= \frac{500}{m} - m\\ \end{align} \]</p>
<p>We have \( m &gt; n \) since b must be positive, solving \( n = m \) gives:</p>
<p>\[ \begin{align} m &amp;= \frac{500}{m} - m\\ 0 &amp;= \frac{500 - 2m^2}{m}\\ 0 &amp;= 500 - 2m^2\\ m &amp;= \sqrt(250)\\ \end{align} \]</p>
<p>Resulting in:</p>
<p>\[ m &gt; 16 &gt; \sqrt(250) \]</p>
<p>We also have \( n &gt; 0 \), solving \( n = 0 \) gives:</p>
<p>\[ \begin{align} 0 &amp;= \frac{500}{m} - m\\ 0 &amp;= 500 - m^2\\ m &amp;= \sqrt(500)\\ \end{align} \]</p>
<p>Resulting in:</p>
<p>\[ m &lt; \sqrt(500) &lt; 23 \]</p>
<p>We also know that \( \frac{500}{m} \) is an integer, so m must divide \(
500 \). The only multiple of that divides \( 500 \) with the constraint \(
16 &gt; m &gt; 23 \) is 20. Having \( m = 20 \) result in \( n = 5 \). It gives
\( a = 200 \), \( b = 375 \) and \( c \) = 425.</p>
<p>The solution can also be found by using a for loop to find \( m \) and \(
n \) with the above constraints.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0009/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def special_pythagorean_triplet():
    for m in range(16, 24):
        for n in range(1, m):
            if m * (n + m) == 500:
                return 2 * m * n * (m**4 - n**4)

    return -1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-8"><a class="header" href="#solution-8">Solution</a></h1>
<hr />
<blockquote>
<p>31875000</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-of-primes"><a class="header" href="#summation-of-primes"><a href="https://projecteuler.net/problem=10">Summation of primes</a></a></h1>
<blockquote>
<p>The sum of the primes below \( 10 \) is \( 2 + 3 + 5 + 7 = 17 \).</p>
<p>Find the sum of all the primes below two million.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-9"><a class="header" href="#brute-force-9">Brute force</a></h1>
<p>We already know, thanks to te previous problems that when one search for all
prime numbers below a certain limit, the sieve of eratosthenes is a good
solution.</p>
<p>It is enough to sum the list of the primes found with the sieve.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def summation_of_primes(limit=2000000):
    return sum(sieve.primerange(limit))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation-minus-summation"><a class="header" href="#summation-minus-summation">Summation minus summation</a></h1>
<p>The sieve of eratosthenes is actually quite slow, it's possible to find a better
solution if we consider that we don't need to know all the primes to find their
sum. For example, the sum of the primes less than \( 10 \) is \( 2 + 3 + 5 +
7 = 17 \).</p>
<p>The sum of the primes less than \( 10 \) is the sum of the numbers less than
10 minus the sum of the multiples of the primes less than \( \sqrt{10} \)
plus the primes themselves minus \( 1 \). In this example, the sum of the
multiples of \( 2 \) and \( 3 \):</p>
<p>\[ \begin{alignat}{1} P &amp;&amp;= &amp;&amp;+1&amp;&amp;+2&amp;&amp;+3&amp;&amp;+4&amp;&amp;+5&amp;&amp;+6+7&amp;&amp;+8&amp;&amp;+9&amp;&amp;+10\\ &amp;&amp;&amp;&amp;&amp;&amp;-2&amp;&amp;&amp;&amp;-4&amp;&amp;&amp;&amp;-6&amp;&amp;-8&amp;&amp;&amp;&amp;-10\\ &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;-3&amp;&amp;&amp;&amp;&amp;&amp;-6&amp;&amp;&amp;&amp;-9\\ &amp;&amp;&amp;&amp;-1&amp;&amp;+2&amp;&amp;+3\\ P &amp;&amp;= &amp;&amp;&amp;&amp;+2&amp;&amp;+3&amp;&amp;&amp;&amp;+5&amp;&amp;-6+7\\ \end{alignat} \]</p>
<p>There is just one problem, the number \( 6 \) is both a multiple of \( 2 \)
and \( 3 \). This means we have to remove the multiple of \( 3 \) but not
the multiple of \( 6 \). For numbers larger than 10, if we continue with \( 5
\) we have to remove the multiple of \( 5 \) but not the multiple of \(
2*5=10 \), \( 3*5=15 \) and \( 5*6=30 \).</p>
<p>Let \( \phi(n) \) be the sum of the numbers less than \( n \).</p>
<p>We have the following sequence:</p>
<p>\[ \begin{align} T_0(n) &amp;= \phi(\left\lfloor n \right\rfloor) &amp;&amp;= 1+2+3+\dots\\ T_1(n) &amp;= 2\left(T_0\left(\frac{n}{2}\right)\right) = 2\phi\left (\left\lfloor \frac{n} {2} \right\rfloor \right) &amp;&amp;= 2+4+6+\dots\\ T_2(n) &amp;= 3\left(T_0\left(\frac{n}{3}\right) - T_1\left(\frac{n}{3}\right) \right) = 3\phi \left(\left\lfloor \frac{n}{3} \right\rfloor\right) - 6\phi\left(\left\lfloor \frac{n}{6} \right\rfloor\right) &amp;&amp;= 3+9+15+\dots\\ T_3(n) &amp;= 5\left(T_0\left(\frac{n}{5}\right) - T_1\left(\frac{n}{5}\right) - T_2\left(\frac{n}{5}\right) \right) = 5\phi\left(\left\lfloor\frac{n}{5}\right\rfloor\right) - 10\phi\left(\left\lfloor\frac{n}{10}\right\rfloor\right) - 15\phi\left(\left\lfloor\frac{n}{15} \right\rfloor\right) + 30\phi\left(\left\lfloor\frac{n}{30} \right\rfloor\right) &amp;&amp;= 5+25+35+\dots\\ \end{align} \]</p>
<p>So the k-th term is:</p>
<p>\[ T_k(n) = p_k\left(T_0\left(\frac{n}{p_k}\right) - \dots - T_{k-1}\left (\frac{n} {p_k}\right)\right) \]</p>
<p>Where \( p_k \) is the k-th prime.</p>
<p>We can create a function to find \( T_k \) if we have \( p_k \):</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def tk(n, k):
    pk = primes[k - 1]
    t0 = phi(floor(n / pk))
    tn = sum([tk(n / pk, i) for i in range(1, k)])
    return pk * (t0 - tn)
</code></pre>
<p>The sum of the primes less than \( n \) is the sum of the numbers less than
\( n \) minus the sum of all the multiples of the primes less than \( \sqrt
{n} \) plus the primes themselves minus \( 1 \):</p>
<p>\[ \left(T_0(n) - T_1(n) - \dots - T_k(n)\right) + \left(p_1 + p_2 + \dots + p_k\right) - 1 \]</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def summation_of_primes(limit=2000000):
    phi = lambda x: x * (x + 1) // 2
    primes = list(sieve.primerange(floor(sqrt(limit)) + 1))

    def tk(n, k):
        pk = primes[k - 1]
        t0 = phi(floor(n / pk))
        tn = sum([tk(n / pk, i) for i in range(1, k)])
        return pk * (t0 - tn)

    return phi(limit) - sum([tk(limit, i + 1) for i in range(len(primes))]) \
           + sum(primes) - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0010/solution2.html">Summation minus summation</a> solution gives an interesting
solution because we found the sum of the primes less than \( n \) with only
the primes less than \( \sqrt{n} \). Unfortunately, this solution is not
efficient because it requires too much recursion for larger n.</p>
<p>The main problem with the previous solution was to remove the numbers that were
multiples of previous primes. For example with the multiples of \( 3 \), the
number \( 6 \) was already removed by the multiples of \( 2 \).</p>
<p>What we really want is to remove the multiples of \( 3 \) that have not
already been removed by the multiples of \( 2 \) such as \( 6 \), \( 12 \)
... For \( 5 \) that would be the number that are neither multiples of \( 2
\) nor \( 3 \).</p>
<p>Instead of the sum of the multiples of a prime, we will search for the sum of
integer that remain after sieving with all primes smaller than the current one.</p>
<p>This solution is well explained by <strong>Lucy_Hedgehog</strong> in this
<a href="https://projecteuler.net/thread=10;page=5#111677">thread</a> (only available if
you solve the problem):</p>
<blockquote>
<p>The main idea is as follows: Let \( S(v,m) \) be the sum of integers in the
range \( 2 \dots v \) that remain after sieving with all primes smaller or
equal than \( m \). That is \( S(v,m) \) is the sum of integers up to
\( v \) that are either prime or the product of primes larger than \( m
\).</p>
<p>\( S(v, p) \) is equal to \(S(v, p-1) \) if \( p \) is not prime or
\( v \) is smaller than \( p*p \). Otherwise (\( p \) prime, \(
p*p\leqslant v \)) \( S(v,p) \) can be computed from \(S(v, p-1)\)
by finding the sum of integers that are removed while sieving with \( p
\). An integer is removed in this step if it is the product of \(p \)
with another integer that has no divisor smaller than \(p \). This can
be expressed as</p>
<p>\[ S\left(v, p \right) = S\left(v, p - 1\right) - p\left(S\left(\frac{v}{p},
p - 1\right) -S\left(p-1, p-1\right)\right) \]</p>
<p>Dynamic programming can be used to implement this. It is sufficient to
compute \( S(v,p) \) for all positive integers \( v \) that are
representable as \( \left\lfloor\frac{n}{k}\right\rfloor \) for some
integer \( k \) and all.</p>
</blockquote>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0010/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def partial_prime_sum(n=2000000):
    r = ceil(sqrt(n))
    V = [n // i for i in range(1, r + 1)]
    V += list(range(V[-1] - 1, 0, -1))
    S = {i: i * (i + 1) // 2 - 1 for i in V}
    for p in range(2, r + 1):
        if S[p] &gt; S[p - 1]:  # p is prime
            sp = S[p - 1]  # sum of primes smaller than p
            p2 = p * p
            for v in V:
                if v &lt; p2: break
                S[v] -= p * (S[v // p] - sp)
    return S[n]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-9"><a class="header" href="#solution-9">Solution</a></h1>
<hr />
<blockquote>
<p>142913828922</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="largest-product-in-a-grid"><a class="header" href="#largest-product-in-a-grid"><a href="https://projecteuler.net/problem=11">Largest product in a grid</a></a></h1>
<blockquote>
<p>In the 20×20 grid below, four numbers along a diagonal line have been 
marked in red.</p>
<p>\[ 08\ 02\ 22\ 97\ 38\ 15\ 00\ 40\ 00\ 75\ 04\ 05\ 07\ 78\ 52\ 12\ 50\ 77\ 91\ 08\\ 49\ 49\ 99\ 40\ 17\ 81\ 18\ 57\ 60\ 87\ 17\ 40\ 98\ 43\ 69\ 48\ 04\ 56\ 62\ 00\\ 81\ 49\ 31\ 73\ 55\ 79\ 14\ 29\ 93\ 71\ 40\ 67\ 53\ 88\ 30\ 03\ 49\ 13\ 36\ 65\\ 52\ 70\ 95\ 23\ 04\ 60\ 11\ 42\ 69\ 24\ 68\ 56\ 01\ 32\ 56\ 71\ 37\ 02\ 36\ 91\\ 22\ 31\ 16\ 71\ 51\ 67\ 63\ 89\ 41\ 92\ 36\ 54\ 22\ 40\ 40\ 28\ 66\ 33\ 13\ 80\\ 24\ 47\ 32\ 60\ 99\ 03\ 45\ 02\ 44\ 75\ 33\ 53\ 78\ 36\ 84\ 20\ 35\ 17\ 12\ 50\\ 32\ 98\ 81\ 28\ 64\ 23\ 67\ 10\ \color{red}{26}\ 38\ 40\ 67\ 59\ 54\ 70\ 66\ 18\ 38\ 64\ 70\\ 67\ 26\ 20\ 68\ 02\ 62\ 12\ 20\ 95\ \color{red}{63}\ 94\ 39\ 63\ 08\ 40\ 91\ 66\ 49\ 94\ 21\\ 24\ 55\ 58\ 05\ 66\ 73\ 99\ 26\ 97\ 17\ \color{red}{78}\ 78\ 96\ 83\ 14\ 88\ 34\ 89\ 63\ 72\\ 21\ 36\ 23\ 09\ 75\ 00\ 76\ 44\ 20\ 45\ 35\ \color{red}{14}\ 00\ 61\ 33\ 97\ 34\ 31\ 33\ 95\\ 78\ 17\ 53\ 28\ 22\ 75\ 31\ 67\ 15\ 94\ 03\ 80\ 04\ 62\ 16\ 14\ 09\ 53\ 56\ 92\\ 16\ 39\ 05\ 42\ 96\ 35\ 31\ 47\ 55\ 58\ 88\ 24\ 00\ 17\ 54\ 24\ 36\ 29\ 85\ 57\\ 86\ 56\ 00\ 48\ 35\ 71\ 89\ 07\ 05\ 44\ 44\ 37\ 44\ 60\ 21\ 58\ 51\ 54\ 17\ 58\\ 19\ 80\ 81\ 68\ 05\ 94\ 47\ 69\ 28\ 73\ 92\ 13\ 86\ 52\ 17\ 77\ 04\ 89\ 55\ 40\\ 04\ 52\ 08\ 83\ 97\ 35\ 99\ 16\ 07\ 97\ 57\ 32\ 16\ 26\ 26\ 79\ 33\ 27\ 98\ 66\\ 88\ 36\ 68\ 87\ 57\ 62\ 20\ 72\ 03\ 46\ 33\ 67\ 46\ 55\ 12\ 32\ 63\ 93\ 53\ 69\\ 04\ 42\ 16\ 73\ 38\ 25\ 39\ 11\ 24\ 94\ 72\ 18\ 08\ 46\ 29\ 32\ 40\ 62\ 76\ 36\\ 20\ 69\ 36\ 41\ 72\ 30\ 23\ 88\ 34\ 62\ 99\ 69\ 82\ 67\ 59\ 85\ 74\ 04\ 36\ 16\\ 20\ 73\ 35\ 29\ 78\ 31\ 90\ 01\ 74\ 31\ 49\ 71\ 48\ 86\ 81\ 16\ 23\ 57\ 05\ 54\\ 01\ 70\ 54\ 71\ 83\ 51\ 54\ 69\ 16\ 92\ 33\ 48\ 61\ 43\ 52\ 01\ 89\ 19\ 67\ 48\\ \]</p>
<p>The product of these numbers is \( 26 × 63 × 78 × 14 = 1788696 \).</p>
<p>What is the greatest product of four adjacent numbers in the same
direction (up, down, left, right, or diagonally) in the \( 20 \times 20 \)
grid?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-10"><a class="header" href="#brute-force-10">Brute force</a></h1>
<p>This problem is not interesting, the solution is simply to iterate on each 
row, column and on the two diagonal.</p>
<p>As with <a href="problems/problem_0011/../problem_0008/problem.html">Largest product in a series</a>, the 
input grid will be stored in a file, so the first step is to obtain this
grid as int matrix.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0011/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, 'r') as file:
        return [[int(x) for x in line.split(' ')] for line in
                file.read().split('\n')[:-1]]  # Last element is an empty line
</code></pre>
<p>And then just iterate on this matrix:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0011/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def largest_product_in_grid(filename):
    g = read_file(filename)

    for y in range(0, 20):
        for x in range(0, 17):
            yield g[x][y] * g[x + 1][y] * g[x + 2][y] * g[x + 3][y]
    for x in range(0, 20):
        for y in range(0, 17):
            yield g[x][y] * g[x][y + 1] * g[x][y + 2] * g[x][y + 3]
    for y in range(0, 17):
        for x in range(0, 17):
            yield g[x][y] * g[x + 1][y + 1] * g[x + 2][y + 2] * g[x + 3][y + 3]
    for x in range(3, 20):
        for y in range(0, 17):
            yield g[x][y] * g[x - 1][y + 1] * g[x - 2][y + 2] * g[x - 3][y + 3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-10"><a class="header" href="#solution-10">Solution</a></h1>
<hr />
<blockquote>
<p>70600674</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="highly-divisible-triangular-number"><a class="header" href="#highly-divisible-triangular-number"><a href="https://projecteuler.net/problem=12">Highly divisible triangular number</a></a></h1>
<blockquote>
<p>The sequence of triangle numbers is generated by adding the natural
numbers. So the 7th triangle number would be \(1 + 2 + 3 + 4 + 5 + 6 + 7
= 28 \). The first ten terms would be:</p>
<p>\[ 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, \dots \]</p>
<p>Let us list the factors of the first seven triangle numbers:</p>
<p>\[
\begin{align}
1&amp;: 1\\
3&amp;: 1,3\\
6&amp;: 1,2,3,6\\
10&amp;: 1,2,5,10\\
15&amp;: 1,3,5,15\\
21&amp;: 1,3,7,21\\
28&amp;: 1,2,4,7,14,28\\
\end{align}
\]</p>
<p>We can see that 28 is the first triangle number to have over five divisors.</p>
<p>What is the value of the first triangle number to have over five hundred divisors?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-11"><a class="header" href="#brute-force-11">Brute force</a></h1>
<p>Finding the number of factors of \( n \) can be done by iterating from 1 to
\( n \) and checking each number that can divide \( n \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def number_of_factors(n):
    res = 1
    for i in range(2, n):
        if n % i == 0:
            res += 1
    return res
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Triangular_number">Triangular number</a> can be
computed quite easily with a loop, we can generate them as long as their number
of divisor is less than \( 500 \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def highly_div_triangular_number(n=500):
    i = 1
    res = 1
    while number_of_factors(res) &lt; n:
        i += 1
        res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-factor"><a class="header" href="#common-factor">Common factor</a></h1>
<p>The <a href="problems/problem_0012/solution1.html">Brute Force</a> solution is really slow, way to slow to be
honest.</p>
<p>First, we can improve the way we find the number of factors. If \( i \)
divides \( n \), then obviously \( \frac{n}{i} \) divides \( n \) too. We
do not need to iterate from 2 to \( n \) but only to \( \sqrt{n} \) and add
the factors two by two. The only exception is that if \( \sqrt{n} \) divides
\( n \) we only need to count it once.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def number_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root):
        if n % i == 0:
            res += 1
    return 2 * res + (root**2 == n)
</code></pre>
<p>This makes the solution much faster, but there is still room for improvement in
the way the triangular numbers are calculated. We already know from the previous
problems that the sum of integer from \( 1 \) to \( n \) is \(\frac{n(n+1)
}{2} \). Since \( n \) and \( n + 1 \) have no factors in common except \(
1 \), we can multiply the number of factor in \( \frac{n}{2} \) and \( n + 1
\) or \( n \) and \( \frac{n+1}{2} \) depending on the parity of \( n \).
This allows us to calculate the number of factors of smaller numbers, which
makes the solution quite fast compared to the <a href="problems/problem_0012/solution1.html">Brute force</a>
solution.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0012/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def highly_div_triangular_number(n=500):
    i = 0
    factors = 0
    while factors &lt; n:
        i += 1
        if i % 2 == 0:
            factors = number_of_factors(i // 2) * number_of_factors(i + 1)
        else:
            factors = number_of_factors(i) * number_of_factors((i + 1) // 2)

    return i * (i + 1) // 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-11"><a class="header" href="#solution-11">Solution</a></h1>
<hr />
<blockquote>
<p>76576500</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="large-sum"><a class="header" href="#large-sum"><a href="https://projecteuler.net/problem=13">Large sum</a></a></h1>
<blockquote>
<p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.</p>
<p>\[ 37107287533902102798797998220837590246510135740250\\ 46376937677490009712648124896970078050417018260538\\ 74324986199524741059474233309513058123726617309629\\ 91942213363574161572522430563301811072406154908250\\ 23067588207539346171171980310421047513778063246676\\ 89261670696623633820136378418383684178734361726757\\ 28112879812849979408065481931592621691275889832738\\ 44274228917432520321923589422876796487670272189318\\ 47451445736001306439091167216856844588711603153276\\ 70386486105843025439939619828917593665686757934951\\ 62176457141856560629502157223196586755079324193331\\ 64906352462741904929101432445813822663347944758178\\ 92575867718337217661963751590579239728245598838407\\ 58203565325359399008402633568948830189458628227828\\ 80181199384826282014278194139940567587151170094390\\ 35398664372827112653829987240784473053190104293586\\ 86515506006295864861532075273371959191420517255829\\ 71693888707715466499115593487603532921714970056938\\ 54370070576826684624621495650076471787294438377604\\ 53282654108756828443191190634694037855217779295145\\ 36123272525000296071075082563815656710885258350721\\ 45876576172410976447339110607218265236877223636045\\ 17423706905851860660448207621209813287860733969412\\ 81142660418086830619328460811191061556940512689692\\ 51934325451728388641918047049293215058642563049483\\ 62467221648435076201727918039944693004732956340691\\ 15732444386908125794514089057706229429197107928209\\ 55037687525678773091862540744969844508330393682126\\ 18336384825330154686196124348767681297534375946515\\ 80386287592878490201521685554828717201219257766954\\ 78182833757993103614740356856449095527097864797581\\ 16726320100436897842553539920931837441497806860984\\ 48403098129077791799088218795327364475675590848030\\ 87086987551392711854517078544161852424320693150332\\ 59959406895756536782107074926966537676326235447210\\ 69793950679652694742597709739166693763042633987085\\ 41052684708299085211399427365734116182760315001271\\ 65378607361501080857009149939512557028198746004375\\ 35829035317434717326932123578154982629742552737307\\ 94953759765105305946966067683156574377167401875275\\ 88902802571733229619176668713819931811048770190271\\ 25267680276078003013678680992525463401061632866526\\ 36270218540497705585629946580636237993140746255962\\ 24074486908231174977792365466257246923322810917141\\ 91430288197103288597806669760892938638285025333403\\ 34413065578016127815921815005561868836468420090470\\ 23053081172816430487623791969842487255036638784583\\ 11487696932154902810424020138335124462181441773470\\ 63783299490636259666498587618221225225512486764533\\ 67720186971698544312419572409913959008952310058822\\ 95548255300263520781532296796249481641953868218774\\ 76085327132285723110424803456124867697064507995236\\ 37774242535411291684276865538926205024910326572967\\ 23701913275725675285653248258265463092207058596522\\ 29798860272258331913126375147341994889534765745501\\ 18495701454879288984856827726077713721403798879715\\ 38298203783031473527721580348144513491373226651381\\ 34829543829199918180278916522431027392251122869539\\ 40957953066405232632538044100059654939159879593635\\ 29746152185502371307642255121183693803580388584903\\ 41698116222072977186158236678424689157993532961922\\ 62467957194401269043877107275048102390895523597457\\ 23189706772547915061505504953922979530901129967519\\ 86188088225875314529584099251203829009407770775672\\ 11306739708304724483816533873502340845647058077308\\ 82959174767140363198008187129011875491310547126581\\ 97623331044818386269515456334926366572897563400500\\ 42846280183517070527831839425882145521227251250327\\ 55121603546981200581762165212827652751691296897789\\ 32238195734329339946437501907836945765883352399886\\ 75506164965184775180738168837861091527357929701337\\ 62177842752192623401942399639168044983993173312731\\ 32924185707147349566916674687634660915035914677504\\ 99518671430235219628894890102423325116913619626622\\ 73267460800591547471830798392868535206946944540724\\ 76841822524674417161514036427982273348055556214818\\ 97142617910342598647204516893989422179826088076852\\ 87783646182799346313767754307809363333018982642090\\ 10848802521674670883215120185883543223812876952786\\ 71329612474782464538636993009049310363619763878039\\ 62184073572399794223406235393808339651327408011116\\ 66627891981488087797941876876144230030984490851411\\ 60661826293682836764744779239180335110989069790714\\ 85786944089552990653640447425576083659976645795096\\ 66024396409905389607120198219976047599490197230297\\ 64913982680032973156037120041377903785566085089252\\ 16730939319872750275468906903707539413042652315011\\ 94809377245048795150954100921645863754710598436791\\ 78639167021187492431995700641917969777599028300699\\ 15368713711936614952811305876380278410754449733078\\ 40789923115535562561142322423255033685442488917353\\ 44889911501440648020369068063960672322193204149535\\ 41503128880339536053299340368006977710650566631954\\ 81234880673210146739058568557934581403627822703280\\ 82616570773948327592232845941706525094512325230608\\ 22918802058777319719839450180888072429661980811197\\ 77158542502016545090413245809786882778948721859617\\ 72107838435069186155435662884062257473692284509516\\ 20849603980134001723930671666823555245252804609722\\ 53503534226472524250874054075591789781264330331690\\ \]</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-12"><a class="header" href="#brute-force-12">Brute force</a></h1>
<p>The main problem is to find a way to add large numbers, because computers can
not store large numbers so easily. That's the point of the problem, to find a
way to add those numbers. We could use an array to store each digit of each
number and add them, but thanks to python and
the <a href="https://www.python.org/dev/peps/pep-0237/">unifying long integers and integers</a>
we can just add these numbers without worrying about memory.</p>
<p>We just need to get the first 10 digits of the additions, which can be done
quite easily by converting the number to a string ang get the first 10
characters.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0013/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def large_sum(filename):
    return str(sum(read_file(filename)))[:10]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-12"><a class="header" href="#solution-12">Solution</a></h1>
<hr />
<blockquote>
<p>5537376230</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-collatz-sequence"><a class="header" href="#longest-collatz-sequence"><a href="https://projecteuler.net/problem=14">Longest Collatz sequence</a></a></h1>
<blockquote>
<p>The following iterative sequence is defined for the set of positive integers:
\[ \begin{align} &amp; n\ \rightarrow \ \frac{n}{2} \ ( n\ is\ even)\\ &amp; n\ \rightarrow \ 3n+1\ ( n\ is\ odd) \end{align}\]</p>
<p>Using the rule above and starting with 13, we generate the following sequence:</p>
<p>\[ 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1 \]
It can be seen that this sequence (starting at 13 and finishing at 1)
contains 10 terms. Although it has not been proved yet (Collatz Problem),
it is thought that all starting numbers finish at 1.</p>
<p>Which starting number, under one million, produces the longest chain?</p>
<p>NOTE: Once the chain starts the terms are allowed to go above one million.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-13"><a class="header" href="#brute-force-13">Brute force</a></h1>
<p>Calculating the number of iterations of the Collatz sequence is easy, just
follow the sequence until it reaches one, and count the number of iterations
to get there:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0014/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def collatz(n):
    iteration = 0
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        iteration += 1

    return iteration
</code></pre>
<p>Then, just check the iteration for each starting number from 1 to 1000000 and
return the largest.</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0014/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def longest_collatz_sequence(n=1000000):
    res, max_it = 0, 0
    for i in range(1, n):
        current_it = collatz(i)
        if current_it &gt; max_it:
            res, max_it = i, current_it

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="caching"><a class="header" href="#caching">Caching</a></h1>
<p>The Collatz sequence of starting numbers \( 4 \) and \( 8 \) are actually
quite similar :
\[
\begin{align} &amp;Collatz(4) = 4 \rightarrow 2 \rightarrow 1\\ &amp;Collatz(8) = 8 \rightarrow 4 \rightarrow 2 \rightarrow 1\\ \end{align} \]</p>
<p>By calculating \( Collatz(8) \) we ended up recalculating \( Collatz(4)
\), if we keep in memory the number of iterations of \( Collatz(4) \), we
could reuse it to find the number of iterations of \( Collatz(8) \).</p>
<p>That is what <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a> is,
storing data so that future requests for that data can be served faster.</p>
<p>In our case, when calculating the number of iteration of \( n \), we first
look if the value has already been computed, if not, we update the cache 
using the formula.</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0014/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def longest_collatz_sequence(n=1000000):
    cache = {1: 1}

    def collatz(i):
        if i not in cache:
            cache[i] = collatz(i // 2 if i % 2 == 0 else 3 * i + 1) + 1

        return cache[i]

    return max(range(1, n), key=collatz)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-13"><a class="header" href="#solution-13">Solution</a></h1>
<hr />
<blockquote>
<p>837799</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lattice-paths"><a class="header" href="#lattice-paths"><a href="https://projecteuler.net/problem=15">Lattice paths</a></a></h1>
<blockquote>
<p>Starting in the top left corner of a 2×2 grid, and only being able to move 
to the right and down, there are exactly 6 routes to the bottom right corner.</p>
<p align="center"> <img src="problems/problem_0015/../../images/p0015/p0015.png" /> </p>
<p>How many such routes are there through a 20×20 grid?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-14"><a class="header" href="#brute-force-14">Brute force</a></h1>
<p>We are searching for the number of different paths starting from the top left
corner and going to the bottom right corner of a \( 20 \times 20 \)
square. The only possible moves are down and right. This is the same as
searching for the <a href="https://en.wikipedia.org/wiki/Lattice_path">Lattice path</a>.</p>
<p>Since the square is \( 20 \times 20 \) we have 20 moves down and 20 moves to
the right. If we move to the right, then we have 20 moves down and 19 moves to
the right, we can continue as long as we have moves available.</p>
<p>The solution can be done recursively, starting with 20 moves down and right, the
result being the combination of paths down and to the right. Each times we move
down we call the function recursively with the same number of moves to the
right, but one less move down. When the number of move down is 1, the result is
obviously 1: the only remaining path is the one to the right. The same can be
done for the move to the right.</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0015/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def lattice_paths(up=20, down=20):
    moves_down = lattice_paths(up, down - 1) if down &gt; 1 else 1
    moves_up = lattice_paths(up - 1, down) if up &gt; 1 else 1

    return moves_up + moves_down
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-1"><a class="header" href="#dynamic-programming-1">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0015/solution1.html">Brute force</a> solution is not efficient at all, for example,
if we go down and then right or right and then down, we end up in the same
place. The <a href="problems/problem_0015/solution1.html">Brute force</a> solution will compute the answer twice.</p>
<p>We could use a cache, but let's do this solution iteratively rather than 
recursively.</p>
<p>We can represent the solution using a matrix, for example, for a \( 3 \times 3
\) square, we have the number of paths from the green point to the red point
for each sub parallelogram.</p>
<p align="center"> <img src="problems/problem_0015/../../images/p0015/p0015-s2-grid.png" style="width: 40%"> </p>
<p>Looking at the \( 2 \times 2 \) sub square, we can see that the number of
different paths is indeed 6.</p>
<p>For each red point, the number of different paths to it is the sum of the path
above and paths on the left.</p>
<p>For the first row and column, the number of different paths is one: either only
downs or only rights. Then, we can simply compute the path to the other red
points using the old ones, we simply return the value at the last cell.</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0015/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def lattice_paths(n=20):
    n += 1
    paths = np.zeros((n, n), dtype=int)

    for i in range(1, n):
        paths[i, 0] = 1
        paths[0, i] = 1

    for i in range(1, n):
        for j in range(1, n):
            paths[i, j] = paths[i - 1, j] + paths[i, j - 1]

    return paths[n - 1, n - 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combination"><a class="header" href="#combination">Combination</a></h1>
<p>For a square of dimension \( n \), we know that whatever path we take, there
will be exactly \( n \) movements to the right and \( n \) movements down.
We can represent the path as a string of 'D' for down and 'R' for right.</p>
<p>For example, with a \( 3 \times 3 \) square, a path could be : 'RRRDDD',
'DDDRRR' or 'RDDRDR'. The question now is, 'In how many ways can we place the '
R' and the 'D' in the string ?'</p>
<p>Since there must be as many 'D' as 'R', we can only place the 'R' and leave the
rest as 'D'. That means we are searching for the number of ways we can place \(
n \) 'R' in a string of \( 2n \) characters. This is called
a <a href="https://en.wikipedia.org/wiki/Combination">combination</a>, in our case, it's:</p>
<p>\[ \begin{pmatrix} 2n\\ n \end{pmatrix} = \frac{\left(2n\right)!}{n!\left(2n - n\right)!} = \frac{\left (2n\right)!}{\left(n!\right)^2} \]</p>
<p>This can be calculated using factorial:</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0015/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def lattice_paths(n=20):
    return factorial(2 * n) // (factorial(n)**2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-14"><a class="header" href="#solution-14">Solution</a></h1>
<hr />
<blockquote>
<p>137846528820</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="power-digit-sum"><a class="header" href="#power-digit-sum"><a href="https://projecteuler.net/problem=16">Power digit sum</a></a></h1>
<blockquote>
<p>\( 2^{15} = 32768 \) and the sum of its digits is \( 3 + 2 + 7 + 6 + 8 = 
26.\)</p>
<p>What is the sum of the digits of the number \( 2^{1000} \)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-15"><a class="header" href="#brute-force-15">Brute force</a></h1>
<p>Thanks to python, the solution is trivial, we just need to sum the digits of a
number, which can be done by casting it into a string and iterating on it.</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0016/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def power_digit_sum(n=1000):
    return sum((int(d) for d in str(2**n)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-15"><a class="header" href="#solution-15">Solution</a></h1>
<hr />
<blockquote>
<p>1366</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-letter-counts"><a class="header" href="#number-letter-counts"><a href="https://projecteuler.net/problem=17">Number letter counts</a></a></h1>
<blockquote>
<p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are \( 3 + 3 + 5 + 4 + 4 = 19 \) letters used in total.</p>
<p>If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?</p>
<p>NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of &quot;and&quot; when writing out numbers is in compliance with British usage</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-16"><a class="header" href="#brute-force-16">Brute force</a></h1>
<p>This problem is boring, there is nothing interesting to do, we can only count
some word several times. For example, the word &quot;hundred&quot; is used 900 times from
100 to 999, this allows some factoring. We can do the same for the number from 1
to 9, for &quot;and&quot;, for 10, 20, 30, ...</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_00017/solution17.py">solution17.py</a>:</p>
<pre><code class="language-python">def number_letter_counts():
    unit = len(&quot;onetwothreefourfivesixseveneightnine&quot;)
    ten = len(&quot;teneleventwelvethirfourfifsixseveneighnine&quot;) + len(&quot;ten&quot;) * 7
    and_l = len(&quot;and&quot;)
    twenty = len(&quot;twentythirtyfortyfiftysixtyseventyeightyninety&quot;)
    hun = len(&quot;hundred&quot;)
    thou = len(&quot;onethousand&quot;)
    return thou + 900 * hun + 190 * unit + 100 * twenty + 891 * and_l + 10 * ten
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-16"><a class="header" href="#solution-16">Solution</a></h1>
<hr />
<blockquote>
<p>21124</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-path-sum-i"><a class="header" href="#maximum-path-sum-i"><a href="https://projecteuler.net/problem=18">Maximum path sum I</a></a></h1>
<blockquote>
<p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.</p>
<p>\[
\begin{gather}
\color{red}{3}\\
\color{red}{7}\quad 4\\
2 \quad \color{red}{4}\quad 6\\
8\quad 5\quad \color{red}{9}\quad 3\\
\end{gather}
\]</p>
<p>That is, 3 + 7 + 4 + 9 = 23.</p>
<p>Find the maximum total from top to bottom of the triangle below:</p>
<p>\[
\begin{gather}
75\\
95\quad 64\\
17\quad 47\quad 82\\
18\quad 35\quad 87\quad 10\\
20\quad 04\quad 82\quad 47\quad 65\\
19\quad 01\quad 23\quad 75\quad 03\quad 34\\
88\quad 02\quad 77\quad 73\quad 07\quad 63\quad 67\\
99\quad 65\quad 04\quad 28\quad 06\quad 16\quad 70\quad 92\\
41\quad 41\quad 26\quad 56\quad 83\quad 40\quad 80\quad 70\quad 33\\
41\quad 48\quad 72\quad 33\quad 47\quad 32\quad 37\quad 16\quad 94\quad 29\\
53\quad 71\quad 44\quad 65\quad 25\quad 43\quad 91\quad 52\quad 97\quad 51\quad 14\\
70\quad 11\quad 33\quad 28\quad 77\quad 73\quad 17\quad 78\quad 39\quad 68\quad 17\quad 57\\
91\quad 71\quad 52\quad 38\quad 17\quad 14\quad 91\quad 43\quad 58\quad 50\quad 27\quad 29\quad 48\\
63\quad 66\quad 04\quad 68\quad 89\quad 53\quad 67\quad 30\quad 73\quad 16\quad 69\quad 87\quad 40\quad 31\\
04\quad 62\quad 98\quad 27\quad 23\quad 09\quad 70\quad 98\quad 73\quad 93\quad 38\quad 53\quad 60\quad 04\quad  23\\
\end{gather}<br />
\]</p>
<p>NOTE: As there are only 16384 routes, it is possible to solve this problem
by trying every route. However, Problem 67, is the same challenge with a
triangle containing one-hundred rows; it cannot be solved by brute force,
and requires a clever method! ;o)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-17"><a class="header" href="#brute-force-17">Brute force</a></h1>
<p>Even if the problem tells us not to use brute force, we will still do it. Not
because we want to do things easily, but because it will be much easier to find
a better solution later after solving the problem the first time.</p>
<p>First, we need to transform the triangle into something easier to manipulate,
for example a two-dimensional array.</p>
<p>The problem can be solved quite easily after that, with a simple recursion: The
maximum score is the current number plus the highest score by choosing the left
or the right.</p>
<p>It is enough to stop when we are outside the triangle, since the lower number is
0, we can consider that leaving the triangle is like adding 0.</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0018/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def maximum_path_sum_I(filename):
    triangle = read_file(filename)

    def path(i, j):
        if i &gt;= len(triangle) or j &gt;= len(triangle[i]):
            return 0

        return triangle[i][j] + max(path(i + 1, j), path(i + 1, j + 1))

    return path(0, 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-2"><a class="header" href="#dynamic-programming-2">Dynamic programming</a></h1>
<p>The <a href="problems/problem_0018/solution1.html">Brute force</a> solution has some issue, for example with the
following triangle:</p>
<p>\[ \begin{gather} 01\\ 02\quad 03\\ 04\quad \color{red}{05}\quad 06\\ 07\quad \color{green}{08}\quad \color{green}{09}\quad 10\\ \end{gather} \]</p>
<p>The path \( 1 \rightarrow 2 \rightarrow 5 \) and the path \( 1 \rightarrow 3
\rightarrow 5 \) both end on 5 and then try to find the best solution between 8
and 9. Obviously, the best choice is 9, because it is the largest number between
8 and 9 and there is no path left to take. It doesn't depend on where we come
from, which means that we can replace the number 5 with \( 5 + 9 = 14 \). We
can do the same with 4 and 6, which then gives the following triangle:</p>
<p>\[ \begin{gather} 01\\ 02\quad 03\\ \color{red}{12}\quad \color{red}{14}\quad \color{red}{16}\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>And we can go all the way to the end by reducing the last line each time:</p>
<p>\[ \begin{gather} 01\\ \color{red}{16}\quad \color{red}{19}\\ 12\quad 14\quad 16\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>And finally:</p>
<p>\[ \begin{gather} \color{red}{20}\\ 16\quad 19\\ 12\quad 14\quad 16\\ 07\quad 08\quad 09\quad 10\\ \end{gather} \]</p>
<p>This solution is much faster because it doesn't recalculate anything twice, it
just chooses the best path from the end, since we don't need to know where we
came from to find the best incoming path.</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0018/solution2.py">solution1.py</a>:</p>
<pre><code class="language-python">def maximum_path_sum_I(filename):
    triangle = read_file(filename)

    for i in range(len(triangle) - 2, -1, -1):
        for j in range(len(triangle[i])):
            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])

    return triangle[0][0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-17"><a class="header" href="#solution-17">Solution</a></h1>
<hr />
<blockquote>
<p>1074</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="counting-sundays"><a class="header" href="#counting-sundays"><a href="https://projecteuler.net/problem=19">Counting Sundays</a></a></h1>
<blockquote>
<p>You are given the following information, but you may prefer to do some research for yourself.</p>
<ul>
<li>1 Jan 1900 was a Monday.</li>
<li>Thirty days has September,<br />
April, June and November.<br />
All the rest have thirty-one,<br />
Saving February alone,<br />
Which has twenty-eight, rain or shine.<br />
And on leap years, twenty-nine.</li>
<li>A leap year occurs on any year evenly divisible by 4, but not on a 
century unless it is divisible by 400.</li>
</ul>
<p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-18"><a class="header" href="#brute-force-18">Brute force</a></h1>
<p>This problem is not fascinating, we could start from the first of January 1901
as a Tuesday, and iterate on each month, for example the first day of February
1901 is Tuesday + \( 31\ \%\ 7 \), which is Friday. We could continue by
taking leap year into account. But thanks to Python, we can solve this problem
with a simpler solution:</p>
<p>From <a href="https://github.com/turtlesmoke/project-euler/blob/main/problems/problem_0019/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def counting_sundays():
    res = 0
    for year in range(1901, 2001):
        for month in range(1, 13):
            if datetime.datetime(year, month, 1).weekday() == 6:
                res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-18"><a class="header" href="#solution-18">Solution</a></h1>
<hr />
<blockquote>
<p>171 </p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="factorial-digit-sum"><a class="header" href="#factorial-digit-sum"><a href="https://projecteuler.net/problem=20">Factorial digit sum</a></a></h1>
<blockquote>
<p>\( n! \) means \( n \times (n − 1) \times ... \times 3 \times 2 \times 
1 \)</p>
<p>For example, \( 10! = 10 \times 9 \times ... \times 3 \times 2 \times 1 = 
3628800 \),
and the sum of the digits in the number \( 10! \) is \( 3 + 6 + 2 + 8 + 8 </p>
<ul>
<li>0 + 0 = 27 \).</li>
</ul>
<p>Find the sum of the digits in the number \( 100! \)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-19"><a class="header" href="#brute-force-19">Brute force</a></h1>
<p>As always, problems involving large numbers are easy to solve in Python, just
compute the number and iterate on it as a string:</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0020/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def factorial_digit_sum(n=100):
    return sum(int(x) for x in str(factorial(n)))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-19"><a class="header" href="#solution-19">Solution</a></h1>
<hr />
<blockquote>
<p>648</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="amicable-numbers"><a class="header" href="#amicable-numbers"><a href="https://projecteuler.net/problem=21">Amicable numbers</a></a></h1>
<blockquote>
<p>Let \( d(n) \) be defined as the sum of proper divisors of \( n \)
(numbers less than \( n \) which divide evenly into \( n \)). If \( d
(a) = b \) and \( d(b) = a \), where \( a \neq b \), then \( a \)
and \( b \) are an amicable pair and each of \( a \) and \( b \) are
called amicable numbers.</p>
<p>For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44,
55 and 110; therefore \( d(220) = 284 \). The proper divisors of 284 are
1, 2, 4, 71 and 142; so \( d(284) = 220 \).</p>
<p>Evaluate the sum of all the amicable numbers under 10000.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-20"><a class="header" href="#brute-force-20">Brute force</a></h1>
<p>The problem first requires to find the sum of proper divisors of a number, if
recall, in the
<a href="problems/problem_0021/../problem_0012/problem.html">Problem 12: Highly divisible triangular number</a>, we
found the number of proper divisors, we can reuse this function by adding the
divisors rather than counting them.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0021/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root + 1):
        if n % i == 0:
            res += i + n // i

    return res
</code></pre>
<p>We can simply iterate from 1 to 10000 and sum the amicable numbers found to find
the solution, we just to be aware that even if \( d(6) = 6 \) and so \( d(6)
= 6 \), 6 is not an amicable number because amicable numbers are in pairs.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0021/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def amicable_numbers(n=10000):
    res = 0
    for i in range(2, n):
        current = sum_of_factors(i)
        if i != current and i == sum_of_factors(current):
            res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-20"><a class="header" href="#solution-20">Solution</a></h1>
<hr />
<blockquote>
<p>31626</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="names-scores"><a class="header" href="#names-scores"><a href="https://projecteuler.net/problem=22">Names scores</a></a></h1>
<blockquote>
<p>Using <a href="https://projecteuler.net/project/resources/p022_names.txt">names.txt</a>
(right click and 'Save Link/Target As...'), a 46K text file
containing over five-thousand first names, begin by sorting it into
alphabetical order. Then working out the alphabetical value for each name,
multiply this value by its alphabetical position in the list to obtain a
name score.</p>
<p>For example, when the list is sorted into alphabetical order, COLIN, which
is worth \( 3 + 15 + 12 + 9 + 14 = 53 \), is the 938th name in the list. So,
COLIN would obtain a score of \( 938 \times 53 = 49714 \).</p>
<p>What is the total of all the name scores in the file?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-21"><a class="header" href="#brute-force-21">Brute force</a></h1>
<p>We first get the huge list of names in python, we just need to remove the <code>&quot;&quot;</code>
around them.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0022/read_file.py">read_file.py</a>:</p>
<pre><code class="language-python">def read_file(filename):
    with open(filename, 'r') as file:
        return [name[1:-1] for name in file.read().split(&quot;,&quot;)]
</code></pre>
<p>Then we just need to sum the letters of the names by their position in the
alphabet. Since all the names are capitalized, we can remove <code>ord('A') + 1</code> to
get their position in the alphabet. The last step is to sum the position of the
names in the list by its value.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0022/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def names_scores(filename):
    names = read_file(filename).sort()
    return sum((i + 1) * sum(ord(c) - ord('A') + 1 for c in name)
               for (i, name) in enumerate(names))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-21"><a class="header" href="#solution-21">Solution</a></h1>
<hr />
<blockquote>
<p>871198282</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-abundant-sums"><a class="header" href="#non-abundant-sums"><a href="https://projecteuler.net/problem=23">Non-abundant sums</a></a></h1>
<blockquote>
<p>A perfect number is a number for which the sum of its proper divisors is 
exactly equal to the number. For example, the sum of the proper divisors 
of 28 would be \( 1 + 2 + 4 + 7 + 14 = 28 \), which means that 28 is a 
perfect number.</p>
<p>A number n is called deficient if the sum of its proper divisors is less 
than \( n \) and it is called abundant if this sum exceeds \(n \).</p>
<p>As 12 is the smallest abundant number, \( 1 + 2 + 3 + 4 + 6 = 16 \), the 
smallest number that can be written as the sum of two abundant numbers is 24.
By mathematical analysis, it can be shown that all integers greater than 
28123 can be written as the sum of two abundant numbers. However, this 
upper limit cannot be reduced any further by analysis even though it is 
known that the greatest number that cannot be expressed as the sum of two 
abundant numbers is less than this limit.</p>
<p>Find the sum of all the positive integers which cannot be written as the 
sum of two abundant numbers.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-22"><a class="header" href="#brute-force-22">Brute force</a></h1>
<p>We are searching for all numbers that are <strong>not</strong> the sum of two abundant
numbers. Since every integer larger than 28123 can be written as the sum of two
abundant numbers, our upper limit is therefore 28123.</p>
<p>First, we need to find all the abundant number below 28123, going higher is
pointless because we are searching for positive numbers only. An abundant number
is a number that have a larger sum of divisors than itself. We already have a
function to compute the sum of divisors, we just need to be aware that if \(
\sqrt{n} \) divide \( n \), it onyl has to count once.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def sum_of_factors(n):
    res = 1
    root = floor(sqrt(n))
    for i in range(2, root + 1):
        if n % i == 0:
            res += i + n // i

    if root**2 == n:
        res -= root

    return res
</code></pre>
<p>We just need to check if a number is the sum of two of the abundant numbers
calculated earlier. The naive way to do this is to try every combination of two
abundant numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">is_sum = lambda i: any(a1 + a2 == i for a1 in abundants for a2 in abundants)
</code></pre>
<p>Finally, we just have to sum each number less than 28124 that is not the sum 
of two abundant numbers.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def non_abundant_sums():
    abundants = [i for i in range(1, 28124) if sum_of_factors(i) &gt; i]
    is_sum = lambda i: any(a1 + a2 == 2 for a1 in abundants for a2 in abundants)

    return sum(i for i in range(28124) if not is_sum(i))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set"><a class="header" href="#set">Set</a></h1>
<p>The <a href="problems/problem_0023/solution1.html">Brute Force</a> solution is extremely slow, the biggest issue is
how we determine if a number is the sum of two abundant numbers.</p>
<p>We are searching for any abundant numbers \( a_1 \) and \( a_2 \) such that
\( a_1 + a_2 = n \), which implies that \(a_2 = n - a_2 \). If \( n - a_2
\) is an abundant number, then \( n \) is the sum of two abundant numbers.</p>
<p>Finding a value in a list is slow because we need to go through the whole list,
that's why using a <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">set</a>
to store our abundant is more efficient in our this case. We just need to
iterate over all abundant once and check if \( n \) minus this abundant is
also in the set.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">any((i - a1 in abundants) for a1 in abundants)
</code></pre>
<p>We can also improve the way we build this set of abundant numbers. Since we have
an upper bound, we can construct the sum of divisors of all these numbers at
once. For every \( i \) and \( j \) such that \( i \times j &lt; limit \),
the number \( i \times j \) has both \( i \) and \( j \) as divisors. We
just need to be aware that if \( i = j \) we need to add the divisor only
once.</p>
<p>We start with a list of 1 because 1 divides all numbers. Then we iterate with
\( i \) from 2 to \( \left\lfloor\sqrt{limit}\right\rfloor \) and \( j \)
from \( i + 1 \) (to avoid the case where \( i = j \)) to \( i \times j &gt;
limit \Leftrightarrow j &gt; \left\lfloor \frac{limit}{i} \right\rfloor \).</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">sum_of_factors = [1] * (n + 1)
for i in range(2, floor(sqrt(n)) + 1):
    sum_of_factors[i * i] += i
    for j in range(i + 1, (n // i) + 1):
        sum_of_factors[i * j] += i + j
</code></pre>
<p>In the previous solution, we first built the list of abundant numbers and then
searched for the number that was not a sum of two of them, since we always have
\( a_1 &lt;= a_2 \) we can actually do both at the same time.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0023/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def non_abundant_sums(n=28123):
    sum_of_factors = [1] * (n + 1)
    for i in range(2, floor(sqrt(n)) + 1):
        sum_of_factors[i * i] += i
        for j in range(i + 1, (n // i) + 1):
            sum_of_factors[i * j] += i + j

    abundants = set()
    res = 0

    for i in range(1, n + 1):
        if sum_of_factors[i] &gt; i:
            abundants.add(i)
        if not any((i - a1 in abundants) for a1 in abundants):
            res += i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-22"><a class="header" href="#solution-22">Solution</a></h1>
<hr />
<blockquote>
<p>4179871</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexicographic-permutations"><a class="header" href="#lexicographic-permutations"><a href="https://projecteuler.net/problem=24">Lexicographic permutations</a></a></h1>
<blockquote>
<p>A permutation is an ordered arrangement of objects. For example, 3124 is 
one possible permutation of the digits 1, 2, 3 and 4. If all of the 
permutations are listed numerically or alphabetically, we call it 
lexicographic order. The lexicographic permutations of 0, 1 and 2 are:</p>
<p align="center"> 012   021   102   120   201   210 </p>
<p>What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4,
5, 6, 7, 8 and 9?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-23"><a class="header" href="#brute-force-23">Brute force</a></h1>
<p>First of all, we need to understand how the lexicographic permutations are
computed. If we enumerate all the permutations of '0123' starting with '0':</p>
<p>\[ 0123\\ 0132\\ 0213\\ 0231\\ 0312\\ 0321\\ \]</p>
<p>By removing the '0' we get:</p>
<p>\[ 123\\ 132\\ 213\\ 231\\ 312\\ 321\\ \]</p>
<p>It's the lexicographic permutations of '123' !</p>
<p>We can continue:</p>
<p>\[\begin{align} &amp;123\ &amp;&amp;213\ &amp;&amp;321\\ &amp;132\ &amp;&amp;231\ &amp;&amp;321 \end{align} \]</p>
<p>By removing the first character each time, it gives:</p>
<p>\[\begin{align} &amp;23\ &amp;&amp;13\ &amp;&amp;21\\ &amp;32\ &amp;&amp;31\ &amp;&amp;21 \end{align} \]</p>
<p>That is, the lexicographic permutations of '23', '13', and '21',</p>
<p>Now, enumerating all permutations of '0123' starting with '1':</p>
<p>\[ 1023\\ 1032\\ 1203\\ 1230\\ 1302\\ 1230 \]</p>
<p>By removing the '1' we get:</p>
<p>\[ 023\\ 032\\ 203\\ 230\\ 302\\ 230 \]</p>
<p>It's the lexicographic permutations of '023' !</p>
<p>This means that we can compute all the lexicographic permutations of a string by
taking each character, placing it at the beginning of the new permutations and
then adding the lexicographic permutations of the rest of the string
recursively.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0024/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def lexicographic_permutations(s):
    if len(s) &lt;= 1:
        yield s
    else:
        for i in range(len(s)):
            for p in lexicographic_permutations(s[:i] + s[i + 1:]):
                yield s[i] + p
</code></pre>
<p>By using <code>yield</code>, we create a generator, it's better than storing 1 million
elements and then returning the last one, just take the 1000000th element
generated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maths-permutations"><a class="header" href="#maths-permutations">Maths permutations</a></h1>
<p>If you have understood how lexicographic permutation are constructed, you should
have noticed that permutations are made from right to left. Before updating the
number on the left, all permutations on the right must have been made. That is
why with the string '0123', the first 6 permutations begin with '0', then the 6
following permutations with '1', and so on.</p>
<p>The string in our examples contains 4 characters, it implies that every \( ( 4
- 1 )! \) permutations the first digit will change. We can even tell which
one will be placed first by knowing the multipliers of that factorial. If it is
the \( 3 * 3! \)th permutations, the first digit will be the third one in the
string, '3' in this example.</p>
<p>Since this process is recursive, we can find the first digit each time by
reducing the n-th permutations we are looking for.</p>
<p>For example, if we researched the 15th lexicographic permutations, we know that
the first character will be '2' because the \( 3! \) first permutations will
start with '0', the next \( 3! \) with '1'.</p>
<p>The 12th lexicographic permutations is obviously '2013'. It's just '0123', but
the '2' is place at the first position. Now that we have our first digit, we can
remove those 12 permutations from the 15th, which gives us 3 permutations.</p>
<p>Now, we are searching for the third lexicographic permutations of '013', with
the same reasoning, we can find that the first digit will be '1' after \( 1 *
2! \) permutations. It leaves use with 1 permutation and the string '03'.</p>
<p>After \( 1 * 1! \) permutations the first digit will be '3'. It leaves us with
'0' which is the last digit. The 15 lexicographic permutations is '2130' !</p>
<p>We just have to find the quotient and remainder of our nth permutations, the
divisor being the length of the string minus one. We can continue as long as our
string contains more than one character.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0024/solution2.py">solution1.py</a>:</p>
<pre><code class="language-python">def lexicographic_permutations(s, n):
    if len(s) &lt;= 1:
        return s
    q, r = divmod(n, factorial(len(s) - 1))
    return s[q] + lexicographic_permutations(s[:q] + s[q + 1:], r)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-23"><a class="header" href="#solution-23">Solution</a></h1>
<hr />
<blockquote>
<p>2783915460</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="1000-digit-fibonacci-number"><a class="header" href="#1000-digit-fibonacci-number"><a href="https://projecteuler.net/problem=25">1000-digit Fibonacci number</a></a></h1>
<blockquote>
<p>The Fibonacci sequence is defined by the recurrence relation:</p>
<p>\[ F_n = F_{n−1} + F_{n−2}\text{ , where } F_1 = 1\text{ and } F_2 = 1. \]
Hence the first 12 terms will be:</p>
<p>\[
\begin{align}
&amp;F_{1} = 1\\
&amp;F_{2} = 1\\
&amp;F_{3} = 2\\
&amp;F_{4} = 3\\
&amp;F_{5} = 5\\
&amp;F_{6} = 8\\
&amp;F_{7} = 13\\
&amp;F_{8} = 21\\
&amp;F_{9} = 34\\
&amp;F_{10} = 55\\
&amp;F_{11} = 89\\
&amp;F_{12} = 144\\
\end{align}
\]</p>
<p>The 12th term, \( F_{12} \), is the first term to contain three digits.</p>
<p>What is the index of the first term in the Fibonacci sequence to contain 1000 digits?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-24"><a class="header" href="#brute-force-24">Brute force</a></h1>
<p>The brute force solution is simple, just iterate until the number of digits 
is at least 1000. We can count the number of digits in a number by turning 
it into a string and counting its length.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0025/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def thousandth_digit_fibonacci_number(n=1000):
    f1 = 1
    f2 = 1
    res = 1
    while len(str(f1)) &lt; n:
        f1, f2 = f2, f1 + f2
        res += 1

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fibonacci-convergence"><a class="header" href="#fibonacci-convergence">Fibonacci convergence</a></h1>
<p>We know from <a href="problems/problem_0025/../problem_0002/solution3.html">Fibonacci and the golden ratio</a>
that the n-th term of Fibonacci can be expressed as :</p>
<p>\[ F_{n} = \frac{\varphi^{n}}{\sqrt{5}} = \frac{\left(\frac{1+\sqrt{5}}{2}
\right)^n}{\sqrt{5}} \]</p>
<p>Searching for a number with at least 1000 digit is the same as searching a
for number that is greater than or equal to \( 10^{999} \)</p>
<p>\[ \begin{align} \frac{\varphi^{n}}{\sqrt{5}} &amp; &gt;= 10^{999}\\
n * \log(\varphi) - \frac{\log(5)}{2} &amp; &gt;= 999 * log(10)\\
n &amp; &gt;= \frac{\frac{\log(5)}{2} + 999}{\log(\varphi)}\\ 
n &amp; = \left\lceil\frac{\frac{\log(5)}{2} + 999}{\log(\varphi)} \right\rceil\\ \end{align} \]</p>
<p>Since n must be an integer, it is sufficient to take the ceiling from the
previous equation.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0025/solution2.py">solution1.py</a>:</p>
<pre><code class="language-python">def thousandth_digit_fibonacci_number(n=1000):
    return ceil((n - 1 + log10(sqrt(5)) / 2) / log10((1 + sqrt(5)) / 2))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-24"><a class="header" href="#solution-24">Solution</a></h1>
<hr />
<blockquote>
<p>4782</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="reciprocal-cycles"><a class="header" href="#reciprocal-cycles"><a href="https://projecteuler.net/problem=26">Reciprocal cycles</a></a></h1>
<blockquote>
<p>A unit fraction contains 1 in the numerator. The decimal representation of
the unit fractions with denominators 2 to 10 are given:</p>
<p>\[
\begin{align}\\
\frac{1}{2} &amp;= 0.5\\
\frac{1}{3} &amp;= 0.(3)\\
\frac{1}{4} &amp;= 0.25\\
\frac{1}{5} &amp;= 0.2\\
\frac{1}{6} &amp;= 0.1(6)\\
\frac{1}{7} &amp;= 0.(142857)\\
\frac{1}{8} &amp;= 0.125\\
\frac{1}{9} &amp;= 0.(1)\\
\frac{1}{10} &amp;= 0.1\\
\end{align}\\
\]
Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can
be seen that \( \frac{1}{7} \) has a 6-digit recurring cycle.</p>
<p>Find the value of \( d &lt; 1000 \) for which \( \frac{1}{d} \) contains the
longest recurring cycle in its decimal fraction part.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-25"><a class="header" href="#brute-force-25">Brute force</a></h1>
<p>How do you find the decimals of a fraction?</p>
<p>In elementary school, we learned a method to convert fractions to decimals.
Repeat the process of multiplying the numerator by 10:</p>
<ul>
<li>The next numerator is the rest of the Euclidean division by the denominator.</li>
<li>The quotient is the next decimal.</li>
</ul>
<p>For example with \( \frac{1}{7} \):</p>
<p>\[ \begin{align} \frac{1}{7} &amp;= 7 * \mathbf{0} + 1\\ \frac{10}{7} &amp;= 7 * \mathbf{1} + 3\\ \frac{30}{7} &amp;= 7 * \mathbf{4} + 2\\ \frac{20}{7} &amp;= 7 * \mathbf{2} + 6\\ \frac{60}{7} &amp;= 7 * \mathbf{8} + 4\\ \frac{40}{7} &amp;= 7 * \mathbf{5} + 5\\ \frac{50}{7} &amp;= 7 * \mathbf{7} + 1\\ \frac{10}{7} &amp;= \dots\\ \end {align} \]</p>
<p>That give us \( \frac{1}{7} = 0,142857... \).</p>
<p>We just have to pay attention to some special cases:</p>
<ul>
<li>When the rest is 0, the division is finite and there is no cycle. We can
assume that the length of the cycle is 0.</li>
<li>The length of the cycle is not the number of time we repeat the process of
finding the decimals of a fraction. For example with \( \frac{1}{6} = 0,
166... \) the cycle is 1. But there is some leading number before it.</li>
</ul>
<p>Detecting the cycle is possible using a set. But we will have no way of knowing
when it started, which is required to find its length. We need to store both the
numbers and their positions for every decimal. When a duplicate is found, it is
enough to calculate the length between the old and the newly found duplicate.
Rather than a set, using a dictionary whose key is the rest and value its
position in the decimal form of the fraction will solve both problem.</p>
<pre><code class="language-python">def find_cycle(n):
    rest = 1
    seen = {}
    for i in itertools.count(0):
        if rest == 0:
            return 0
        if rest in seen:
            return i - seen[rest]

        seen[rest] = i
        rest = (rest * 10) % n
</code></pre>
<p>The last step is to test all numbers below 1000 and find the one with the
greatest cycle.</p>
<pre><code class="language-python">def reciprocal_cycles(n=1000):
    return max(((find_cycle(i), i) for i in range(2, n)))[1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carmichael-function"><a class="header" href="#carmichael-function">Carmichael function</a></h1>
<p>The <a href="problems/problem_0026/solution1.html">Brute force</a> solution works and is not that slow. Yet, with a
few observations, we can improve it.</p>
<ol>
<li>If you played a bit with the previous snippet of code, you might have notice
that most of the duplicate digits are 1. That's not a coincidence, the first
rest is also 1. In fact, what we are searching for is more known as the
result of
the <a href="https://en.wikipedia.org/wiki/Carmichael_function">Carmichael function</a>:</li>
</ol>
<blockquote>
<p>The Carmichael function associates to every positive interger \( n \) a
positive integer \lambda{n}, defined as the smallest positive integer \(
m \) such that
\[ a^m \equiv 1\ [ n ] \]</p>
</blockquote>
<p>In our case, \( a \) is always 10 and \( m \) is the length of the cycle we
are searching for the number \( n \).</p>
<p>Knowing that, we can try to make some observations:</p>
<ol start="2">
<li>
<p>Let \( f=\frac{1}{2^{a} 5^{b}} \), where \( a,b\in\mathbb{Z}_{\geqslant 0}
\). f has a finite and non-recurring decimal
representation. <a href="https://en.wikipedia.org/wiki/Decimal_representation#Finite_decimal_representations">Proof on Wikipedia</a>
.</p>
</li>
<li>
<p>If \( \frac{1}{m} \) is a repeating decimal and \( \frac{1}{n} \) is a
terminating decimal, them \( \frac{1}{mn} \) has a nonperiodic part whose
length is that of \( \frac{1}{n} \) and a repeating part whose length is
that of \( \frac {1}{m} \).
From <a href="https://mathworld.wolfram.com/RepeatingDecimal.html">Wolfram MathWorld</a></p>
</li>
<li>
<p>The recurring part of \( \frac{1}{d} \) cannot have more than \( d - 1 \)
digits. <a href="https://en.wikipedia.org/wiki/Carmichael_function#Order_of_elements_modulo_n">Proof on Wikipedia</a></p>
</li>
</ol>
<p>Let's try to use this information in our program:</p>
<p>We can reduce \( n \) by dividing it with \( 2 \) or \( 5 \) until it
become coprime with \( 10 \) (3). If after this reduction \( n = 1 \), \(
\frac{1}{n} \) has no recurring part (2).</p>
<p>We do not need to use a dictionary to find our cycle. Since \( n \) will be
coprime with 10, there will not be any leading number before the recurring
part (4). We know that if the rest is 1, we found our cycle (1).</p>
<pre><code class="language-python">def find_cycle(n):
    while n % 2 == 0:
        n /= 2
    while n % 5 == 0:
        n /= 5

    if n == 1:
        return 0

    i = 1
    r = 10
    while r != 1:
        r = (r * 10) % n
        i += 1

    return i
</code></pre>
<p>We can start from 1000 and iterate until \( \frac{n}{2} \) (2). If we find \(
n \) such that \( \lambda{n} == n - 1 \), there will be no point to go any
further (4).</p>
<pre><code class="language-python">def reciprocal_cycles(n=1000):
    max_cycle = 0
    res = 0
    for i in range(n, n // 2, -1):
        current_cycle = find_cycle(i)

        if current_cycle == i - 1:
            return i

        if current_cycle &gt; max_cycle:
            max_cycle = current_cycle
            res = i

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-25"><a class="header" href="#solution-25">Solution</a></h1>
<hr />
<blockquote>
<p>983</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="quadratic-primes"><a class="header" href="#quadratic-primes"><a href="https://projecteuler.net/problem=27">Quadratic primes</a></a></h1>
<blockquote>
<p>Euler discovered the remarkable quadratic formula:</p>
<p>\[n^2 + n + 41 \]</p>
<p>It turns out that the formula will produce \( 40 \) primes for the
consecutive integer values \( 0 \leq n \leq 39 \). However, when \( n =
40, 40^2 + 40 + 41 = 40(40 + 1) + 41 \) is divisible by \( 41 \), and
certainly when  is \( n = 41, 41^2 + 41 + 41 \) is clearly divisible by
\( 41 \).</p>
<p>The incredible formula \( n^2 -79n + 1601 \) was discovered, which
produces 80 primes for the consecutive values \( 0 \leq n \leq 79 \). The
product of the coefficients, \( −79 \) and \( 1601 \), is \( −126479 \).</p>
<p>Considering quadratics of the form:</p>
<p>\( n^2 + an + b \), where \( |a| &lt; 1000 \) and \( |b| \leq 
1000 \)</p>
<p>         where \( |n| \) is the modulus/absolute value of \( n \)<br />
         e.g. \( |11| = 11 \) and \( |-4| = 4 \)</p>
<p>Find the product of the coefficients, \( a \) and \( b \), for the 
quadratic expression that produces the maximum number of primes for 
consecutive values of \( n \), starting with \( n = 0 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-26"><a class="header" href="#brute-force-26">Brute force</a></h1>
<p>The problem is to find the best combination of \( a \) and \( b \) such that
the formula:</p>
<p>\[ n^2 + an + b \]</p>
<p>produces the largest number of primes for consecutive values of \( n \). The
absolute value of \( a \) and \( b \) must be less than \( 1000 \).</p>
<p>The brute force solution is to iterate from \( -1000 \) to \( 1000 \)
for \( a \) and \( b \) and count the number of consecutive primes each
time.</p>
<pre><code class="language-python">def quadratic_primes(limit=1000):
    res = 0
    max_primes = 0
    for a in range(-limit, limit):
        for b in range(-limit, limit):
            n = 0
            while isprime(n ** 2 + a * n + b):
                n += 1
            if n &gt; max_primes:
                max_primes = n
                res = a * b

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shorten-the-intervals"><a class="header" href="#shorten-the-intervals">Shorten the intervals</a></h1>
<p>If with take a closer look at the equation, we should find useful information.
For example, with some peculiar values of \( n \), we can narrow down the
ranges of \( a \) and \( b \).</p>
<p>We are searching \( p \) prime such that:</p>
<p>\[ p = n^2 + an + b \]</p>
<p>For \( n = 0\), the equation is \( p = b \). That means that \( b \)
must be a prime.</p>
<p>For \( n = b \), the equation is \( p = b^2 + ab + b = b(b + a + 1) \)
which is divisible by \( b \). \( b \) is in fact the limit of consecutive
primes that can be found using this equation.</p>
<p>Rearranging the equation we have:</p>
<p>\[ p = n^2 + an + b \Leftrightarrow p - b = n(n + a) \]</p>
<p>Since both \( p \) and \( b \) are prime, \( p - b \) is an even number.</p>
<p>If \( n \) is even then \( n(n + a) \) will also be even.<br />
If \( n \) is odd, then \( n(n + a) \) will be odd only if \( a \) is odd.</p>
<p>For \( n = 1 \), \( n^2 + an + b \) will never be a prime if \( a \) is
even.</p>
<p>All this information can help quite a bit:</p>
<ul>
<li>\( a \) must be an odd number between.</li>
<li>b must be a prime.</li>
<li>b is the upper limit of consecutive primes.</li>
</ul>
<pre><code class="language-python">def quadratic_primes():
    primes_b = list((primerange(0, 1000)))[::-1]  # b is prime.
    res = 0
    max_primes = 0
    for a in range(-999, 1000, 2):  # a is odd.
        for b in primes_b:
            if b &lt; max_primes:  # b is the limit for consecutive prime.
                continue

            n = 0
            while isprime(n ** 2 + a * n + b):
                n += 1

            if n &gt; max_primes:
                max_primes = n
                res = a * b

    return res
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lucky-numbers-of-euler"><a class="header" href="#lucky-numbers-of-euler">Lucky numbers of Euler</a></h1>
<p>Thanks
to <a href="https://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">mathworld</a>
, we know that if \( p(n) = n^2 + n + 41 \) is prime-generating for \(
0 \leq n \leq L \), then so is \( p(L - n) \).</p>
<p>\[ \begin{align} &amp;p(n) = n^2 + n + 41\\ &amp;p(L - n) = (L - n)^2 + L - n + 41\\ &amp;p(L - n) = L^2 - 2Ln + n^2 + L - n + 41\\ &amp;p(L - n) = n^2 - (2L + 1)n + L^2 + L + 41\\ &amp;p(L - n) = n^2 - (2L + 1)n + p(L)\\ &amp;p(L - n) = n^2 + an + b\\ &amp;where\ a = -(2L + 1)\ and\ b = L^2 + L + 41\\ \end{align} \]</p>
<p>We also know from the <a href="problems/problem_0027/solution2.html">Shorten the intervals</a> solution that when
\( n = 0 \), \( b = L^2 + L + 41 \) is prime. Since \( |b| &lt; 1000 \) we
have:</p>
<p>\[ b = L^2 + L + 41 &lt; 1000 \Rightarrow -31 \leq L \leq 31 \]</p>
<p>We also know that \( b \) is the upper limit of consecutive primes, it means
that \( b \) must be the largest number possible. It corresponds to \( L = 30
\) and \( b = 30^2 + 30 + 41 = 971 \) and \( a = -(2 \times 30 + 1)
= -61 \).</p>
<p>We can find a general solution based on the limit by searching the value of \(
L \) and then computing \( a \times b = (L^2 + L + 41) \times (-2(L + 1))
\).</p>
<p>The value of \( L \) is the largest solution for \( L^2 + L + 41 &lt; limit \)
.<br />
We have \( \Delta = 1 - 4(41 - limit) \), thus the solution is L = 
\( \left\lfloor \frac{-1 + \sqrt{4(41 - limit)}}{2} \right\rfloor \)</p>
<pre><code class="language-python">def quadratic_primes(limit=1000):
    l = floor((-1 + sqrt(1 - 4 * (41 - limit))) / 2)
    return (l ** 2 + l + 41) * (-(2 * l + 1))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-26"><a class="header" href="#solution-26">Solution</a></h1>
<hr />
<blockquote>
<p>-59231</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="number-spiral-diagonals"><a class="header" href="#number-spiral-diagonals"><a href="https://projecteuler.net/problem=28">Number spiral diagonals</a></a></h1>
<blockquote>
<p>Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:</p>
<p>\[
\begin{gather}
\color{red}{21}\ 22\ 23\ 24\ \color{red}{25}\\
20\ \ \ \color{red}{7}\ \ \ 8\ \ \ \color{red}{9}\ 10\\
19\ \ \ 6\ \ \ \color{red}{1}\ \ \ 2\ 11\\
18\ \ \ \color{red}{5}\ \ \ 4\ \ \ \color{red}{3}\ 12\\
\color{red}{17}\ 16\ 15\ 14\ \color{red}{13}\\
\end{gather}
\]</p>
<p>It can be verified that the sum of the numbers on the diagonals is 101.</p>
<p>What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral 
formed in the same way?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-27"><a class="header" href="#brute-force-27">Brute force</a></h1>
<p>This problem actually contains two problem. The first is the spiral creation
problem and the second is the diagonal sum problem.</p>
<p>The direction of the spiral is a cycle of 'EAST', 'SOUTH', 'WEST' and 'NORTH'
but the main question is to know when it changes.</p>
<p>There is many ways of creating a spiral matrix, but the idea I had was to insert
number in every cell in the same direction until the cell in the next direction
is empty.</p>
<p>Once the spiral matrix is created, we can compute the diagonal using the
<code>trace</code> function of numpy. We also need to remove the cell in the middle because
it will be counted twice.</p>
<pre><code class="language-python">def number_spiral_diagonals(n=1001):
    dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # EAST, SOUTH, WEST, NORTH
    cur_dir = 0
    (x, y) = (n // 2, n // 2)  # Center of the matrix
    spiral = np.zeros(n * n, dtype=int).reshape(n, n)
    spiral[x, y] = 1

    for i in range(2, n * n + 1):
        # Move along the current direction and update the new cell
        dx, dy = dir[cur_dir]
        x, y = x + dx, y + dy
        spiral[x, y] = i

        # If the cell in the next direction is empty: change direction
        dx, dy = dir[(cur_dir + 1) % 4]
        if spiral[x + dx, y + dy] == 0:
            cur_dir = (cur_dir + 1) % 4

    return np.trace(spiral) + np.trace(np.fliplr(spiral)) - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summation"><a class="header" href="#summation">Summation</a></h1>
<p>The sum of the diagonals is actually the sum of the 4 corners of each subcube of
the spiral matrix.</p>
<p>With:</p>
<p>\[
\begin{gather} \color{red}{21}\ 22\ 23\ 24\ \color{red}{25}\\ 20\ \ \ \color{red}{7}\ \ \ 8\ \ \ \color{red}{9}\ 10\\ 19\ \ \ 6\ \ \ \color{red}{1}\ \ \ 2\ 11\\ 18\ \ \ \color{red}{5}\ \ \ 4\ \ \ \color{red}{3}\ 12\\ \color{red}{17}\ 16\ 15\ 14\ \color{red}{13}\\ \end{gather} \]</p>
<p>The sum is \( (1) + (3 + 5 + 7 + 9) + (13 + 17 + 21 + 25) \)</p>
<p>For an \( n \times n \) grid, with n being odd, the top right corner is \( n^
2 \), the top left corner is \( n^2 -n + 1 \), the bottom left corner is \(
n^2 -2n + 2 \) and the bottom right corner is \( n^2 -3n + 3 \). The sum of
these corners is \( 4n^2 -6n + 6 \).</p>
<p>We need to sum these corners for all odd \( n \) between 3 and \( l \). Odd
numbers can be written in the form \( 2k + 1 \). By replacing \( n \)
with \( 2k + 1 \) we have:</p>
<p>\[ 4n^2 -6n + 6 = 4(2k+1)^2 -6(2k+1) + 6 = 16k^2 + 4k + 4 \]</p>
<p>The sum become:</p>
<p>\[ \begin{align} S &amp;= \sum _{k=1}^{m} 16k^{2} + 4k + 4\\ S &amp;= 16\sum _{k=1}^ {m} k^{2} + 4\sum _{k=1}^{m} k + 4\sum _{k=1}^{m} 1\\ S &amp;= \frac{16m(m+1) (2m+1)}{6} + \frac{4m(m + 1)}{2} + 4m\\ S &amp;= \frac{16m^3}{3} + 10m^2 + \frac{26m}{3}\\ \end{align} \]</p>
<p>where \( m = \frac{l - 1}{2} \)</p>
<p>This sum plus \( 1 \) (the center of the spiral matrix) is the solution we are
searching for:</p>
<pre><code class="language-python">def number_spiral_diagonals(n=1001):
    m = (n - 1) // 2
    return int(1 + (16 / 3) * m ** 3 + 10 * m ** 2 + (26 / 3) * m)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-27"><a class="header" href="#solution-27">Solution</a></h1>
<hr />
<blockquote>
<p>669171001</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="distinct-powers"><a class="header" href="#distinct-powers"><a href="https://projecteuler.net/problem=29">Distinct powers</a></a></h1>
<blockquote>
<p>Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
\[
\begin{align}
&amp;2^2=4, 2^3=8, 2^4=16, 2^5=32\\
&amp;3^2=9, 3^3=27, 3^4=81, 3^5=243\\
&amp;4^2=16, 4^3=64, 4^4=256, 4^5=1024\\
&amp;5^2=25, 5^3=125, 5^4=625, 5^5=3125\\
\end{align}
\]
If they are then placed in numerical order, with any repeats removed, we
get the following sequence of 15 distinct terms:</p>
<p>\[ 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125 \]</p>
<p>How many distinct terms are in the sequence generated by \( a^b \) for
\( 2 \leq a \leq 100 \) and \(2 \leq b \leq 100 \) </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-28"><a class="header" href="#brute-force-28">Brute force</a></h1>
<p>Using
python's <a href="https://python-reference.readthedocs.io/en/latest/docs/comprehensions/set_comprehension.html">{} set comprehension</a>
we can create a set with all the terms generated by the sequence: \( a^b \).
Since a set discards duplicate elements, the solution is the length of that set.</p>
<pre><code class="language-python">def distinct_powers(n=100):
    return len({a ** b for a in range(2, n + 1) for b in range(2, n + 1)})
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discarding-duplicate"><a class="header" href="#discarding-duplicate">Discarding duplicate</a></h1>
<p>We can actually solve this problem with pen and paper.</p>
<p>I won't explain the solution since <code>jorgbrown</code> has already done a great job in
his <a href="https://projecteuler.net/thread=29;page=3#6162">post</a>:</p>
<blockquote>
<p>Suppose \( a \) is a perfect square of the smaller \( a \), but not a
square of a square. Then we have a duplicate when \( b \) is \( 2, 3,
4\dots \) up to \( 50 \). That is, \( 49 \) duplicates.</p>
<p>Suppose \( a \) is a perfect cube of a smaller \( a \). When \( b \)
is \( 2 \) through \( 33 \), we have duplicates of smaller \( a \)
raised to the power \( b\times3 \). When \( b \) is \( 34, 36, 38, 40,
42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66 \), we have duplicates
of a smaller \( a \) raised to the power \( (\frac{b}{2})\times3 \).
Total is \( 32 + 17 \), or again, \( 49 \) duplicates.</p>
<p>Suppose \( a \) is the square of the square of a smaller \( a \). When
\( b \) is \( 2 \) through \( 49 \), we have duplicates of the square
root of a raised to the power \( (b\times2) \).<br />
When \( b \) is \( 51, 54, 57, 60, 63, 66, 69, 72, \) or \( 75, \) we
have dupes of \( a^{(\frac{3}{4})} \) raised to the power \( \frac
{b\times4} {3} \). Total is \( 49 + 9 \), or \( 58 \).</p>
<p>Suppose \( a \) is the fifth power of a smaller \( a \). We have dupes of
fifth root of a raised to the power \( (b\times5) \), which covers \( b \)
from \( 2 \) to \( 20 \). Then we have dupes of \( a^{(\frac{2}{5})} \)
raised to the power \( \frac{b\times5}{2} \), which covers \( b \) of
\( 22, 24, 26, 28, 30, 32, 34, 36, 38, 40 \). Then we have dupes of \(
a^{(\frac{3}{5})} \) raised to the power \( \frac{b\times5}{3} \), which
covers \( b \) of \( 21, 27, 33, 39, 42, 45, 48, 51, 54, 57, 60 \).
Last, we have dupes of \( a^\frac{4}{5} \) raised to the power \(
\frac{b\times5}{4} \), which covers \( b \) of \( 44, 52, 56, 64, 68, 72,
76\), and \( 80 \). Total dupes: \( 48 \).</p>
<p>And the last power we have to worry about is \( 6 \). We have dupes of the
square root of a raised to power \( (b\times2) \), which covers \( b \)
from \( 2 \) to \( 50 \). Then we have dupes of the sixth root to the power
\( \frac{b\times6}{4} \), which covers \( b \) of \( 52 \),
\( 54, 56, 58, 60, 62, 64, 66 \). And last we have dupes of the sixth
root to the power \( \frac{b\times6}{5} \), which covers \( b \) of \(
55,
65, 70, 75 \), and \( 80 \). Total dupes: \( 62 \).</p>
<p>Now let's put it all together:</p>
<p>squares: \( 4, 9, 25, 36, 49, 100 \): These \( 6 \) squares have \(
49 \) dupes each, \( 6 \times 49 \) = \( 294 \)</p>
<p>cubes: \( 8, 27 \): These \( 3 \) cubes have \( 49 \) duplicates
each: \( 2 \times 49 = 98 \)</p>
<p>4th power: \( 16, 81 \). These \( 2 \) have \( 58 \) dupes each: \( 2
\times 58 = 116 \)</p>
<p>5th power: \( 32 \). This has \( 48 \) dupes.</p>
<p>6th power: \( 64 \): this has \( 62 \) dupes.</p>
<p>Total # dupes: \( 618 \). \( 9801-618 \) is \( 9183 \).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-28"><a class="header" href="#solution-28">Solution</a></h1>
<hr />
<blockquote>
<p>9183</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="digit-fifth-powers"><a class="header" href="#digit-fifth-powers"><a href="https://projecteuler.net/problem=30">Digit fifth powers</a></a></h1>
<blockquote>
<p>Surprisingly there are only three numbers that can be written as the sum 
of fourth powers of their digits:</p>
<p>\[
\begin{align}
1634 &amp;= 1^4 + 6^4 + 3^4 + 4^4\\
8208 &amp;= 8^4 + 2^4 + 0^4 + 8^4\\
9474 &amp;= 9^4 + 4^4 + 7^4 + 4^4\\
\end{align}
\]</p>
<p>As \( 1 = 1^4 \) is not a sum it is not included.</p>
<p>The sum of these numbers is \( 1634 + 8208 + 9474 = 19316 \).</p>
<p>Find the sum of all the numbers that can be written as the sum of fifth
powers of their digits.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-29"><a class="header" href="#brute-force-29">Brute force</a></h1>
<p>Finding number that can be written as the sum of fifth powers of theirs digits
is easy. The main difficulty of this problem is to find an upper bound and thus
to know when to stop the iteration.</p>
<p>The sum of the fifth powers of a \( n \)-digits number will always be less
than or equal to \( n * 9^5 \). We need to find \( n \) such that \( n *
9^5 &lt; 10^n - 1 \) for all \( n \). The solution is actually very complex, but
with \( n = 5 \) we have \( 5 * 9^5 = 295245 &gt; 10^5 - 1 \) and with \( n =
6 \) we have \( 6 * 9^5 = 354294 &lt; 10^6 - 1 \). Which implies that it is
pointless to try any number with more than 6 digits.</p>
<pre><code class="language-python">def digit_fifth_powers():
    return sum((n for n in range(2, 999999)
                if sum(int(i) ** 5 for i in str(n)) == n))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="search-unique-combination"><a class="header" href="#search-unique-combination">Search unique combination</a></h1>
<p>There is no need to try all numbers with at most 6 digits. What is really
important is to try all combinations of numbers with at most 6 digits. For
example, the sum of the fourth powers of digits of \( 1346 \) is the same as
the sum of \( 1634, 1436\dots \) But even if the sum is the same for \(
1356 \) and \( 1634 \), only \( 1634 \) has a sum equal to itself. So how
can we avoid calculating duplicate combinations but still find the solution ?</p>
<p>We need to build a list of these combinations, which is easily done with a
recursive function. The idea is to create the string so that the digits are
sorted. The stopping condition is the number of digits. Recursive functions are
a pain to understand, but if you print the result and the string after each
iteration, you should understand the function without too much trouble.</p>
<p>I used <code>yield</code> instead of building an entire list, but you can consider that
it's the same thing.</p>
<pre><code class="language-python">def build_combination(d, n=0, s=''):
    if d == 0:
        yield s
    else:
        for i in range(n, 10):
            for v in build_combination(d - 1, i, s + str(i)):
                yield v

</code></pre>
<p>The trick is to compute the sum a first time, for example, taking \( 1346 \)
which sum is equal to \( 1^5 + 3^5 + 4^5 + 6^5 = 1634 \). Then, repeat the
operation a second time \( 1^5 + 6^5 + 3^5 + 4^5 = 1634 \). If the total is
the same for both computations, then you have found one combination that works.</p>
<p>Instead of computing the fifth power of each digit, we can compute them once and
store them in a cache. The rest is just trying all the previously found
combinations. We need to remove <code>1</code> from the final result as the problem
indicates.</p>
<pre><code class="language-python">def digit_fifth_powers():
    cache = [i ** 5 for i in range(0, 10)]
    res = 0
    for n in build_combination(6):
        total = sum(cache[int(c)] for c in n)
        if sum(cache[int(c)] for c in str(total)) == total:
            res += total

    return res - 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-29"><a class="header" href="#solution-29">Solution</a></h1>
<hr />
<blockquote>
<p>443839</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="coin-sums"><a class="header" href="#coin-sums"><a href="https://projecteuler.net/problem=31">Coin sums</a></a></h1>
<blockquote>
<p>In the United Kingdom the currency is made up of pound (£) and pence (p).
There are eight coins in general circulation:</p>
<p>\[ \text{1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).} \]<br />
It is possible to make £2 in the following way:</p>
<p>\[ 1\times£1 + 1\times50p + 2\times20p + 1\times5p + 1\times2p + 3\times1p \]
How many different ways can £2 be made using any number of coins?</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brute-force-30"><a class="header" href="#brute-force-30">Brute force</a></h1>
<p>We are searching for all the combination to make 2 pounds using the eights
following coins in pence:</p>
<blockquote>
<p>1, 2, 5, 10, 20, 50, 100, 200.</p>
</blockquote>
<p>Combination implies that making 2 pounds with <code>100 + 50 + 50</code> pences is the same
as <code>50 + 100 + 50</code> pences. To avoid this, we will try every piece one by one in
increasing order.</p>
<p>The algorithm will use an accumulator that will increase with each iteration of
the function:</p>
<ol>
<li>If the accumulator reaches 200, a combination has been found.</li>
<li>If the accumulator is greater than 200 the current combination will not work.</li>
<li>If the accumulator is less than 200, add a new piece. To avoid duplicate
combinations, always add piece larger than or equal to the last one.</li>
</ol>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution1.py">solution1.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]

    def coin_sums_rec(accumulator, minimum_piece):
        if accumulator == n:
            return 1
        if accumulator &gt; n:
            return 0

        return sum(coin_sums_rec(accumulator + coins[new_piece], new_piece)
                   for new_piece in range(minimum_piece, len(coins)))

    return coin_sums_rec(0, 0)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-programming-3"><a class="header" href="#dynamic-programming-3">Dynamic programming</a></h1>
<p>The last solution does not scale to the number of parts or the target. We can do
better using dynamic programming, but first, we must divide the problem into
subproblems.</p>
<p>Let's start with the ways to do 1p using all the pieces we have. The table is a
cumulative sum, so the value of each cell is the number of ways to have the
target using the pieces up to the current one. We consider that there is only
one way to do 0p, so the first column is always 1.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
</tbody></table>
</div>
<p>This table means that there is only one way to express 1p, no matter what coins
we are using.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">2p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
</tbody></table>
</div>
<p>2p can be expressed using 1p: 1p + 1p, but also using 2p. With the other coins
the result remain the same.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">1</th><th style="text-align: center">\( \leq \)2</th><th style="text-align: center">\( \leq \)5</th><th style="text-align: center">\( \leq \)10</th><th style="text-align: center">\( \leq \)20</th><th style="text-align: center">\( \leq \)50</th><th style="text-align: center">\( \leq \)100</th><th style="text-align: center">\( \leq \)200</th></tr></thead><tbody>
<tr><td style="text-align: center">0p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">1p</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr>
<tr><td style="text-align: center">2p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center">3p</td><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td></tr>
<tr><td style="text-align: center">4p</td><td style="text-align: center">1</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td><td style="text-align: center">3</td></tr>
<tr><td style="text-align: center">5p</td><td style="text-align: center">1</td><td style="text-align: center">3</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td><td style="text-align: center">4</td></tr>
</tbody></table>
</div>
<p>You might start to understand how this table was computed:</p>
<ul>
<li>The first column is always 1, there is only one way to express any target
with 1p.</li>
<li>The first row is always 1, there is only one way to express 0p.</li>
<li>For the rest we construct the table lines by lines, the current cells is the
sum of two possibilities:
<ul>
<li>The new coin is not used,</li>
<li>The new coin is not used: the number of ways to make \( n \) is the
number of way to make \(n - 1 \) using the same coins, which is the
value in the left cell.</li>
<li>If possible, the new coin is used: the number of ways to make \( n \) is
the number of ways to make \( n - c \) using the same coins, which is
the value in the cell on the same column but on the line \( n - c \).</li>
</ul>
</li>
</ul>
<p>For example with the last line, the first column is obviously 1
and the second is: 1 (left cell) + 2 (the number of ways to make \( 5p -
2p = 3p \), above cell).</p>
<p>So, using a cache table, we can drop the time complexity from \( O(m^n) \) to
\( O(nm) \), where \( n \) is the target and \( m \) the number of
coins. But we now have an \( O(nm) \) space complexity.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution2.py">solution2.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    cache = [[1] + [0] * (len(coins) - 1) for _ in range(n + 1)]

    for i in range(n + 1):
        for j in range(1, len(coins)):
            cache[i][j] = cache[i][j - 1]
            if coins[j] &lt;= i:
                cache[i][j] += cache[i - coins[j]][j]

    return cache[-1][-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="better-dynamic-programming"><a class="header" href="#better-dynamic-programming">Better dynamic programming</a></h1>
<p>Dynamic programming can be a bit improved by using a single array instead of a
table. The array will contain the number of ways to make \( n \) using the
coins we have. The array will be initialized with 1, and we will update it by
adding the number of ways to make \( n - c \) to the current value. This way
we will only need \( O(n) \) space. The time complexity will be the same
as the previous solution, but the space complexity will be better.</p>
<p>From <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/problems/problem_0031/solution3.py">solution3.py</a>:</p>
<pre><code class="language-python">def coin_sums(n=200):
    coins = [1, 2, 5, 10, 20, 50, 100, 200]
    cache = [1] + [0] * n

    for coin in coins:
        for i in range(coin, n + 1):
            cache[i] += cache[i - coin]

    return cache[-1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solution-30"><a class="header" href="#solution-30">Solution</a></h1>
<hr />
<blockquote>
<p>73682</p>
</blockquote>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>You can download each solution and modify it as much as you like. However, 
please do not copy the answer to the Euler project without thinking about it 
first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>You can contribute as much as you want to the project, for more information
please see <a href="https://github.com/TurtleSmoke/Project-Euler/blob/main/README.md">README.md</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
